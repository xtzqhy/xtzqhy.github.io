[{"title":"2024.10.3","url":"/2024/10/03/2024-10-3/","content":"模拟赛\n\n数据范围：n \\le 100,1\\le a_i,b_i,c_i \\le 10^9\n值域很大，无法加到状态里。那么考虑每个操作对答案产生的贡献。\n我们把攻击力拆开来算。\n直接攻击，那么贡献就是 a_i。\n设这回合后一共攻击 j 次。\n加攻击力，那么在这以后每次攻击伤害都会加 c_i，贡献就是 j\\times c_i\n加增量，那么设后续攻击的回合是 p_1,p_2,\\cdots,p_j，那么贡献为 \\sum_{k=1}^j (p_k-i)\\times b_i。\n把这个东西稍微拆一下，得到 b_i(\\sum_{k=1}^j p_k-j\\times i)。\n那么我们只需要记录攻击次数和攻击回合的编号和即可。\n但有个问题，我们现在的贡献和未来回合的行动有关。\n所以要倒过来做。那么转移也要相应的变一下。\n设 f_{i,j,k} 表示第 i 个回合到最后一个回合，一共攻击了 j 次，攻击回合的编号和为 k 的最大值。\n转移为\n\nf_{i,j+1,k+i}=f_{i+1,j,k}+a_i\n\\\\\nf_{i,j,k}=f_{i+1,j,k}+(i\\times j-k)\\times b_i\n\\\\\nf_{i,j,k}=f_{i+1,j,k}+j\\times c_i转移时可以把第一维压掉，但第二维要倒序枚举。\n复杂度 O(n^4)。\nCode：\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=110,inf=1e18;int n;int a[maxn],b[maxn],c[maxn],f[maxn][maxn*maxn];inline void solve()&#123;    cin&gt;&gt;n;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];    reverse(a+1,a+n+1);reverse(b+1,b+n+1);reverse(c+1,c+n+1);    memset(f,-0x3f,sizeof f);    f[0][0]=0;    for(re int i=1;i&lt;=n;++i)&#123;        for(re int j=i-1;j&gt;=0;--j)&#123;            for(re int k=0;k&lt;=(i-1)*i/2;++k)&#123;                f[j+1][k+i]=max(f[j+1][k+i],f[j][k]+a[i]);                f[j][k]=max(f[j][k],f[j][k]+max((i*j-k)*b[i],j*c[i]));            &#125;        &#125;    &#125;    int ans=-inf;    for(re int i=0;i&lt;=n;++i) for(re int j=0;j&lt;=n*(n+1)/2;++j) ans=max(ans,f[i][j]);    cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    int T;cin&gt;&gt;T;while(T--) solve();    return 0;&#125;\nRemoving Leaves *2300\n又读错题被硬控了。\n一开始没看见 k，以为随便删。\n考虑贪心。\n我们用 set 存每个节点，然后每次找到叶子最多的那个点，然后删 k 个。找不到就结束。\n这为什么是对的？\n感性理解一下，我们这么做只会让能删的点越来越多，而且不会有本来能删的点因为操作而不能删除，所以这么做操作数就是最大的。\n复杂度 O(n\\log n)\nVoting (Hard Version) *2400\n看完题就想到了一个假贪心：先按 m 降序再按 p 升序，每次买 m 最大 p 最小的。\n显然不对。我们不一定只从 m 最大的里面买。\n那改成每次买 p 最小的呢？\n还是不对。因为不一定买最小的就优。例如这组样例\n21 12 2\n显然只需要 2 即可。\n那应该怎么做？\n我们依旧按 m 降序排序。\n对于当前的 m_i，设 m 值小于 m_i 的人数为 pre，大于 m_i 且被买的人数为 cnt。\n假设我们已经把 < m_i 的人全搞定了，那么只需要让 pre+cnt\\ge m_i，就能搞定 m_i了。\n但如果不满足，我们就要从 \\ge m_i 的人里买人（因为 pre 是固定的），直到 pre+cnt\\ge m_i。\n满足该条件后，m_i 就被我们搞定了。\n那么我们只需要保证 < m_i 的人都被搞定就行了。\n然后再处理 < m_i 的那些人。这是一个子问题，和上述步骤完全一致。\n买人贪心买最便宜的，用个堆维护一下即可。\n复杂度 O(n\\log n)\nHappy Life in University *2300\n怎么现在啥数据结构都不会了/kk。\n对于这种 lca 的问题，常见套路是枚举 lca，把贡献都在 lca 处统计（枚举 lca 的意思是考虑每个点作为 lca 时的情况）。\n而这种 lca 的路径问题又能跟子树弄上关系。\n设当前考虑到以 u 为根的子树。\n那么我们只需要维护 u 到子树内节点的路径即可，答案就是拿两条路径拼起来。\n假设已经搜完了子树，回溯到了 u。\n那么 u 会对所有路径产生自己颜色的贡献。\n但显然会算重，那么考虑去重。\n因为每个点只需要在离他最近的且颜色和他相同的祖先处减去重复，所以只会操作 O(n) 次。\n那么直接去重就是对的。\n所以我们的操作就只有子树加和子树查，线段树维护。\n答案用最大值和次大值拼一下即可。\n复杂度 O(n\\log n)\nWine Factory (Easy Version) *2300\n讲一个很有意思的做法。\n我们考虑有多少水被浪费了。\n设 f_i  表示从 i 流向 i+1 的水的量。\n转移为 \n\nf_i=\\max(f_{i-1}+a_i-b_i,0)这东西可以用 (max,+) 矩乘表示。\n\n\\begin{bmatrix}\nf_i \n\\\\\n0 \n\\end{bmatrix}\n=\n\\begin{bmatrix}\na_i-b_i & 0 \n\\\\\n-inf & 0\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\nf_{i-1} \n\\\\\n0 \n\\end{bmatrix}然后线段树维护矩阵即可。单点修改也是简单的。\n复杂度 O(k^3n\\log n)\nMark and Professor Koro *2300\n感觉和 [HBCPC2024] Enchanted 非常的像啊，套路也是一样。\n对于这种两个相同的数合并成+1的数的操作，我们可以把它看成二进制意义下的加法，然后进行维护。\n但这个题不能直接把数的二进制用整数表示，值域太大了。\n我们用线段树维护值域上每个数出现次数，不难发现每个数出现次数只会为 0/1。\n那么修改可以看成删一个数再加上一个数。\n删和加是类似的，先考虑加。设加的那个数是 x。\n如果 x 那一位是 0，那么不用进位，直接给这一位 +1 即可。\n否则会进位。但不难发现，这东西是一次区间覆盖和一次单点修改。\n删数同理。\n如果 x 那一位是 1，那么不用退位，直接给这一位 -1 即可。\n否则会退位。依旧是一次区间覆盖和一次单点修改。\n那么答案就是最右边的 1 的位置，这个可以线段树上二分找到。\n具体的，线段树上维护区间里 1 的个数。\n加法进位：找到 x 后第一个为 0 的位置 pos，然后把 [x,pos-1] 区间赋值为 0，把 pos 赋值为 1.\n减法进位：找到 x 后第一个为 1 的位置 pos，然后把 [x,pos-1] 区间赋值为 1，把 pos 赋值为 0.\n找位置都可以线段树上二分。\n复杂度 O(n\\log n)\n","categories":["每日记录"],"tags":["模拟赛","Codeforces","dp","数据结构","贪心","矩阵乘法"]},{"title":"2024.10.4","url":"/2024/10/04/2024-10-4/","content":"模拟赛\n\n数据范围：1\\le n \\le 3\\times 10^5\n感觉自己的思路非常自然，所以写一下。\n一开始读错题了，没弄懂它的 s_1=s_2 是啥意思，以为只要元素一样就行了不用管顺序。\n如果不管顺序，那答案就是 \\sum_{i=1}^n \\binom{n}{i} \\times 2^i。\n但是我们是需要考虑顺序的。\n那么我们考虑什么时候是不合法的。\n例如 3773，这种情况下是不能把这两个数都选进去的，因为一定无法满足顺序一样。\n如果我们把每个数看成一条线段，那么可以发现，这种不合法的情况就是两条线段是包含关系。\n然后考虑合法情况。\n例如样例里的 1122，可以发现怎么选都是合法的。\n不难发现，这种情况是两条线段无交。\n再例如 1212，可以发现只有两种情况是合法的，要么都选左端点要么都选右端点。\n不难发现，这种情况是两条线段有交且不包含。\n但如果是一堆线段怎么办？\n如果连续若干条线段有交，可以发现总贡献依旧为 2。\n如果连续若干条线段无交，可以发现总贡献为 2^{num}。\n那么考虑 dp。\n设 f_i 表示第 i 条线段的贡献，转移为\n\nf_i=\\sum_{l_i>r_j}2\\times f_j+\\sum_{l_ir_j} f_j初始值为 f_i=2，因为每条线段都有两种选择。\n复杂度是 O(n^2) 的。考虑优化。\n不难发现，我们可以用前缀和来转移。\n但这样会少算一部分和多算一部分。\n我们把 dp 值放到每条线段的右端点上，然后用树状数组直接查询就可以了。\n复杂度 O(n\\log n)\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define lb(x) (x&amp;(-x))using namespace std;const int maxn=3e5+10,mod=998244353,inf=6e5;int n,ans;int f[maxn],s[maxn],tr[maxn&lt;&lt;1];struct line&#123;    int l,r;    inline bool operator &lt; (const line &amp;a)const&#123;        return l&lt;a.l;    &#125;&#125;t[maxn];inline void add(int x,int val)&#123;while(x&lt;=inf) tr[x]=(tr[x]+val)%mod,x+=lb(x);&#125;inline int query(int x)&#123;int res=0;while(x) res=(res+tr[x])%mod,x-=lb(x);return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;std.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n;    for(re int i=1,x;i&lt;=2*n;++i)&#123;        cin&gt;&gt;x;        if(!t[x].l) t[x].l=i;        else t[x].r=i;    &#125;    sort(t+1,t+n+1);    for(re int i=1;i&lt;=n;++i)&#123;        f[i]=2;        f[i]=(f[i]+s[i-1])%mod;        f[i]=(f[i]+query(t[i].l))%mod;        f[i]=((f[i]-(query(inf)-query(t[i].r))%mod)%mod+mod)%mod;        add(t[i].r,f[i]);        s[i]=(s[i-1]+f[i])%mod;    &#125;    for(re int i=1;i&lt;=n;++i) ans=(ans+f[i])%mod;    cout&lt;&lt;ans;    return 0;&#125;\n","categories":["每日记录"],"tags":["模拟赛","dp","数据结构"]},{"title":"2024.10.2","url":"/2024/10/02/2024-10-2/","content":"Team Building *2300\n首先可以想到暴力 dp。\n设 f_{i,j,S} 表示前 i 个人，选了 j 个观众，队伍的选择状态为 S。\n复杂度是炸的。\n但仔细想想，我们真的要记这么多状态吗？\n如果你把这道题想成一个普通的背包，那就错了，因为这题很特殊。\n每个物品的体积都是 1。\n这说明此时贪心是正确的。\n我们按观众值降序排序，那么对于观众值而言，一定是全选前面的更优。\n设 f_{i,S} 表示前 i 个人，队伍的选择状态为 S，num_S 为 S 里 1 的个数。\n转移时，如果当前观众人数小于 k，那么一定是让他当观众最优。\n因为观众是能选就选的，所以观众人数很容易得出，就是 i-num_S。\n复杂度 O(n2^p)\nMinimal Labels *2300\n第一眼看到以后以为是拓扑板子，直到看到第三个样例。\n经过手玩可以发现，我们应该每次都先填未填的点里编号最小的点，这样才能让字典序更小。\n但是编号最小的点可能被一些点指向，所以要先把前面的那些点给填上。\n前面那些点又构成一张新图，这就是一个子问题了，递归解决即可。\n找前面点可以建反图往回跑即可。\n复杂度？\n然而正解是建反图后拓扑，然后倒序编号。\n我们刚才的思路都是正着来的，那为什么倒着才是对的呢？\n正解是对的比较好理解，但感性理解一下，我们的做法似乎和倒着做是一样的？\nTrains and Statistic *2300\n类似 Floyd，对于两个点，我们要么一步到，要么找一个中转点。\n而这道题不需要 O(n^3) 的原因是：每个点能到的区间是一定的。\n所以我们可以贪心。\n既然一步走不到，那肯定走的越远越好。\n所以我们一定会从 i 走到 [i+1,a_i] 里 a 最大点 j。\n设 f_i=\\sum_{j=i+1}^n p_{i,j}。\n那么 f_i 只会从 f_j 转移来。\n转移为\n\nf_i=f_j+n+j-a_i-i首先让编号 >j 的点强制从 j 转移过去，那么这部分答案是 f_j+n-j。\n这会把 [j+1,a_i] 里的点多算一步，那么减去 a_i-(j+1)+1。\n最后加上 [i+1,j] 的点，他们只需要走一步，是 j-(i+1)+1。\n合起来就是 f_j+n+j-a_i-i。\n求 j 是一个 RMQ 问题，随便做。\n复杂度 O(n\\log n)\nMonster Invaders *2300\n又读错题。\n贪心肯定是很难贪的。考虑 dp。\n但是 dp 是不是有后效性？毕竟可以从前面过来，还可以从后面过来。\n难道要高斯消元解方程组？复杂度也接受不了啊。\n但你仔细想想，我们真的会从很后面的地方过来吗？\n显然不会。\n如果我们现在在 i，剩个 boss 差一血没打死，然后被强制移到了 i+1。\n假设我们一直往后打，直到  j 才往回走，把 i 剩下的 boss 打死。\n那么我们为什么不在被迫移动到 i+1 的时候就直接回去把 boss 打死？这肯定更优。\n想明白了这个，剩下就很简单了。\n然后考虑用什么方式把 i 清完。\n这里我读错题了，没看到 r_1 \\le r_2 \\le r_3。\n既然这样，那么每个房间只有这几种方法：\n\n手枪打小怪，AWP 打 boss。\n用激光枪（或手枪）对所有人各打一点伤害，被迫移动后，再移动回来，然后手枪解决 boss。\n\n转移很简单。\n注意最后重点可能是 n-1，也可能是 n。\nKeshi in Search of AmShZ *2300\n竟然是原理题。\n读完题后又瞬间想到一个假贪心：把最短路以外的边封掉，然后强制走最短路。\n显然不正确。我们可以少封一些边，然后走最长路，这样代价可以更小。\n考虑这张图确定了下来，那么对方一定会走最长路。\n设 f_u 表示 u 到 n 的最大代价。\n考虑一条边 (u,v)，如果我们经过了这条边，那么说明经过 u 必须是一条最长路。\n那么我们必须把比 u 还长的删掉。即转移为\n\nf_u=\\min_{v \\in to_u} (f_v+1+\\sum_{v'\\in to_u} [f_{v'}>f_v])直接转移复杂度是炸的。\n那么能不能在反图上跑时转移呢？\n但是如果倒着转移的话，无法确定 \\sum_{v'\\in to_u} [f_{v'}>f_v]) 的值。\n然后我们钦定转移顺序，让 f_v 从小到大转移，这样 \\sum_{v'\\in to_u} [f_{v'}>f_v]) 就满足了单调性。\n用优先队列维护最小即可。\n复杂度 O((n+m)\\log m)\n","categories":["每日记录"],"tags":["Codeforces","dp","贪心"]},{"title":"2024.9.29","url":"/2024/09/29/2024-9-29/","content":"Funny Game *2200\n看了半个小时不会后看题解被嘲讽简单题后破防。\nKirill and Company *2200\n终于做到会的题了。\n看到 k 这么小，直接考虑状压。\n在处理最短路时，我们还要处理出每个点的搭载朋友情况。\n最后就是一个背包。\n复杂度 O((n+m)2^k+f(2^k)^2)\nRailguns *2200\n你指尖跃动的电光，是我此生不变的信仰。\n似乎不太难想？\n首先可以发现，答案上界为 n+m+r，因此可以枚举答案。\n设 f_{i,j,k} 表示第 k 秒时能否到达 (i,j)。转移为\n\nf_{i,j,k}|=(f_{i-1,j,k-1}|f_{i,j-1,k-1}|f_{i,j,k-1})我们在最外层枚举时间，然后 dp 即可。\n至于超电磁炮，我们都已经枚举时间了，那 dp 之前把对应状态直接限制一下就行了。\n复杂度 O(nmr)\n","categories":["每日记录"],"tags":["Codeforces","dp"]},{"title":"2024.9.30","url":"/2024/09/30/2024-9-30/","content":"Darth Vader and Tree *2200\n首先考虑暴力。\n设 f_i 表示距离根距离恰好为 i 的数量。转移为\n\nf_i=\\sum_{j=1}^n f_{i-d_j}但观察数据范围，发现 d_i\\le 100，说明不同的 d_i 很少。\n那么只需要对这些不同的 d_i 转移就行了。\n设 num_i=\\sum_{j=1}^n [d_j=i]，那么转移为\n\nf_i=\\sum_{j=1}^V num_j\\times f_{i-j} 这是一个常系数齐次线性递推方程，BM算法矩阵快速幂即可。\n最终答案为 \\sum_{i=1}^x f_i，可以在矩阵里顺便维护一下。\n复杂度 O(V^3\\log x)\nVladik and cards *2200\n容易想到状压。\n但第一个条件感觉很难搞，没法记录每个元素出现次数，怎么办？\n我们可以二分出所有的数字的最小出现次数 mid，那么每个元素出现次数只能为 mid 和 mid+1（经常在错解里想到这种思路，终于在这道题成为正解了）。\n设 f_{i,S} 表示到第 i 个位置，数字出现状态为 S 时，出现次数为 mid+1 的数的最大个数。\n这么设状态是因为，一个数的出现次数只能为 mid 和 mid+1，那肯定让 mid+1 的个数越多越好。\n转移比较简单，看每个数字出现 mid 次还是 mid+1 次即可。\n我们可以把每个数字出现的位置记录下来，方便转移。\n注意每种数字必须连续，也就是出现过后就不能再转移了。\n复杂度 O(2^Vn\\log n)\nTreeland Tour *2200\n树上路径问题直接考虑点分治。\n设当前分治重心为 rt，我们求出从叶子往 rt 走且以 i 结尾的 LIS 和 LDS。\n这个东西怎么求呢？\n每个点都只能从子树转移来，所以问题就是单点加子树查，弄个 dfn 序后线段树维护即可。\n统计答案时，考虑包不包含 rt。\n设 up_i 表示以 i 结尾的 LIS 长度， down_i 表示以 i 结尾的 LDS 长度。\n对 up_i 和 down_i 分别做前缀 max 和后缀 max。\n包含 rt：ans=\\max up_{a_{rt}-1}+down_{a_{rt}+1}+1\n不包含 rt：ans=\\max up_i+down_{i+1}\n然后完了？\n显然没有，因为如果两条路径来自同一颗子树内就寄了。\n那么线段树在维护时，记录最大值和次大值，以及来自哪棵子树即可。\n统计答案时特判一下。\n复杂度 O(n\\log^2 n)\nFelicity’s Big Secret Revealed *2200\n简单性质题。\n不难发现答案 x 不会很大。因为 n\\le 75，所以 x\\le 20。 \n那就考虑状压，设 f_{i,S} 表示这一刀切在 i 前，状态为 S 时的方案数。\n转移就枚举上一刀切在哪。\n转移为 \n\nf_{i,S}=\\sum f_{j,S/T}把 [j,i-1] 组成的数去掉即可。\n答案为 \\sum f_{i,2^j-1}\n复杂度 O(n2^V)\nAbbreviation *2200\n唐唐唐，下次读题能不能读仔细点。\n做了半个小时+看了半天题解才发现翻译里最后一句写着“至多进行一次操作”\n绷不住了。\n那就好做了。枚举缩哪一段区间即可。\n具体的，我们可以先处理出 f_{i,j} 表示 i 和 j 向后匹配的最长长度。\n然后枚举缩哪段区间，然后向后暴力缩就行了。\n复杂度 O(n^3+n|\\sum s_i|)\n代码可参考官方题解。\nThree Pieces *2200\n很厉害的一道题，完全没想出来。\n考虑 dp。\n设 f_{i,j,k,0/1/2} 表示当前在 (i,j)，已经填了 1\\sim k，且当前是 0/1/2 棋子的最小花费。\n但这个 dp 有一个问题：不知道转移顺序。\n所以考虑用最短路转移。\n转移分三种：\n\n换棋子，代价为 inf+1\n移动棋子，代价为 inf\n填数（即 (i,j) 所在的数是下一个数），代价为 0\n\n这里有一个 trick：因为还要求换的次数最小，所以可以设一个极大值，将移动棋子设为 inf，换棋子设为 inf+1，这样就可以做到双关键字了。\n输出答案时，时间就是 ans/inf，换的次数就是 ans\\%inf。\n一共 O(n^4) 个点，O(n^5) 条边。\n","categories":["每日记录"],"tags":["Codeforces","dp","数据结构","贪心","矩阵乘法"]},{"title":"2024.9.27","url":"/2024/09/27/2024-9-27/","content":"一直在搭博客没怎么做题啊···\nTourism *2200\n首先手玩样例可以发现：环上的点可以都拿，连接环的点也可以都拿。\n然后考虑剩下的点。\n因为剩下的点只能选一条点权和最大的路径，所以考虑拓扑 dp。\n那么答案就是起点到环经过的点 + 环上的点的点权和 + \\max f_i\n学到的东西：看到这种类似不能重复走一条边的东西可以考虑缩点双（因为割边走过去不能回来）\nHappy Line *2200\n感觉很困难。我是性质低手/kk。\n假设当前 a_i,a_{i+1}  需要操作，那么操作完后会变成 a_{i+1}+1,a_i-1。\n对于 a_i，可以发现 a_i+i=(a_i-1)+(i+1)。\n即 val_i+pos_i=val_i'+pos_i'。\n不难推出，对于所有 i，都有 a_i+i 为定值。\n那么将 a_i+i 排序得到序列 b，答案就是 b_i-i。\n无解就是存在 b_i=b_{i+1}。\n学到的东西：对于这种交换位置的题，要往排序想，分析两个元素交换带来的影响（类似微扰法）。\nShort Code *2200\n读完题瞬间想到一个假做法：按长度从小到大排序，然后模拟。\n但这很容易 hack。对于一个很长的串，我们完全可以让它取很短的一部分，让一些短串取稍微长一些。这样比长串取很长短串取很短要优。\n那从大到小呢？也不行。\n因为很有可能长串取完以后，一些短串作为长串的前缀，就算全取也无法避免重复，这就不合法了。\n然后不会了。\n正解：\n建立 trie 树。此时问题变为：\n给一棵树，有一些黑点。可以把黑点移到祖先处，但两个黑点不能在同一个位置。求最小的黑点深度和。\n用堆维护每颗子树中黑点的深度，如果根上没有黑点就把最深的移到根。\n学到的东西：看到字符串前缀想到 trie（还是字符串做少了）。\n","categories":["每日记录"],"tags":["Codeforces","贪心"]},{"title":"2024.9.28","url":"/2024/09/28/2024-9-28/","content":"LaIS *2200\n没太想出来。\n设 f_i 表示以 i 为结尾的最长子序列长度。\n考虑如何从 j 转移到 i。\n若 a_j\\le a_i，那么直接转移即可。\n若 a_j > a_i，则需要考虑 j 的前驱 k。\n因为需要满足 \\min(a_k,a_j)\\le \\min(a_j,a_i)，即 a_k \\le a_i。\n那么我们贪心的想，让 j 越靠右越好，因为这样前驱 k 的范围就更大。\n那么我们维护一个单调栈，求出每个 i 左侧的第一个 j，使得 a_j > a_i。\n转移用树状数组即可。\n复杂度 O(n\\log n)\nHelping Hiasat *2200\n开到抽象题了。\n第一遍读错题了，没看到每一次都得一样。\n如果没有这个限制的话就很简单了，把相邻两个 1 之间划分成一个区间，找每个区间的众数即可。\n但现在有这个限制，怎么办？\n依旧考虑划分成若干区间，那么两个人可以共存当且仅当两个人从未同时出现过。\n如果两个人不能共存，那么就连一条边。最后求出这个图的最大独立集即可。\n这是一个 NPC 问题。\n不过有结论：原图的最大独立集=补图的最大团。\n最大团可以用 Bron–Kerbosch 算法在 O(2^{\\frac{n}{2}}) 的复杂度内求出。\n复杂度 O(nm^2+2^{\\frac{m}{2}})\nDemiurges Play Again *2200\n首先考虑权值给定怎么做。\n设 f_{u,0/1} 表示 u 点先/后手能取到的值。转移为\n\nf_{u,0}=\\max_{v \\in sub_u} f_{v,1}\n\\\\\nf_{u,1}=\\min_{v \\in sub_u} f_{v,0}然后考虑放权值。\n依旧设 f_{u,0/1}，表示 u 点先/后手能取到的值是该子树内第 f_{u,0/1} 大的数。\n那么转移是类似的，不过变成了第几大。\n对于 f_{u,0}，取 \\min 即可。\n对于 f_{u,1}，下一步由对方取最大值，而无论怎么放权值，对方都有可能不选择某子树。所以问题可以看作我们需要放多少个数进入叶子结点才可以让此时的玩家保证能够取到数。而能取到的最小值就是这些数的最后一个。因为是子树内的第几大，所以可以直接求和。\n综上，转移为\n\nf_{u,0}=\\min_{v \\in sub_u} f_{v,1}\n\\\\\nf_{u,1}=\\sum_{v \\in sub_u} f_{v,0}那么答案分别为 m-f_{1,0}+1,f_{1,1}。\n复杂度 O(n)\n因为有单调性，所以也可以二分变成判定性问题，不过似乎有点多此一举？\nYet Another Array Counting Problem *2300\n开到了笛卡尔树上 dp 板子。\n以下标为键，a_i 为值建立大根笛卡尔树，那么 [l,r] 的最左端最大值位置就是 l,r 在笛卡尔树上的 \\operatorname{lca}。\n那么所有最左端最大值位置都相等，就意味着笛卡尔树的形态相同。\n此时转化为树计数问题。\n设 f_{u,i} 表示 u 取值 1 \\sim i 的方案数。\n左儿子可以填 [1,i-1]，右儿子可以填 [1,i]\n转移就是 f_{u,i}=f_{u,i-1}+f_{ls_u,i-1}\\times f_{rs_u,i}\n复杂度 O(nm)\n","categories":["每日记录"],"tags":["Codeforces","dp"]},{"title":"bitset学习笔记","url":"/2024/10/04/bitset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"参考文章\n一直不会用 bitset，今天终于下定决心学一下。\nbitset 是一个很好用的 STL，且时间复杂度和空间复杂度都很优秀。\nbitset 是一个 01 串，每一位占一个 bit。\nbitset 的下标是从右往左的。例如 f_1=1，那么得到的 bitset 应该是 00010 之类的东西。\n所以后面的左移右移才是那样。\n如何声明首先，我们需要引用 &lt;bitset&gt; 头文件。\n声明方式为\nbitset&lt;maxn&gt; s;\nmaxn 为长度。\n修改与运算bitset 中每一个元素可以通过下标的方式访问。\n进行单点修改时，直接访问位置然后赋值即可。\ns[pos]=1;\nbitset 还支持位运算，返回值为一个 bitset。\ns&lt;&lt;=x;s&gt;&gt;=x;s&amp;=s1;s|=s1;s^=s1;\n复杂度设计算机字长为 \\omega，则一次操作的复杂度为 O(\\frac{n}{\\omega})。\n因为 \\omega 位才占一个整形长度，所以空间复杂度位 O(\\frac{n}{\\omega})。\n成员函数1.reset\n将 bitset 每一位都置为 0。\ns.reset();\n2.set\n如果不传参数，会将每一位都置为 1。复杂度 O(\\frac{n}{\\omega})。\n如果传参数，那么第一个参数为 pos，第二个参数为 val，意为把第 pos 位置为 val。\n如果不传 val，那么默认为 1。\ns.set();s.set(1);s.set(1,0);\n3.test\n有一个参数 pos，返回第 pos 位的值。\ns.test(1);\n4.any\n若 bitset 内存在 1，则返回 1，否则返回 0。\ncout&lt;&lt;s.any();\n5.none\n若 bitset 内所有位都是 0，则返回 1，否则返回 0。\ncout&lt;&lt;s.none();\n6.all\n若 bitset 内所有位都是 1，则返回 1，否则返回 0。\ncout&lt;&lt;s.all();\n7.count\n返回 bitset 内 1 的个数。\ncout&lt;&lt;s.count();\n8.flip\n把每一位取反。\n如果传参数 pos，那么就把第 pos 位取反。\ns.flip();s.flip(1);\n9._Find_first\n返回 bitset 第一个 1 的位置，不存在则返回 bitset 大小。\ncout&lt;&lt;s._Find_first();\n10._Find_next\n需要传参数 pos，返回下标严格大于 pos 的位置中第一个 1 的位置。\ncout&lt;&lt;s._Find_next(1);\n应用1.bitset 优化 dp\n对于一些可行性 dp，可以 bitset 优化。\n例题1：P1537 弹珠\n这是一道多重背包，不过可以当 01 背包做。\n但这是可行性背包，所以用 bitset 优化一下就可以了。\n复杂度为 O(\\frac{n\\sum w_i}{\\omega})\n这里给出优化 01 背包的代码。\nf.set(0);for(re int i=1;i&lt;=n;++i) f|=(f&lt;&lt;w[i]);\n例题2：Earn or Unlock *2200\n首先可以发现，如果最后一共解锁了 x 张牌，那么分数为 (\\sum_{i=1}^x a_i)-(x-1)。\n因为我们一开始只有一张牌，想解锁剩下的 x-1 张就必须花 x-1 的代价。\n然后显然解锁的牌可以都拿，那么就是一个前缀和再减去代价。\n所以我们只需要判断是否存在一种方案使得恰好解锁 x 张牌即可。\n复杂度 O(n^2) 的 dp 显然，考虑优化。\n但这是可行性 dp，可以用 bitset 优化。\n事实上也是个 01 背包。\n复杂度 O(\\frac {n^2}{\\omega})\n一些细节：\n\nx 可以达到 2n。\n\n这里的背包比较特殊，因为如果我们用第 i 张牌解锁后面的牌，那么恰好解锁 i 张牌这个状态也就不能为后续提供转移了。所以我们还需要再开个数组，记录每种值能否被恰好取到。\n\n\n2.bitset 结合莫队\n例题：[Ynoi2017] 由乃的玉米田 \n区间询问可离线，考虑莫队。\n我们维护两个 bitset，分别为 v1 和 v2。\n设值域为 V。\n如果 x 在当前区间出现，那么 v1[x]=v2[V-x]=1。\n对于减法操作，答案为 (v1&amp;(v1&lt;&lt;x)).any()。\n这很好理解。\n假设 a-b=x，那么当前区间一定存在 a 和 a-x。\n所以我们把 v1 和 (v1&lt;&lt;x) 与一下，看看能否满足即可。\n对于加法操作，答案为 (v1&amp;(v2&gt;&gt;(V-x))).any()。\n设 b'=V-b，那么 b 在 v1 和 b' 在 v2 中是对应的。\n假设 a+b=x，那么 a+V-b'=x。\n再移项一下，那么 a-b'=x-V。\n这里已经转化成减法了。\n因为 x-V 是负数，所以把左移变成右移。\n所以我们把 v1 和 (v2&gt;&gt;(V-x)) 与一下，看看能否满足即可。\n对于乘法操作，我们可以考虑枚举约数，然后看 i 和 \\frac {x}{i} 是否都存在。\n这个复杂度是 O(\\sqrt n) 的。\n对于除法操作，考虑根号分治。\n对于 x \\ge \\sqrt V，直接暴力枚举，然后看 i 和 i\\times x 是否都存在即可。\n这个复杂度是 O(\\sqrt n) 的。\n对于 x < \\sqrt V，我们不使用莫队，而是单独处理。\n首先将询问离线，然后枚举 x。\n对于每个 x，我们扫一遍序列。\n记 last_i 表示 i 当前最后一次出现的位置。\n记 ans_i 表示满足在 [l,i] 中，同时存在 a_i 和 a_i \\times x 或同时存在 a_i 和 \\frac {a_i}{x} 的最靠右的 l 的位置。 \n设当前扫到 i，那么先更新 last_{a_i}，再用 last_{a_i\\times x} 和 last_{\\frac {a_i}{x}} 更新 res_i 即可。\n扫完以后，我们回答以当前枚举到的 x 作为 x 的询问。\n设询问区间为 [l,r]，那么只要 l \\le res_r，该询问就合法。\n因为 x 只有 \\sqrt V 个，所以复杂度为 O(n\\sqrt n)\n综上，总复杂度为 O(n\\sqrt n)。\ncode：\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e5+10,V=1e5,lim=300;int n,m,Q,siz;int a[maxn],buc[maxn],lst[maxn],res[maxn];struct query&#123;    int op,l,r,x,id;&#125;q[maxn];bitset&lt;maxn&gt; v1,v2,ans;vector&lt;query&gt; q1[maxn];inline bool cmp(query a,query b)&#123;return ((a.l/siz)^(b.l/siz))?(a.l/siz)&lt;(b.l/siz):((a.l/siz)&amp;1)?a.r&lt;b.r:a.r&gt;b.r;&#125;inline void add(int x)&#123;    ++buc[x];    v1[x]=v2[V-x]=(buc[x]);&#125;inline void del(int x)&#123;    --buc[x];    v1[x]=v2[V-x]=(buc[x]);&#125;inline void solve()&#123;    for(re int x=1,l;x&lt;=lim;++x)&#123;        memset(lst,0,sizeof lst);        memset(res,0,sizeof res);        l=0;        for(re int i=1;i&lt;=n;++i)&#123;            lst[a[i]]=i;            if(x*a[i]&lt;=V) l=max(l,lst[x*a[i]]);            if(a[i]%x==0) l=max(l,lst[a[i]/x]);            res[i]=l;        &#125;        for(auto v:q1[x]) ans[v.id]=(v.l&lt;=res[v.r]);    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;Q;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];    for(re int i=1,op,l,r,x;i&lt;=Q;++i)&#123;        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r&gt;&gt;x;        if(op==4&amp;&amp;x&lt;=lim) q1[x].push_back(&#123;op,l,r,x,i&#125;);        else q[++m]=&#123;op,l,r,x,i&#125;;    &#125;    solve();    siz=sqrt(n)+1;    sort(q+1,q+m+1,cmp);    int l=1,r=0;    for(re int i=1;i&lt;=m;++i)&#123;        while(r&lt;q[i].r) add(a[++r]);        while(l&gt;q[i].l) add(a[--l]);        while(r&gt;q[i].r) del(a[r--]);        while(l&lt;q[i].l) del(a[l++]);        if(q[i].op==1) ans[q[i].id]=(v1&amp;(v1&lt;&lt;q[i].x)).any();        if(q[i].op==2) ans[q[i].id]=(v1&amp;(v2&gt;&gt;(V-q[i].x))).any();        if(q[i].op==3) for(re int j=1;j*j&lt;=q[i].x;++j) if(!(q[i].x%j)) if(v1[j]&amp;&amp;v1[q[i].x/j]) ans[q[i].id]=1;        if(q[i].op==4) for(re int j=1;j*q[i].x&lt;=V;++j) if(v1[j]&amp;&amp;v1[j*q[i].x]) ans[q[i].id]=1;    &#125;    for(re int i=1;i&lt;=Q;++i) cout&lt;&lt;(ans[i]?&quot;yuno&quot;:&quot;yumi&quot;)&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n","categories":["学习笔记"],"tags":["dp","数据结构","莫队"]},{"title":"test","url":"/2024/09/27/test/","content":"\n      \n        89d863a635c044f5f17b49eeb5c96a49343e814422cbb591a7530953f9b5af7d47820739998e2417b7e8fd3fa7446a3b2612aec5faacade24d4e3049010bb513fa8df6a4f43fb94d4abafcb6217381fe0f3bd48fbe669799a03a417e99b8bce345ae021f7b0576279234c898306e9611\n      \n      \n        \n          \n          \n            请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n          \n        \n        \n      \n    \n    "},{"title":"值域分块学习笔记","url":"/2024/10/05/%E5%80%BC%E5%9F%9F%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"参考文章\n又是一个很有用但一直不会的东西，今天学习一下。\n不过写的还是比较浅显，可以看参考文章，讲的很好。\n什么是值域分块普通的分块都学过，它是对序列分块的。\n而值域分块，顾名思义，是对值域分块。\n序列分块和值域分块的关系就像线段树和权值线段树的关系一样，一个维护序列，一个维护值域。\n两种常用的值域分块第一种：修改 O(1)，查询 O(\\sqrt n)\n正常维护即可。\n第二种：修改 O(\\sqrt n)，查询 O(1)\n维护块内前缀和，以及每个块的前缀和，这样复杂度就反过来了。\n应用值域分块一般用来平衡复杂度。\n例如莫队，我们有 O(n\\sqrt n) 次修改和  O(n) 次查询，这时可以用 O(1) 修改，O(\\sqrt n) 查询的值域分块平衡复杂度。\n而如果用 O(\\log n) 修改，O(\\log n) 查询的其他数据结构，复杂度就来到了混乱邪恶的 O(n\\sqrt n \\log n)，不可接受。\n例题值域分块配合莫队\n例题1：[AHOI2013] 作业\n可以说是板子题了。\n使用 O(1) 修改，O(\\sqrt n) 查询的值域分块。\n复杂度 O(n\\sqrt n)。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e5+10,maxm=500;int n,m,siz,tot;int a[maxn];int ans1[maxn],ans2[maxn];int st[maxm],ed[maxm],bel[maxn];int cnt1[maxm],cnt2[maxn],cnt3[maxm];struct query&#123;    int l,r,a,b,id;&#125;q[maxn];inline bool cmp(query a,query b)&#123;return ((a.l/siz)^(b.l/siz))?(a.l/siz)&lt;(b.l/siz):((a.l/siz)&amp;1)?a.r&lt;b.r:a.r&gt;b.r;&#125;inline void init()&#123;    siz=sqrt(n);    tot=n/siz;    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;n) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=n;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i;&#125;inline void add(int x)&#123;    if(!cnt2[x]) ++cnt3[bel[x]];    ++cnt1[bel[x]];    ++cnt2[x];&#125;inline void del(int x)&#123;    --cnt1[bel[x]];    --cnt2[x];    if(!cnt2[x]) --cnt3[bel[x]];&#125;inline int get_ans1(int l,int r)&#123;    int L=bel[l],R=bel[r];    int res=0;    if(L==R) for(re int i=l;i&lt;=r;++i) res+=cnt2[i];    else&#123;        for(re int i=l;i&lt;=ed[L];++i) res+=cnt2[i];        for(re int i=st[R];i&lt;=r;++i) res+=cnt2[i];        for(re int i=L+1;i&lt;=R-1;++i) res+=cnt1[i];    &#125;    return res;&#125;inline int get_ans2(int l,int r)&#123;    int L=bel[l],R=bel[r];    int res=0;    if(L==R) for(re int i=l;i&lt;=r;++i) res+=(bool)cnt2[i];    else&#123;        for(re int i=l;i&lt;=ed[L];++i) res+=(bool)cnt2[i];        for(re int i=st[R];i&lt;=r;++i) res+=(bool)cnt2[i];        for(re int i=L+1;i&lt;=R-1;++i) res+=cnt3[i];    &#125;    return res;&#125;signed main()&#123;    #ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);    #endif\t    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];    for(re int i=1;i&lt;=m;++i) cin&gt;&gt;q[i].l&gt;&gt;q[i].r&gt;&gt;q[i].a&gt;&gt;q[i].b,q[i].id=i;    init();    sort(q+1,q+m+1,cmp);    int l=1,r=0;    for(re int i=1;i&lt;=m;++i)&#123;        while(r&lt;q[i].r) add(a[++r]);        while(l&gt;q[i].l) add(a[--l]);        while(r&gt;q[i].r) del(a[r--]);        while(l&lt;q[i].l) del(a[l++]);        ans1[q[i].id]=get_ans1(q[i].a,q[i].b);        ans2[q[i].id]=get_ans2(q[i].a,q[i].b);    &#125;    for(re int i=1;i&lt;=m;++i) cout&lt;&lt;ans1[i]&lt;&lt;&quot; &quot;&lt;&lt;ans2[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n例题2：[Ynoi2019 模拟赛] Yuno loves sqrt technology II \n区间逆序对，不难想到用树状数组维护修改。\n但这样复杂度是 O(n\\sqrt n \\log n) 的，不能接受。\n但可以发现，这个贡献是可以差分的，所以考虑莫队二次离线。\n这里还是把二离详细说一下吧（毕竟我也不太懂）。\n假设当前在区间 [l,r]。\n我们分四种情况讨论指针的移动。\n1.右指针右移\n考虑当前到的位置 r+1，此时会产生的新贡献是 [l,r] 里大于 a_{r+1} 的个数。\n可以差分成 [1,r] 中大于 a_{r+1} 的个数减去 [1,l-1] 大于 a_{r+1} 的个数。\n2.右指针左移\n考虑当前到的位置 r-1，此时会减少的贡献是 [l,r-1] 里大于 a_r 的个数。\n可以差分成 [1,r-1] 中大于 a_r 的个数减去 [1,l-1] 大于 a_r 的个数。\n3.左指针左移\n考虑当前到的位置 l-1，此时会产生的新贡献是 [l,r] 里小于 a_{l-1} 的个数。\n可以差分成 [1,r] 中小于 a_{l-1} 的个数减去 [1,l-1] 小于 a_{l-1} 的个数。\n4.左指针右移\n考虑当前到的位置 l+1，此时会减少的贡献是 [l+1,r] 里小于 a_l 的个数。\n可以差分成 [1,r] 中小于 a_l 的个数减去 [1,l] 小于 a_l 的个数。\n请注意上文的减少，因为是减少下面的那个东西，所以要记得变号。\n然后可以发现有一些可以预处理出来。\n例如 [1,i-1] 中 > a_i 的个数，[1,i] 中 < a_i 的个数。\n然后剩下的部分离线下来，一共 O(n\\sqrt n) 次修改和 O(n) 次询问。\n然后扫描线，用数据结构维护剩下形如：每次求一个前缀中 > x 或 < x 的数的个数。\n这让你想到了什么？值域分块！\n我们用 O(1) 修改，O(\\sqrt n) 查询的值域分块维护这个东西。\n最后，别忘了我们上面讨论的都是变化量，相当于答案的差分，所以最后还要求个前缀和得到答案。\n然后大概就做完了，吗？\nYnoi，怎么能不卡常呢？\n首先是卡空间。\n我们如果直接存 O(n\\sqrt n) 次修改，空间复杂度是 O(n\\sqrt n) 的。\n但是不难发现，莫队每次的指针移动是一段区间，所以直接把这一段区间一块存下来就行了。\n空间复杂度变为 O(n)。\n然后是卡时间。\n预处理的那部分最好直接处理前缀和（然而代码里没这么写）。\n少开 long long。\n值域分块最好这么分：\n维护值域上每个数的出现次数的前缀和，然后单点修改打标记。这样常数很小。\n而不是这么分：\n维护值域块的前缀和以及每个值域块内的前缀和，单点修改直接改前缀和即可。常数较大。\n代码里是第二种，因为第一种写挂了。\n改成第一种就能过了。\n下面是一份可以在 300ms 左右通过所有数据的代码。\n不想卡常了。\n#include&quot;bits/stdc++.h&quot;#define re register// #define int long long#define lb(x) (x&amp;(-x))using namespace std;const int maxn=1e5+10,maxm=500;int n,m,siz,tot,len;int a[maxn],b[maxn],tr[maxn];int st[maxm],ed[maxm],bel[maxn],idx[maxn];int fl[maxn],fr[maxn];long long ans[maxn],cnt1[maxm],cnt2[maxm][maxm];struct query&#123;    int l,r,id;    long long ans;&#125;q[maxn];struct node&#123;    int l,r,id,op;&#125;;vector&lt;node&gt; g1[maxn],g2[maxn];inline bool cmp(query a,query b)&#123;return ((a.l/siz)^(b.l/siz))?(a.l/siz)&lt;(b.l/siz):((a.l/siz)&amp;1)?a.r&lt;b.r:a.r&gt;b.r;&#125;inline void add(int x,int val)&#123;while(x&lt;=maxn) tr[x]+=val,x+=lb(x);&#125;inline int query(int x)&#123;int res=0;while(x&gt;0) res+=tr[x],x-=lb(x);return res;&#125;inline void pre()&#123;    for(re int i=1;i&lt;=n;++i)&#123;        fr[i]=i-1-query(a[i]);        add(a[i],1);    &#125;    for(re int i=1;i&lt;=n;++i) add(a[i],-1);    for(re int i=1;i&lt;=n;++i)&#123;        add(a[i],1);        fl[i]=query(a[i]-1);    &#125;&#125;inline void init()&#123;    siz=sqrt(len);    tot=ceil(len/siz);    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;len) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=len;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i,idx[j]=j-st[i]+1;&#125;inline void update(int x,int val)&#123;    int id=bel[x];    for(re int i=id;i&lt;=tot;++i) cnt1[i]+=val;    for(re int i=idx[x];i&lt;=idx[ed[id]];++i) cnt2[id][i]+=val;&#125;inline int query(int l,int r)&#123;    int L=bel[l],R=bel[r];    long long res=0;    if(L==R) res+=(cnt2[L][idx[r]]-cnt2[L][idx[l]-1]);    else&#123;        res+=(cnt2[L][idx[ed[L]]]-cnt2[L][idx[l]-1]);        res+=(cnt2[R][idx[r]]);        res+=(cnt1[R-1]-cnt1[L]);    &#125;    return res;&#125;inline void solve_l()&#123;    for(re int i=1;i&lt;=n;++i)&#123;        update(a[i],1);        for(auto t:g1[i])&#123;            for(re int j=t.l;j&lt;=t.r;++j)&#123;                q[t.id].ans+=t.op*(i-query(1,a[j]));            &#125;        &#125;    &#125;    for(re int i=1;i&lt;=n;++i) update(a[i],-1);&#125;inline void solve_r()&#123;    for(re int i=1;i&lt;=n;++i)&#123;        update(a[i],1);        for(auto t:g2[i])&#123;            for(re int j=t.l;j&lt;=t.r;++j)&#123;                q[t.id].ans+=t.op*query(1,a[j]-1);            &#125;        &#125;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],b[i]=a[i];    sort(b+1,b+n+1);    len=unique(b+1,b+n+1)-(b+1);    for(re int i=1;i&lt;=n;++i) a[i]=lower_bound(b+1,b+len+1,a[i])-b;    pre();    for(re int i=1;i&lt;=m;++i) cin&gt;&gt;q[i].l&gt;&gt;q[i].r,q[i].id=i;    siz=sqrt(n);    sort(q+1,q+m+1,cmp);    int l=1,r=0;    for(re int i=1;i&lt;=m;++i)&#123;        if(r&lt;q[i].r)&#123;            g1[l-1].push_back(&#123;r+1,q[i].r,i,-1&#125;);            while(r&lt;q[i].r) q[i].ans+=fr[++r];        &#125;        if(l&gt;q[i].l)&#123;            g2[r].push_back(&#123;q[i].l,l-1,i,1&#125;);            while(l&gt;q[i].l) q[i].ans-=fl[--l];        &#125;        if(r&gt;q[i].r)&#123;            g1[l-1].push_back(&#123;q[i].r+1,r,i,1&#125;);            while(r&gt;q[i].r) q[i].ans-=fr[r--];        &#125;        if(l&lt;q[i].l)&#123;            g2[r].push_back(&#123;l,q[i].l-1,i,-1&#125;);            while(l&lt;q[i].l) q[i].ans+=fl[l++];        &#125;    &#125;    init();    solve_l();    solve_r();    for(re int i=1;i&lt;=m;++i) q[i].ans+=q[i-1].ans;    for(re int i=1;i&lt;=m;++i) ans[q[i].id]=q[i].ans;    for(re int i=1;i&lt;=m;++i) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n序列分块套值域分块\n先来个简单问题：全局 kth。\n权值线段树很好维护对吧，线段树上二分即可。\n考虑值域分块怎么做。\n事实上是类似的。枚举整块，如果超了就枚举块内。\n复杂度 O(n\\sqrt n)\n那现在加强一下：区间 kth。\n【模板】可持久化线段树 2\n主席树可以做，那分块呢？\n在学值域分块前，我的第一想法是序列分块+二分。\n然而复杂度是 O(n\\sqrt n \\log n)\n能不能把 log 去掉呢？\n我们考虑序列分块套值域分块。\n这种值域类数据结构都有非常好的性质：单调性。\n我们先对序列分块，维护块内每个数的出现次数。\n然后对值域分块，维护每个序列块内每个值域块中数的出现次数。\n然后对序列块做上面两个信息的前缀和，这样就可以 O(1) 查询一段块内每个数的出现次数以及每个值域块中数的出现次数。\n这个预处理的复杂度是 O(n\\sqrt n) 的。\n查询时，我们先把散块里的元素放到一个桶里，再把值域块中的数放到一个桶里。\n然后跳值域块，超过 k 时就跳块内的数。\n复杂度 O(n\\sqrt n)\n代码实现里序列块和值域块共用了块长和所有编号，请分清哪个是序列块，哪个是值域块。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e5+10,maxm=500;int n,m,siz,tot;int a[maxn],b[maxn];int st[maxm],ed[maxm],bel[maxn];int cnt1[maxm][maxn],cnt2[maxm][maxm];int buc1[maxn],buc2[maxm];inline void init()&#123;    siz=sqrt(n);    tot=n/siz;    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;n) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=n;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i;&#125;inline void pre()&#123;    for(re int i=1;i&lt;=tot;++i)&#123;        for(re int j=1;j&lt;=n;++j) cnt1[i][j]=cnt1[i-1][j];        for(re int j=1;j&lt;=tot;++j) cnt2[i][j]=cnt2[i-1][j];        for(re int j=st[i];j&lt;=ed[i];++j) ++cnt1[i][a[j]],++cnt2[i][bel[a[j]]];    &#125;&#125;inline int query(int l,int r,int k)&#123;    int L=bel[l],R=bel[r],res=-1,tmp=0,id=0;    if(L==R)&#123;        for(re int i=l;i&lt;=r;++i) ++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=1;i&lt;=tot;++i)&#123;            tmp+=buc2[i];            if(tmp&gt;=k)&#123;                tmp-=buc2[i];                id=i;                break;            &#125;        &#125;        for(re int i=st[id];i&lt;=ed[id];++i)&#123;            tmp+=buc1[i];            if(tmp&gt;=k)&#123;                res=b[i];                break;            &#125;        &#125;        for(re int i=l;i&lt;=r;++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;    &#125;    else&#123;        for(re int i=l;i&lt;=ed[L];++i) ++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=st[R];i&lt;=r;++i) ++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=1;i&lt;=tot;++i)&#123;            tmp+=buc2[i]+cnt2[R-1][i]-cnt2[L][i];            if(tmp&gt;=k)&#123;                tmp-=buc2[i]+cnt2[R-1][i]-cnt2[L][i];                id=i;                break;            &#125;        &#125;        for(re int i=st[id];i&lt;=ed[id];++i)&#123;            tmp+=buc1[i]+cnt1[R-1][i]-cnt1[L][i];            if(tmp&gt;=k)&#123;                res=b[i];                break;            &#125;        &#125;        for(re int i=l;i&lt;=ed[L];++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;        for(re int i=st[R];i&lt;=r;++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;    &#125;    return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif\t    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],b[i]=a[i];    sort(b+1,b+n+1);    int len=unique(b+1,b+n+1)-(b+1);    for(re int i=1;i&lt;=n;++i) a[i]=lower_bound(b+1,b+len+1,a[i])-b;    init();    pre();    for(re int i=1,l,r,k;i&lt;=m;++i)&#123;        cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;        cout&lt;&lt;query(l,r,k)&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n那再加强一下：单点修。\nDynamic Rankings\n因为我们预处理的是前缀和，所以要更改 O(\\sqrt n) 的块。\n代码基本相同。\n但如果你还把两种块的编号并用，请注意元素个数可能会 > n。\n代码里的 n=cnt 就是解决这一情况的。\n#include&quot;bits/stdc++.h&quot;#define re register// #define int long longusing namespace std;const int maxn=2e5+10,maxm=500;int n,m,siz,tot,cnt;int a[maxn],b[maxn];int st[maxm],ed[maxm],bel[maxn];int cnt1[maxm][maxn],cnt2[maxm][maxm];int buc1[maxn],buc2[maxm];struct query&#123;    int op;    int l,r,k;    int x,y;&#125;q[maxn];inline void init()&#123;    n=cnt;    siz=sqrt(n);    tot=n/siz;    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;n) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=n;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i;&#125;inline void pre()&#123;    for(re int i=1;i&lt;=tot;++i)&#123;        for(re int j=1;j&lt;=n;++j) cnt1[i][j]=cnt1[i-1][j];        for(re int j=1;j&lt;=tot;++j) cnt2[i][j]=cnt2[i-1][j];        for(re int j=st[i];j&lt;=ed[i];++j) ++cnt1[i][a[j]],++cnt2[i][bel[a[j]]];    &#125;&#125;inline void modify(int x,int y)&#123;    int pos=bel[x];    for(re int i=pos;i&lt;=tot;++i)&#123;        --cnt1[i][a[x]];        --cnt2[i][bel[a[x]]];        ++cnt1[i][y];        ++cnt2[i][bel[y]];    &#125;    a[x]=y;&#125;inline int query(int l,int r,int k)&#123;    int L=bel[l],R=bel[r],res=-1,tmp=0,id=0;    if(L==R)&#123;        for(re int i=l;i&lt;=r;++i) ++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=1;i&lt;=tot;++i)&#123;            tmp+=buc2[i];            if(tmp&gt;=k)&#123;                tmp-=buc2[i];                id=i;                break;            &#125;        &#125;        for(re int i=st[id];i&lt;=ed[id];++i)&#123;            tmp+=buc1[i];            if(tmp&gt;=k)&#123;                res=b[i];                break;            &#125;        &#125;        for(re int i=l;i&lt;=r;++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;    &#125;    else&#123;        for(re int i=l;i&lt;=ed[L];++i) ++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=st[R];i&lt;=r;++i) ++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=1;i&lt;=tot;++i)&#123;            tmp+=buc2[i]+cnt2[R-1][i]-cnt2[L][i];            if(tmp&gt;=k)&#123;                tmp-=buc2[i]+cnt2[R-1][i]-cnt2[L][i];                id=i;                break;            &#125;        &#125;        for(re int i=st[id];i&lt;=ed[id];++i)&#123;            tmp+=buc1[i]+cnt1[R-1][i]-cnt1[L][i];            if(tmp&gt;=k)&#123;                res=b[i];                break;            &#125;        &#125;        for(re int i=l;i&lt;=ed[L];++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;        for(re int i=st[R];i&lt;=r;++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;    &#125;    return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif\t    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],b[++cnt]=a[i];    char op;    for(re int i=1;i&lt;=m;++i)&#123;        cin&gt;&gt;op;        if(op==&#x27;Q&#x27;) cin&gt;&gt;q[i].l&gt;&gt;q[i].r&gt;&gt;q[i].k,q[i].op=1;        else cin&gt;&gt;q[i].x&gt;&gt;q[i].y,q[i].op=2,b[++cnt]=q[i].y;    &#125;    sort(b+1,b+cnt+1);    cnt=unique(b+1,b+cnt+1)-(b+1);    for(re int i=1;i&lt;=n;++i) a[i]=lower_bound(b+1,b+cnt+1,a[i])-b;    init();    pre();    for(re int i=1;i&lt;=m;++i)&#123;        if(q[i].op==1) cout&lt;&lt;query(q[i].l,q[i].r,q[i].k)&lt;&lt;&#x27;\\n&#x27;;        else modify(q[i].x,lower_bound(b+1,b+cnt+1,q[i].y)-b);    &#125;    return 0;&#125;\n那再加强一下：区间修。\n[Ynoi2018] 未来日记\n望月悲叹的最初分块。\n每个序列块用并查集把所有值相同的缩在一起。然后维护 rt[i][x]，表示第 i 个块中某个值为 x 的数的位置。\n对于整块修改，如果 x 不存在，直接无视。\n否则，如果 y 不存在，那么就把 x 映射成 y。\n否则暴力重构。\n然后还要把我们维护的前缀和修改掉。\n因为是区间修，所以我们还得再记录一下每个序列块内每个数的出现次数，用于修改后面的前缀和。\n对于散块修改，直接暴力重构即可。\n具体的，我们把并查集的信息全部重新维护一遍，然后再把后面块的前缀和修改一下。\n感觉说的也不是很清楚？那放一下lxl的题解吧。\n实现参考了题解（我太菜了写不出来QWQ）。\n#include&quot;bits/stdc++.h&quot;#define re register// #define int long longusing namespace std;const int maxn=1e5+10,maxm=170;int n,m,siz,tot;int a[maxn];int st[maxm],ed[maxm],bel[maxn];int cnt1[maxm][maxn],cnt2[maxm][maxm],cnt3[maxm][maxn];int buc1[maxn],buc2[maxm];int fa[maxn],rt[maxm][maxn];int stk[maxn];inline int find(int x)&#123;if(x!=fa[x]) fa[x]=find(fa[x]);return fa[x];&#125;inline void init()&#123;    siz=600;    tot=n/siz;    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;n) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=n;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i;&#125;inline void pre()&#123;    for(re int i=1;i&lt;=tot;++i)&#123;        for(re int j=st[i];j&lt;=ed[i];++j)&#123;            if(!rt[i][a[j]]) rt[i][a[j]]=j;             else fa[j]=rt[i][a[j]];        &#125;        for(re int j=1;j&lt;=n;++j) cnt1[i][j]=cnt1[i-1][j];        for(re int j=1;j&lt;=tot;++j) cnt2[i][j]=cnt2[i-1][j];        for(re int j=st[i];j&lt;=ed[i];++j) ++cnt1[i][a[j]],++cnt2[i][bel[a[j]]],++cnt3[i][a[j]];    &#125;&#125;inline void update(int p,int l,int r,int x,int y)&#123;    int tmp=0,top=0,L=st[p],R=ed[p];    rt[p][x]=rt[p][y]=0;    for(re int i=L;i&lt;=R;++i)&#123;        a[i]=a[find(i)];        if(a[i]==x||a[i]==y) stk[++top]=i;    &#125;    for(re int i=l;i&lt;=r;++i) if(a[i]==x) a[i]=y,++tmp;    for(re int i=1;i&lt;=top;++i) fa[stk[i]]=stk[i];    for(re int i=1;i&lt;=top;++i)&#123;        if(!rt[p][a[stk[i]]]) rt[p][a[stk[i]]]=stk[i];        else fa[stk[i]]=rt[p][a[stk[i]]];    &#125;    cnt3[p][x]-=tmp,cnt3[p][y]+=tmp;    for(re int i=p;i&lt;=tot;++i)&#123;        cnt1[i][x]-=tmp,cnt1[i][y]+=tmp;        if(bel[x]!=bel[y]) cnt2[i][bel[x]]-=tmp,cnt2[i][bel[y]]+=tmp;    &#125;&#125;inline void modify(int l,int r,int x,int y)&#123;    if(x==y) return;    int L=bel[l],R=bel[r];    if(L==R) update(L,l,r,x,y);    else&#123;        update(L,l,ed[L],x,y),update(R,st[R],r,x,y);        int tmp1=0,tmp2=0;        for(re int i=L+1;i&lt;=R-1;++i)&#123;            if(rt[i][x])&#123;                if(!rt[i][y]) rt[i][y]=rt[i][x],a[rt[i][x]]=y;                else fa[rt[i][x]]=rt[i][y];                rt[i][x]=0;                tmp1=cnt3[i][x],tmp2+=tmp1;                cnt3[i][y]+=tmp1,cnt3[i][x]=0;            &#125;            cnt1[i][x]-=tmp2,cnt1[i][y]+=tmp2;            if(bel[x]!=bel[y]) cnt2[i][bel[x]]-=tmp2,cnt2[i][bel[y]]+=tmp2;        &#125;        for(re int i=R;i&lt;=tot;++i)&#123;            cnt1[i][x]-=tmp2,cnt1[i][y]+=tmp2;            if(bel[x]!=bel[y]) cnt2[i][bel[x]]-=tmp2,cnt2[i][bel[y]]+=tmp2;        &#125;    &#125;&#125;inline int query(int l,int r,int k)&#123;    int L=bel[l],R=bel[r],res=-1,tmp=0,id=0;    if(L==R)&#123;        for(re int i=l;i&lt;=r;++i) a[i]=a[find(i)],++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=1;i&lt;=tot;++i)&#123;            tmp+=buc2[i];            if(tmp&gt;=k)&#123;                tmp-=buc2[i];                id=i;                break;            &#125;        &#125;        for(re int i=st[id];i&lt;=ed[id];++i)&#123;            tmp+=buc1[i];            if(tmp&gt;=k)&#123;                res=i;                break;            &#125;        &#125;        for(re int i=l;i&lt;=r;++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;    &#125;    else&#123;        for(re int i=l;i&lt;=ed[L];++i) a[i]=a[find(i)],++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=st[R];i&lt;=r;++i) a[i]=a[find(i)],++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=1;i&lt;=tot;++i)&#123;            tmp+=buc2[i]+cnt2[R-1][i]-cnt2[L][i];            if(tmp&gt;=k)&#123;                tmp-=buc2[i]+cnt2[R-1][i]-cnt2[L][i];                id=i;                break;            &#125;        &#125;        for(re int i=st[id];i&lt;=ed[id];++i)&#123;            tmp+=buc1[i]+cnt1[R-1][i]-cnt1[L][i];            if(tmp&gt;=k)&#123;                res=i;                break;            &#125;        &#125;        for(re int i=l;i&lt;=ed[L];++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;        for(re int i=st[R];i&lt;=r;++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;    &#125;    return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif\t    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],fa[i]=i;    init();    pre();    for(re int i=1,op,l,r,x,y,k;i&lt;=m;++i)&#123;        cin&gt;&gt;op;        if(op==1) cin&gt;&gt;l&gt;&gt;r&gt;&gt;x&gt;&gt;y,modify(l,r,x,y);        else cin&gt;&gt;l&gt;&gt;r&gt;&gt;k,cout&lt;&lt;query(l,r,k)&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n事实上这东西和主席树很像，都是维护前缀信息，然后通过差分求区间信息。\n一般来说，我们都会维护前缀序列块的某个值域块的前缀和，这样可以方便修改。\n有时候，我们还会维护前缀序列块的前缀值域块的前缀和。\n例如[ABC339G] Smaller Sum，我们维护前缀序列块的前缀值域块的前缀和。\n在序列上，我们把询问差分成 [1,r]-[1,l-1]，然后因为我们还维护了前缀值域块的前缀和，所以 \\le x 的和也直接求出来了。\n倍增值域分块倍增值域分块，就是把值域分成 [b^k,b^{k+1}) 的形式，一般取 b=2。\n通常用来解决 a_i\\ge x,a_i\\leftarrow a_i-x 的操作。\n常见做法是每块建一颗线段树维护。\n例题1：Phoenix and Diamonds *3400\n考虑倍增值域分块。\n我们把值域按 [2^k,2^{k+1}) 分块。\n设 c 当前在的块是 [2^k,2^{k+1})，那么 w_i 有三种情况：w_i < 2^k，w_i \\in [2^k,2^{k+1})，w_i \\ge 2^{k+1}。\n最后一种情况显然不需要考虑。\n如果选了第二种情况，那么 c 就会向下掉一层。\n如果选了第一种情况，那么也有两种情况：一直选，然后掉到下一层；或者直接选完。\n考虑对每一块开一颗线段树维护。\n线段树上维护 w_i < 2^k 的 \\sum w_i 和 \\sum v_i，以及选一个 w_i \\in [2^k,2^{k+1}) 所需的 c 的最小值（别忘了拿 [2^k,2^{k+1}) 的条件是先把前面拿完）。\n查询就是线段树上二分。\n还有另一种写法，不过差不多。\n线段树上每个节点维护所有块信息，维护的东西不变。\n设 sw_k=\\sum_{w_i < 2^k} w_i,sv_k=\\sum_{w_i < 2^k} v_i，mn 为上文提到的 c 的最小值。\n那么查询时，如果 c\\ge sw_k，那么说明小物品都能拿，那么直接返回 sw_k。\n如果 sw_{k-1}\\le c < mn_{k-1}，说明比 c 所在层的下一层还要小的物品可以全拿（拿完以后可能掉下去也可能不掉下去），但是下一层的物品一个也拿不了，那么直接返回 sw_{k-1}。\n否则向两边递归。可以证明复杂度为 O(\\log V)。\n感性理解就是每次递归都至少往下走一层，最多走 O(\\log V) 层。\n复杂度 O(n\\log n \\log V)\n实现时，查询里要实时维护当前在哪一层。\n代码实现了第二种（感觉线段树上二分不太好写）\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e5+10,maxv=20,inf=2e18;int n,m,c,rt,segcnt,now;int seq[maxn],id[maxn];struct node&#123;    int num,w,v,id;&#125;a[maxn];struct node1&#123;    int sw,sv,tot;&#125;;struct tree&#123;    int ls,rs;    node1 s[maxv];&#125;tr[maxn&lt;&lt;1];inline bool cmp(int x,int y)&#123;    if(a[x].v==a[y].v) return a[x].w&lt;a[y].w;    return a[x].v&gt;a[y].v;&#125;inline void up(int p)&#123;    for(re int i=1;i&lt;=18;++i)&#123;        tr[p].s[i].sw=tr[tr[p].ls].s[i].sw+tr[tr[p].rs].s[i].sw;        tr[p].s[i].sv=tr[tr[p].ls].s[i].sv+tr[tr[p].rs].s[i].sv;        tr[p].s[i].tot=min(tr[tr[p].ls].s[i].tot,tr[tr[p].ls].s[i].sw+tr[tr[p].rs].s[i].tot);    &#125;&#125;inline void init(int p,int pos)&#123;    for(re int i=1;i&lt;=18;++i)&#123;        tr[p].s[i].sw=tr[p].s[i].sv=0,tr[p].s[i].tot=inf;        if(a[pos].w&lt;(1&lt;&lt;(i-1))) tr[p].s[i].sw=a[pos].w*a[pos].num,tr[p].s[i].sv=a[pos].v*a[pos].num;        else if(a[pos].w&lt;(1&lt;&lt;i)&amp;&amp;a[pos].num) tr[p].s[i].tot=a[pos].w;     &#125;&#125;inline void build(int l,int r,int &amp;p)&#123;    if(!p) p=++segcnt;    if(l==r)&#123;init(p,id[l]);return;&#125;    int mid=(l+r)&gt;&gt;1;    build(l,mid,tr[p].ls),build(mid+1,r,tr[p].rs);    up(p);&#125;inline void update(int l,int r,int pos,int p)&#123;    if(l==r)&#123;init(p,id[pos]);return;&#125;    int mid=(l+r)&gt;&gt;1;    if(pos&lt;=mid) update(l,mid,pos,tr[p].ls);    else update(mid+1,r,pos,tr[p].rs);    up(p);&#125;inline void calc()&#123;while(now&gt;1&amp;&amp;(1&lt;&lt;((now-1)-1))&gt;c) --now;&#125;inline int query(int l,int r,int p)&#123;    if(l==r)&#123;        int num=min(a[id[l]].num,c/a[id[l]].w);        c-=num*a[id[l]].w;calc();        return num*a[id[l]].v;    &#125;    if(c&gt;=tr[p].s[now].sw)&#123;int tmp=tr[p].s[now].sv;c-=tr[p].s[now].sw,calc();return tmp;&#125;    else if(c&gt;=tr[p].s[now-1].sw&amp;&amp;c&lt;tr[p].s[now-1].tot)&#123;int tmp=tr[p].s[now-1].sv;c-=tr[p].s[now-1].sw,calc();return tmp;&#125;    else&#123;        int mid=(l+r)&gt;&gt;1;        return query(l,mid,tr[p].ls)+query(mid+1,r,tr[p].rs);    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i].num&gt;&gt;a[i].w&gt;&gt;a[i].v,id[i]=i;    sort(id+1,id+n+1,cmp);    for(re int i=1;i&lt;=n;++i) seq[id[i]]=i;    build(1,n,rt);    while(m--)&#123;        int op,num,pos;        cin&gt;&gt;op;        if(op==3)&#123;            cin&gt;&gt;c;now=18;calc();            cout&lt;&lt;query(1,n,1)&lt;&lt;&#x27;\\n&#x27;;        &#125;        else&#123;            cin&gt;&gt;num&gt;&gt;pos;            if(op==1) a[pos].num+=num;            else a[pos].num-=num;            update(1,n,seq[pos],1);        &#125;    &#125;    return 0;&#125;\n例题2：[Ynoi2007] rgxsxrs\n摆\n例题3：[Ynoi Easy Round 2022] 堕天作战 TEST_98\n摆\n","categories":["学习笔记"],"tags":["数据结构","莫队","分块"]},{"title":"笛卡尔树学习笔记","url":"/2024/09/28/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"笛卡尔树是一种二叉树，它既满足二叉搜索树的性质，又满足堆的性质。\n例如 treap，就属于笛卡尔树的一种。\n以下规定：第一键值为满足二叉搜索树的键值，第二键值为满足堆的键值。\n如何构建笛卡尔树\n我们可以用单调栈做到 O(n) 建树。\n我们考虑将下标作为第一键值，权值作为第二键值。\n那么每次我们插入的元素必然在这棵树的右链（右链：即从根节点一直往右子树走，经过的节点形成的链）的末端。\n所以我们可以用栈来维护笛卡尔树的右链。\n假设我们要建一颗大根笛卡尔树。\n设当前位置为 i，前 i-1 个位置已经构建好了。设栈顶元素为 a_{top}。\n我们维护值单调递增的单调栈。\n若 a_i \\le a_{top}，直接将 i 入栈（也就是把 i 挂在右链上）。\n否则一直弹栈，直到栈空或 a_i \\le a_{top}。把最后一个弹出的元素设为 i 的左儿子。\nfor(re int i=1;i&lt;=n;++i)&#123;    int tmp=top;    while(tmp&amp;&amp;a[stk[tmp]]&lt;a[i]) --tmp;    if(tmp) rs[stk[tmp]]=i;    if(tmp&lt;top) ls[i]=stk[tmp+1];    stk[++tmp]=i;    top=tmp;&#125;\n事实上，如果要按某个值作为第一键值，那么按这个值排序即可。\n可以发现，笛卡尔树的根就是 stk_1。\n应用\n笛卡尔树大多用来 dp。\n对原问题转化后，变为笛卡尔树上的 dp 问题。\n而且一般只会用到思想，并不会真把树建出来。\n以及一些直方图似乎也会用到。\n对于直方图类问题，我们常把下标作为第一键值，h_i 作为第二键值建立小根笛卡尔树。\n例题\n[TJOI2011] 树的序\n一道考察笛卡尔树定义的题。\n题目给的很明白了，要按权值当第一键值。\n因为要求字典序最小的生成序列，所以我们把每个数在序列中的位置当作第二键值，然后建小根笛卡尔树即可。\n因为插入顺序是父亲-&gt;左儿子-&gt;右儿子，所以输出先序遍历即可。\n注意输出的是键而不是编号。\nLargest Rectangle in a Histogram\n笛卡尔树求矩形面积板子题。\n我们把下标作为第一键值，h_i 作为第二键值建立小根笛卡尔树。\n枚举点 u，看当 h_u 作为矩形的高度时的最大面积。\n因为我们建的是小根树，所以子树内的点的 h_i 都大于 h_u。\n因为下标是键，所以子树内的点构成一段连续区间。\n那么以 h_u 作为高时的最大面积为 siz_u\\times h_u。\n[COCI2008-2009#4] PERIODNI\n我们考虑把这个多边形转成树。\n受上题启发，我们把下标作为第一键值，h_i 作为第二键值建立小根笛卡尔树。\n\n我们每次找到最低点，分成左右两边，然后递归处理。\n不难发现，这些矩形对应笛卡尔树上的所有节点。\n对于点 u,它代表的长为 siz_u，宽为 h_u-h_{fa}。\n因为两个儿子是分开的，所以可以直接合并，没有影响。\n设 f_{u,i} 表示以 u 为根的子树放了 i 个的方案数，g_{u,i} 表示以 u 为根的子树放了 i 个，且不包括 u 代表的矩形的方案数。\n那么 g 的转移就是背包。\n\ng_{u,i}=\\sum_{j=0}^i f_{ls,j}\\times f_{rs,i-j}至于 f 的转移，就是考虑 u 放几个。\n有结论：大小为 n\\times m 的棋盘，放 k 个互不攻击的车，方案数为 \\binom{n}{k}\\times \\binom{m}{k}\\times k!\n那么枚举子树一共用了几个，剩下的就是自己用的。\n注意子树用了的自己不能用。\n\nf_{u,i}=\\sum_{j=0}^i \\binom{siz_u}{i-j}\\times \\binom{h_u-h_{fa}}{i-j}\\times (i-j)!\\times g_{u,j}复杂度 O(nk^2+n^2)\nYet Another Array Counting Problem\n以下标为第一键值，a_i 为第二键值建立大根笛卡尔树，那么 [l,r] 的最左端最大值位置就是 l,r 在笛卡尔树上的 \\operatorname{lca}。\n那么所有最左端最大值位置都相等，就意味着笛卡尔树的形态相同。\n此时转化为树计数问题。\n设 f_{u,i} 表示 u 取值 1 \\sim i 的方案数。\n左儿子可以填 [1,i-1]，右儿子可以填 [1,i]\n转移就是 f_{u,i}=f_{u,i-1}+f_{ls_u,i-1}\\times f_{rs_u,i}\n复杂度 O(nm)\n","categories":["学习笔记"],"tags":["数据结构"]}]