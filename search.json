[{"title":"2024.10.10","url":"/posts/b9e27ec5/","content":"代码能力怎么这么弱？代码能力怎么这么弱？代码能力怎么这么弱？\n昨天调题调破防了，忘了写。今天补上。\n【模板】回滚莫队&amp;不删除莫队\n增加是好维护的，删除是不好维护的，考虑回滚莫队。\n但是这题的撤销不太好弄，以前写的回滚莫队撤销都很好撤销。\n这道题可以用栈维护一下，然后栈序撤销。\n或者拿桶记录一下也行。\n但是写挂了，不想调，所以没有代码。\n曼哈顿交易\n首先，你要先读对题。\n题目让求的是出现次数的第k小，不是第k小的出现次数。\n且这个第k小是不去重的。\n因为读错题又挂了半天，呃呃。\n区间查询，容易想到莫队。\n值域上的第k小且要平衡复杂度，容易想到值域分块。\n莫队加值域分块即可。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e5+10,maxm=350;int n,m,siz,tot;int a[maxn],b[maxn],ans[maxn];int st[maxm],ed[maxm],bel[maxn];int cnt1[maxn],cnt2[maxn],cnt3[maxm];struct query&#123;    int l,r,k,id;&#125;q[maxn];inline bool cmp(query a,query b)&#123;return ((a.l/siz)^(b.l/siz))?(a.l/siz)&lt;(b.l/siz):((a.l/siz)&amp;1)?a.r&lt;b.r:a.r&gt;b.r;&#125;inline void init()&#123;    siz=sqrt(n);    tot=n/siz;    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;n) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=n;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i;&#125;inline void add(int x)&#123;    --cnt2[cnt1[x]];    --cnt3[bel[cnt1[x]]];    ++cnt1[x];    ++cnt2[cnt1[x]];    ++cnt3[bel[cnt1[x]]];&#125;inline void del(int x)&#123;    --cnt2[cnt1[x]];    --cnt3[bel[cnt1[x]]];    --cnt1[x];    ++cnt2[cnt1[x]];    ++cnt3[bel[cnt1[x]]];&#125;inline int query(int k)&#123;    int id=0;    for(re int i=1;i&lt;=tot;++i)&#123;        if(k-cnt3[i]&lt;=0)&#123;id=i;break;&#125;        k-=cnt3[i];    &#125;    if(!id) return -1;    for(re int i=st[id];i&lt;=ed[id];++i)&#123;        if(k-cnt2[i]&lt;=0) return i;        k-=cnt2[i];    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],b[i]=a[i];    sort(b+1,b+n+1);    int len=unique(b+1,b+n+1)-(b+1);    for(re int i=1;i&lt;=n;++i) a[i]=lower_bound(b+1,b+len+1,a[i])-b;    for(re int i=1;i&lt;=m;++i) cin&gt;&gt;q[i].l&gt;&gt;q[i].r&gt;&gt;q[i].k,q[i].id=i;    init();    sort(q+1,q+m+1,cmp);    int l=1,r=0;    for(re int i=1;i&lt;=m;++i)&#123;        while(r&lt;q[i].r) add(a[++r]);        while(l&gt;q[i].l) add(a[--l]);        while(r&gt;q[i].r) del(a[r--]);        while(l&lt;q[i].l) del(a[l++]);        ans[q[i].id]=query(q[i].k);    &#125;    for(re int i=1;i&lt;=m;++i) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n美好的每一天\n因为是重排以后的回文串，所以这个限制本质上就是对每种字符的出现次数的奇偶性的限制。\n因为我们只关心奇偶性，所以想到异或。\n因为字符集很小，所以考虑状压。\n我们用一个 26 位的数表示每种字符的出现次数的奇偶性。\n那么对于一个区间，我们可以先把前缀异或求出来，然后就很好得到区间异或值了。\n设 s_i 为前缀异或，询问区间为 [l,r]，那么询问就被转化成了：在 [l-1,r] 种选取两个不同位置 x,y，使得 s_x \\oplus s_y 等于 0 或 2 的若干次方（0 代表每种字符都出现偶数次，2 的若干次方代表只有一种字符出现奇数次）。\n指针移动时的修改就对每种字符都算一下就行。\n和[CQOI2018] 异或序列很像。\n事实上可以二离做到更优复杂度，但是没必要，字符集太小了。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=6e4+10,maxv=(1&lt;&lt;26)+10;int n,m,siz,now;int a[maxn],ans[maxn];int buc[maxv];struct query&#123;    int l,r,id;&#125;q[maxn];inline bool cmp(query a,query b)&#123;return ((a.l/siz)^(b.l/siz))?(a.l/siz)&lt;(b.l/siz):((a.l/siz)&amp;1)?a.r&lt;b.r:a.r&gt;b.r;&#125;inline void add(int x)&#123;    now+=buc[x];    ++buc[x];    for(re int i=0;i&lt;26;++i) now+=buc[x^(1&lt;&lt;i)];&#125;inline void del(int x)&#123;    --buc[x];    now-=buc[x];    for(re int i=0;i&lt;26;++i) now-=buc[x^(1&lt;&lt;i)];&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i)&#123;        char c;        cin&gt;&gt;c;        a[i]=1&lt;&lt;(c-&#x27;a&#x27;);        a[i]^=a[i-1];    &#125;    for(re int i=1;i&lt;=m;++i) cin&gt;&gt;q[i].l&gt;&gt;q[i].r,--q[i].l,q[i].id=i;    siz=sqrt(n);    sort(q+1,q+m+1,cmp);    int l=1,r=0;    for(re int i=1;i&lt;=m;++i)&#123;        while(r&lt;q[i].r) add(a[++r]);        while(l&gt;q[i].l) add(a[--l]);        while(r&gt;q[i].r) del(a[r--]);        while(l&lt;q[i].l) del(a[l++]);        ans[q[i].id]=now;    &#125;    for(re int i=1;i&lt;=m;++i) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n「TERRA-OI R1」神，不惧死亡\n首先得先把这个游戏想明白。\n事实上是个简单贪心。\n不难发现，从小往大消除就是最优的。\n然后手玩样例可以发现，最后得到的最优结果就是最小的出现次数为偶数的数的后继。\n不难理解，因为你可以先把小于这个数的数全消成只剩 1 个，然后把这个数消没，最后得到的就是这个数的后继。\n而且这一定是最优的。\n假设它的后继不是最优，那么我们最后能得到一个比它的后继大的数，那么这就要求这个数的后继和这个数最后必须被消没。\n但因为这个数出现次数为偶数，所以它不能被大数消除的亡语给带没。所以如果我们要把它的后继给消没，那么此时的结果就是这个数。这是不优的。\n如果我们先把这个数消没，那么得到的一定是后继。\n命题得证。\n那么现在问题变成了：单点修改，区间查询值域在一段区间上的数里，最小的出现次数为偶数的数的后继。\n先不考虑修改，容易想到莫队。\n那么需要维护值域上的信息，容易想到值域分块。\n因为要带修，所以带修莫队+值域分块即可。\n值域分块维护每个数的出现次数，每个块内出现次数为偶数的数的个数，每个块的数的个数（去重或不去重都行，没必要去重，但我写的去重）。\n查询时，我写成了查两次：先找出来最小的出现次数为偶数的数，然后找这个数的后继。\n感觉比较好理解。\n但我很唐，所以写出来了一堆唐氏错误：\n\n第一次查完得到 x，第二次应该查 [x+1,r]，我写的 [x+1,n]\n第一次查完得到 x，x 可能等于 r，此时再查 [x+1,r] 会查出抽象东西。\n带修莫队的询问编号编错了，导致答案存到了未知地方。\n\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e5+10,maxm=350;int n,m,m1,m2,siz,tot;int a[maxn],ans[maxn];int st[maxm],ed[maxm],bel[maxn];int cnt1[maxn],cnt2[maxm],cnt3[maxm];struct query1&#123;    int pos,val;&#125;q1[maxn];struct query2&#123;    int l,r,l1,r1,tim,id;&#125;q2[maxn];inline bool cmp(query2 a,query2 b)&#123;return a.l/siz==b.l/siz?a.r/siz==b.r/siz?a.tim&lt;b.tim:a.r&lt;b.r:a.l&lt;b.l;&#125;inline void init()&#123;    siz=sqrt(n);    tot=n/siz;    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;n) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=n;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i;&#125;inline void add(int x)&#123;    if(!cnt1[x]) ++cnt3[bel[x]];    ++cnt1[x];    if(cnt1[x]%2==0) ++cnt2[bel[x]];    else if(cnt1[x]%2==1&amp;&amp;cnt1[x]!=1) --cnt2[bel[x]];&#125;inline void del(int x)&#123;    --cnt1[x];    if(!cnt1[x]) --cnt3[bel[x]];    if(cnt1[x]%2==0&amp;&amp;cnt1[x]) ++cnt2[bel[x]];    else if(cnt1[x]%2==1) --cnt2[bel[x]];&#125;inline void move(int tim,int l,int r,int op)&#123;    int pos=q1[tim].pos,val=q1[tim].val;    if(pos&gt;=l&amp;&amp;pos&lt;=r) del(a[pos]);    a[pos]+=val*op;    if(pos&gt;=l&amp;&amp;pos&lt;=r) add(a[pos]);&#125;inline int query2(int l,int r)&#123;    if(l&gt;r) return -1;    int L=bel[l],R=bel[r];    if(L==R)&#123;        for(re int i=l;i&lt;=r;++i) if(cnt1[i]) return i;    &#125;    else&#123;        for(re int i=l;i&lt;=ed[L];++i) if(cnt1[i]) return i;        for(re int i=L+1;i&lt;=R-1;++i)&#123;            if(cnt3[i])&#123;                for(re int j=st[i];j&lt;=ed[i];++j)&#123;                    if(cnt1[j]) return j;                &#125;            &#125;        &#125;        for(re int i=st[R];i&lt;=r;++i) if(cnt1[i]) return i;    &#125;    return -1;&#125;inline int query(int l,int r)&#123;    int L=bel[l],R=bel[r],pos=0;    if(L==R)&#123;        for(re int i=l;i&lt;=r;++i) if(cnt1[i]%2==0&amp;&amp;cnt1[i])&#123;pos=i;break;&#125;        if(pos) return query2(pos+1,r);    &#125;    else&#123;        for(re int i=l;i&lt;=ed[L];++i) if(cnt1[i]%2==0&amp;&amp;cnt1[i])&#123;pos=i;break;&#125;        if(pos) return query2(pos+1,r);        for(re int i=L+1;i&lt;=R-1;++i)&#123;            if(cnt2[i])&#123;                for(re int j=st[i];j&lt;=ed[i];++j)&#123;                    if(cnt1[j]%2==0&amp;&amp;cnt1[j])&#123;pos=j;break;&#125;                &#125;            &#125;            if(pos) return query2(pos+1,r);        &#125;        for(re int i=st[R];i&lt;=r;++i)if(cnt1[i]%2==0&amp;&amp;cnt1[i])&#123;pos=i;break;&#125;        if(pos) return query2(pos+1,r);    &#125;    return -1;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];    for(re int i=1,op;i&lt;=m;++i)&#123;        cin&gt;&gt;op;        if(op==1) ++m1,cin&gt;&gt;q1[m1].pos&gt;&gt;q1[m1].val;        else ++m2,cin&gt;&gt;q2[m2].l&gt;&gt;q2[m2].r&gt;&gt;q2[m2].l1&gt;&gt;q2[m2].r1,q2[m2].tim=m1,q2[m2].id=m2;    &#125;    siz=pow(n,2.0/3.0);    sort(q2+1,q2+m2+1,cmp);    init();    int l=1,r=0,lst=0;    for(re int i=1;i&lt;=m2;++i)&#123;        while(r&lt;q2[i].r) add(a[++r]);        while(l&gt;q2[i].l) add(a[--l]);        while(r&gt;q2[i].r) del(a[r--]);        while(l&lt;q2[i].l) del(a[l++]);        while(lst&lt;q2[i].tim) move(++lst,l,r,1);        while(lst&gt;q2[i].tim) move(lst--,l,r,-1);        ans[q2[i].id]=query(q2[i].l1,q2[i].r1);    &#125;    for(re int i=1;i&lt;=m2;++i) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n[BJWC2018] 基础匹配算法练习题\n二分图匹配肯定是假的，先转化题意。\n首先，把 a_i+c_j\\le z 转化成 c_j\\le z-a_i。\n令 a_i \\leftarrow z-a_i，转化为则 c_j \\le a_i。\n因为点的顺序不影响匹配，所以按点权从大到小排序，不难发现每个右部点对应的都是一段前缀。\n现在问题转化为：给一个序列，每个点都有一个可供安排的前缀区域，每次区间查询，把该区间的点拿出来，最多能安排几个点。\n首先想到莫队。\n然后这东西想了半天没想出来怎么维护，最后发现可以线段树维护。\n我们维护安排区域上的线段树。\n每个节点上维护三个信息：区间大小（siz），区间内尝试过安排的数的个数（sum），区间内成功安排的数的个数（ans）。\n指针移动时的修改就是单点修改。\n贪心地，我们在这个点可供安排区域的右端点修改。\n若该位置还未被匹配，则该点 sum 和 ans +1，否则只有 sum +1。\n删除是同理的。\n然后考虑怎么合并信息。\n关于合并，sum 直接相加即可。而 ans ，要先把左右相加，然后考虑能否多匹配几个。\n这东西就是 min(左区间空的位置数，右区间多的位置数)，也即是 min(max(0,siz_l-ans_l),sum_r-ans_r)。\n可能会有疑问：为什么不把左边多的给右边？\n因为我们每次都是贪心地把每个点插到自己的区域的右端点，所以肯定是右边会多。\n复杂度 O(m\\sqrt m \\log n)\n然而我用 upper_bound 传了个 greater 预处理每个点的安排区域写挂了，只有 95pts。\n然后把这东西改成线段树上二分就行了。\n呃呃，不知道哪里写错了，看来还是慎用 STL，尤其是不确定这么写会不会出问题的时候。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=6e4+10,maxv=2e5+10;int n,m,Q,z,siz,rt,segcnt;int a[maxv],b[maxn],c[maxv];int ans[maxn];struct query&#123;    int l,r,id;&#125;q[maxn];struct tree&#123;    int ls,rs,sum,ans,siz;&#125;tr[maxv&lt;&lt;1];inline bool cmp(query a,query b)&#123;return ((a.l/siz)^(b.l/siz))?(a.l/siz)&lt;(b.l/siz):((a.l/siz)&amp;1)?a.r&lt;b.r:a.r&gt;b.r;&#125;inline void up(int p)&#123;    tr[p].sum=tr[tr[p].ls].sum+tr[tr[p].rs].sum;    tr[p].ans=tr[tr[p].ls].ans+tr[tr[p].rs].ans;    tr[p].ans+=min(max(0ll,tr[tr[p].ls].siz-tr[tr[p].ls].ans),tr[tr[p].rs].sum-tr[tr[p].rs].ans);&#125;inline void build(int l,int r,int &amp;p)&#123;    if(!p) p=++segcnt;    tr[p].siz=r-l+1;    if(l==r) return;    int mid=(l+r)&gt;&gt;1;    build(l,mid,tr[p].ls),build(mid+1,r,tr[p].rs);&#125;inline void update(int l,int r,int pos,int val,int p)&#123;    if(l==r)&#123;        if(z-pos&lt;a[l]) return;        if(!tr[p].sum) tr[p].ans=1;        tr[p].sum+=val;        if(!tr[p].sum) tr[p].ans=0;        return;    &#125;    int mid=(l+r)&gt;&gt;1;    if(z-pos&lt;a[mid+1]) update(l,mid,pos,val,tr[p].ls);    else update(mid+1,r,pos,val,tr[p].rs);    up(p);&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;std.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;z;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];    for(re int i=1;i&lt;=m;++i) cin&gt;&gt;b[i];    sort(a+1,a+n+1);    cin&gt;&gt;Q;    for(re int i=1;i&lt;=Q;++i) cin&gt;&gt;q[i].l&gt;&gt;q[i].r,q[i].id=i;    siz=sqrt(m);    sort(q+1,q+Q+1,cmp);    build(1,n,rt);    int l=1,r=0;    for(re int i=1;i&lt;=Q;++i)&#123;        while(r&lt;q[i].r) update(1,n,b[++r],1,1);        while(l&gt;q[i].l) update(1,n,b[--l],1,1);        while(r&gt;q[i].r) update(1,n,b[r--],-1,1);        while(l&lt;q[i].l) update(1,n,b[l++],-1,1);        ans[q[i].id]=tr[1].ans;    &#125;    for(re int i=1;i&lt;=Q;++i) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n","categories":["每日记录"],"tags":["数据结构","莫队","分块"]},{"title":"2024.10.17","url":"/posts/2786eb66/","content":"没新东西学了这两天都不知道该干啥···\n只能写点简单杂题了。\n你说得对，但是距离 CSP 还剩 8 天。\nTop Secret Task *2300\n第一遍读题没看到交换的是两个相邻的数，然后疑惑半天为什么只敢开这点数据范围。\n首先 s 的范围是假的，因为冒泡排序上界次数为 O(\\frac {n(n-1)}{2})。\n然后猜一把复杂度 O(n^4)，正好 n 一维，k 一维，s 一维，够了。\n设 f_{i,j,k} 表示前 i 个数，把 j 个数加进贡献，操作了 k 次的最小值。\n转移考虑选不选第 i 个数：\n\nf_{i,j,k}=f_{i-1,j,k}\n\\\\\nf_{i,j,k}=f_{i-1,j-1,k-(i-j)}空间炸了，滚动数组一下。\n复杂度 O(n^4)\n然后我去学高维前缀和了，所以只有一道题。\n","categories":["每日记录"],"tags":["Codeforces","dp"]},{"title":"2024.10.2","url":"/posts/12c9edda/","content":"Team Building *2300\n首先可以想到暴力 dp。\n设 f_{i,j,S} 表示前 i 个人，选了 j 个观众，队伍的选择状态为 S。\n复杂度是炸的。\n但仔细想想，我们真的要记这么多状态吗？\n如果你把这道题想成一个普通的背包，那就错了，因为这题很特殊。\n每个物品的体积都是 1。\n这说明此时贪心是正确的。\n我们按观众值降序排序，那么对于观众值而言，一定是全选前面的更优。\n设 f_{i,S} 表示前 i 个人，队伍的选择状态为 S，num_S 为 S 里 1 的个数。\n转移时，如果当前观众人数小于 k，那么一定是让他当观众最优。\n因为观众是能选就选的，所以观众人数很容易得出，就是 i-num_S。\n复杂度 O(n2^p)\nMinimal Labels *2300\n第一眼看到以后以为是拓扑板子，直到看到第三个样例。\n经过手玩可以发现，我们应该每次都先填未填的点里编号最小的点，这样才能让字典序更小。\n但是编号最小的点可能被一些点指向，所以要先把前面的那些点给填上。\n前面那些点又构成一张新图，这就是一个子问题了，递归解决即可。\n找前面点可以建反图往回跑即可。\n复杂度？\n然而正解是建反图后拓扑，然后倒序编号。\n我们刚才的思路都是正着来的，那为什么倒着才是对的呢？\n正解是对的比较好理解，但感性理解一下，我们的做法似乎和倒着做是一样的？\nTrains and Statistic *2300\n类似 Floyd，对于两个点，我们要么一步到，要么找一个中转点。\n而这道题不需要 O(n^3) 的原因是：每个点能到的区间是一定的。\n所以我们可以贪心。\n既然一步走不到，那肯定走的越远越好。\n所以我们一定会从 i 走到 [i+1,a_i] 里 a 最大点 j。\n设 f_i=\\sum_{j=i+1}^n p_{i,j}。\n那么 f_i 只会从 f_j 转移来。\n转移为\n\nf_i=f_j+n+j-a_i-i首先让编号 >j 的点强制从 j 转移过去，那么这部分答案是 f_j+n-j。\n这会把 [j+1,a_i] 里的点多算一步，那么减去 a_i-(j+1)+1。\n最后加上 [i+1,j] 的点，他们只需要走一步，是 j-(i+1)+1。\n合起来就是 f_j+n+j-a_i-i。\n求 j 是一个 RMQ 问题，随便做。\n复杂度 O(n\\log n)\nMonster Invaders *2300\n又读错题。\n贪心肯定是很难贪的。考虑 dp。\n但是 dp 是不是有后效性？毕竟可以从前面过来，还可以从后面过来。\n难道要高斯消元解方程组？复杂度也接受不了啊。\n但你仔细想想，我们真的会从很后面的地方过来吗？\n显然不会。\n如果我们现在在 i，剩个 boss 差一血没打死，然后被强制移到了 i+1。\n假设我们一直往后打，直到  j 才往回走，把 i 剩下的 boss 打死。\n那么我们为什么不在被迫移动到 i+1 的时候就直接回去把 boss 打死？这肯定更优。\n想明白了这个，剩下就很简单了。\n然后考虑用什么方式把 i 清完。\n这里我读错题了，没看到 r_1 \\le r_2 \\le r_3。\n既然这样，那么每个房间只有这几种方法：\n\n手枪打小怪，AWP 打 boss。\n用激光枪（或手枪）对所有人各打一点伤害，被迫移动后，再移动回来，然后手枪解决 boss。\n\n转移很简单。\n注意最后重点可能是 n-1，也可能是 n。\nKeshi in Search of AmShZ *2300\n竟然是原理题。\n读完题后又瞬间想到一个假贪心：把最短路以外的边封掉，然后强制走最短路。\n显然不正确。我们可以少封一些边，然后走最长路，这样代价可以更小。\n考虑这张图确定了下来，那么对方一定会走最长路。\n设 f_u 表示 u 到 n 的最大代价。\n考虑一条边 (u,v)，如果我们经过了这条边，那么说明经过 u 必须是一条最长路。\n那么我们必须把比 u 还长的删掉。即转移为\n\nf_u=\\min_{v \\in to_u} (f_v+1+\\sum_{v'\\in to_u} [f_{v'}>f_v])直接转移复杂度是炸的。\n那么能不能在反图上跑时转移呢？\n但是如果倒着转移的话，无法确定 \\sum_{v'\\in to_u} [f_{v'}>f_v]) 的值。\n然后我们钦定转移顺序，让 f_v 从小到大转移，这样 \\sum_{v'\\in to_u} [f_{v'}>f_v]) 就满足了单调性。\n用优先队列维护最小即可。\n复杂度 O((n+m)\\log m)\n","categories":["每日记录"],"tags":["Codeforces","dp","贪心"]},{"title":"2024.10.3","url":"/posts/65cedd4c/","content":"模拟赛\n\n数据范围：n \\le 100,1\\le a_i,b_i,c_i \\le 10^9\n值域很大，无法加到状态里。那么考虑每个操作对答案产生的贡献。\n我们把攻击力拆开来算。\n直接攻击，那么贡献就是 a_i。\n设这回合后一共攻击 j 次。\n加攻击力，那么在这以后每次攻击伤害都会加 c_i，贡献就是 j\\times c_i\n加增量，那么设后续攻击的回合是 p_1,p_2,\\cdots,p_j，那么贡献为 \\sum_{k=1}^j (p_k-i)\\times b_i。\n把这个东西稍微拆一下，得到 b_i(\\sum_{k=1}^j p_k-j\\times i)。\n那么我们只需要记录攻击次数和攻击回合的编号和即可。\n但有个问题，我们现在的贡献和未来回合的行动有关。\n所以要倒过来做。那么转移也要相应的变一下。\n设 f_{i,j,k} 表示第 i 个回合到最后一个回合，一共攻击了 j 次，攻击回合的编号和为 k 的最大值。\n转移为\n\nf_{i,j+1,k+i}=f_{i+1,j,k}+a_i\n\\\\\nf_{i,j,k}=f_{i+1,j,k}+(i\\times j-k)\\times b_i\n\\\\\nf_{i,j,k}=f_{i+1,j,k}+j\\times c_i转移时可以把第一维压掉，但第二维要倒序枚举。\n复杂度 O(n^4)。\nCode：\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=110,inf=1e18;int n;int a[maxn],b[maxn],c[maxn],f[maxn][maxn*maxn];inline void solve()&#123;    cin&gt;&gt;n;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];    reverse(a+1,a+n+1);reverse(b+1,b+n+1);reverse(c+1,c+n+1);    memset(f,-0x3f,sizeof f);    f[0][0]=0;    for(re int i=1;i&lt;=n;++i)&#123;        for(re int j=i-1;j&gt;=0;--j)&#123;            for(re int k=0;k&lt;=(i-1)*i/2;++k)&#123;                f[j+1][k+i]=max(f[j+1][k+i],f[j][k]+a[i]);                f[j][k]=max(f[j][k],f[j][k]+max((i*j-k)*b[i],j*c[i]));            &#125;        &#125;    &#125;    int ans=-inf;    for(re int i=0;i&lt;=n;++i) for(re int j=0;j&lt;=n*(n+1)/2;++j) ans=max(ans,f[i][j]);    cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    int T;cin&gt;&gt;T;while(T--) solve();    return 0;&#125;\nRemoving Leaves *2300\n又读错题被硬控了。\n一开始没看见 k，以为随便删。\n考虑贪心。\n我们用 set 存每个节点，然后每次找到叶子最多的那个点，然后删 k 个。找不到就结束。\n这为什么是对的？\n感性理解一下，我们这么做只会让能删的点越来越多，而且不会有本来能删的点因为操作而不能删除，所以这么做操作数就是最大的。\n复杂度 O(n\\log n)\nVoting (Hard Version) *2400\n看完题就想到了一个假贪心：先按 m 降序再按 p 升序，每次买 m 最大 p 最小的。\n显然不对。我们不一定只从 m 最大的里面买。\n那改成每次买 p 最小的呢？\n还是不对。因为不一定买最小的就优。例如这组样例\n21 12 2\n显然只需要 2 即可。\n那应该怎么做？\n我们依旧按 m 降序排序。\n对于当前的 m_i，设 m 值小于 m_i 的人数为 pre，大于 m_i 且被买的人数为 cnt。\n假设我们已经把 < m_i 的人全搞定了，那么只需要让 pre+cnt\\ge m_i，就能搞定 m_i了。\n但如果不满足，我们就要从 \\ge m_i 的人里买人（因为 pre 是固定的），直到 pre+cnt\\ge m_i。\n满足该条件后，m_i 就被我们搞定了。\n那么我们只需要保证 < m_i 的人都被搞定就行了。\n然后再处理 < m_i 的那些人。这是一个子问题，和上述步骤完全一致。\n买人贪心买最便宜的，用个堆维护一下即可。\n复杂度 O(n\\log n)\nHappy Life in University *2300\n怎么现在啥数据结构都不会了/kk。\n对于这种 lca 的问题，常见套路是枚举 lca，把贡献都在 lca 处统计（枚举 lca 的意思是考虑每个点作为 lca 时的情况）。\n而这种 lca 的路径问题又能跟子树弄上关系。\n设当前考虑到以 u 为根的子树。\n那么我们只需要维护 u 到子树内节点的路径即可，答案就是拿两条路径拼起来。\n假设已经搜完了子树，回溯到了 u。\n那么 u 会对所有路径产生自己颜色的贡献。\n但显然会算重，那么考虑去重。\n因为每个点只需要在离他最近的且颜色和他相同的祖先处减去重复，所以只会操作 O(n) 次。\n那么直接去重就是对的。\n所以我们的操作就只有子树加和子树查，线段树维护。\n答案用最大值和次大值拼一下即可。\n复杂度 O(n\\log n)\nWine Factory (Easy Version) *2300\n讲一个很有意思的做法。\n我们考虑有多少水被浪费了。\n设 f_i  表示从 i 流向 i+1 的水的量。\n转移为 \n\nf_i=\\max(f_{i-1}+a_i-b_i,0)这东西可以用 (max,+) 矩乘表示。\n\n\\begin{bmatrix}\nf_i \n\\\\\n0 \n\\end{bmatrix}\n=\n\\begin{bmatrix}\na_i-b_i & 0 \n\\\\\n-inf & 0\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\nf_{i-1} \n\\\\\n0 \n\\end{bmatrix}然后线段树维护矩阵即可。单点修改也是简单的。\n复杂度 O(k^3n\\log n)\nMark and Professor Koro *2300\n感觉和 [HBCPC2024] Enchanted 非常的像啊，套路也是一样。\n对于这种两个相同的数合并成+1的数的操作，我们可以把它看成二进制意义下的加法，然后进行维护。\n但这个题不能直接把数的二进制用整数表示，值域太大了。\n我们用线段树维护值域上每个数出现次数，不难发现每个数出现次数只会为 0/1。\n那么修改可以看成删一个数再加上一个数。\n删和加是类似的，先考虑加。设加的那个数是 x。\n如果 x 那一位是 0，那么不用进位，直接给这一位 +1 即可。\n否则会进位。但不难发现，这东西是一次区间覆盖和一次单点修改。\n删数同理。\n如果 x 那一位是 1，那么不用退位，直接给这一位 -1 即可。\n否则会退位。依旧是一次区间覆盖和一次单点修改。\n那么答案就是最右边的 1 的位置，这个可以线段树上二分找到。\n具体的，线段树上维护区间里 1 的个数。\n加法进位：找到 x 后第一个为 0 的位置 pos，然后把 [x,pos-1] 区间赋值为 0，把 pos 赋值为 1.\n减法进位：找到 x 后第一个为 1 的位置 pos，然后把 [x,pos-1] 区间赋值为 1，把 pos 赋值为 0.\n找位置都可以线段树上二分。\n复杂度 O(n\\log n)\n","categories":["每日记录"],"tags":["数据结构","Codeforces","dp","贪心","模拟赛","矩阵乘法"]},{"title":"2024.10.23","url":"/posts/bc67cbc/","content":"Day -3\n最近都不知道写什么题···\n啥也不会啥也不想写···\n请注意，以下有大量口胡内容。\n总结一下最近写的杂题\n[湖南集训] Clever Rabbit首先手玩样例，可以发现答案非常少。\n然后打了一个小表，发现答案确实非常少。\n因为 n\\le 30，所以考虑打表。\n这里有一个性质：如果两个数字构成的可重集相同，则 f(x) 值一样。\n所以可以直接枚举集合，一共有 \\binom {n+10}{10} 个。\n然后高精算一下答案，把表打出来即可。\n分数统计无聊题。\n询问一前缀和，询问二离线下来回滚莫队，询问三 ST 表。\n没删 define int long long 被卡空间，导致没一遍过，气。\n[HEOI2014] 大工程看到保证关键点总数想到虚树。\n建完虚树以后就是个简单树形 dp。\n询问一就是经典的 \\sum_{i=1}^n\\sum_{j=i+1}^n dis(i,j)。\n做法是把贡献拆成每条边的贡献，统计每条边的经过次数。\n询问二三就是树上最短路径长和树的直径。\n注意虚树上边的边权是什么。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e6+10,inf=1e18;int n,m,cnt,tim,num,ans,mn,mx,len;int head[maxn];int key[maxn],a[maxn&lt;&lt;1];int f[maxn][3];bitset&lt;maxn&gt; vis;vector&lt;int&gt; g[maxn];struct edge&#123;    int to,nxt;&#125;e[maxn&lt;&lt;1];struct node&#123;    int fa,siz,dep,top,hson,dfn;&#125;t[maxn];inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void dfs1(int u,int fa)&#123;    t[u].fa=fa,t[u].dep=t[fa].dep+1,t[u].siz=1;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(v==fa) continue;        dfs1(v,u);        t[u].siz+=t[v].siz;        if(!t[u].hson||t[v].siz&gt;t[t[u].hson].siz) t[u].hson=v;    &#125;&#125;inline void dfs2(int u,int top)&#123;    t[u].top=top,t[u].dfn=++tim;    if(!t[u].hson) return;    dfs2(t[u].hson,top);    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(v==t[u].fa||v==t[u].hson) continue;        dfs2(v,v);    &#125;&#125;inline int lca(int u,int v)&#123;    while(t[u].top!=t[v].top)&#123;        if(t[t[u].top].dep&lt;t[t[v].top].dep) swap(u,v);        u=t[t[u].top].fa;    &#125;    return t[u].dep&lt;t[v].dep?u:v;&#125;inline bool cmp(int x,int y)&#123;return t[x].dfn&lt;t[y].dfn;&#125;inline void build()&#123;    sort(key+1,key+num+1,cmp);    len=0;    for(re int i=1;i&lt;num;++i)&#123;        a[++len]=key[i];        a[++len]=lca(key[i],key[i+1]);    &#125;    a[++len]=key[num];    a[++len]=1;    sort(a+1,a+len+1,cmp);    len=unique(a+1,a+len+1)-(a+1);    for(re int i=1;i&lt;len;++i)&#123;        int lc=lca(a[i],a[i+1]);        g[lc].push_back(a[i+1]),g[a[i+1]].push_back(lc);    &#125;&#125;inline void dfs(int u,int fa)&#123;    t[u].siz=vis[u];    if(vis[u]) f[u][1]=f[u][2]=0;    else f[u][1]=inf,f[u][2]=-inf;    for(auto v:g[u])&#123;        if(v==fa) continue;        dfs(v,u);        int w=t[v].dep-t[u].dep;        t[u].siz+=t[v].siz;        ans+=w*t[v].siz*(num-t[v].siz);        mn=min(mn,f[u][1]+f[v][1]+w),mx=max(mx,f[u][2]+f[v][2]+w);        f[u][1]=min(f[u][1],f[v][1]+w),f[u][2]=max(f[u][2],f[v][2]+w);    &#125;    g[u].clear();&#125;inline void solve()&#123;    build();    ans=0,mn=inf,mx=-inf;    dfs(1,0);    cout&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;mn&lt;&lt;&quot; &quot;&lt;&lt;mx&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n;    for(re int i=1,u,v;i&lt;n;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    dfs1(1,0),dfs2(1,1);    cin&gt;&gt;m;    while(m--)&#123;        cin&gt;&gt;num;        for(re int i=1;i&lt;=num;++i) cin&gt;&gt;key[i],vis[key[i]]=1;        solve();        for(re int i=1;i&lt;=num;++i) vis[key[i]]=0;    &#125;    return 0;&#125;\n[SCOI2016] 美味异或问题基本就三个方向：按位考虑，01trie，线性基。\n如果没有这个加 x_i，那这是可持久化trie模板。\nupd：可持久化trie好像也能做？不太会，还是按位考虑好想。\n但现在有 x_i，所以只能按位考虑。\n我们从高位到低位贪心。\n设前面位累计的答案为 ans，然后考虑当前位情况。\n设当前考虑到第 k 位。\n若当前位 b_i 位为 1，则我们希望 a_j+x_i 当前位为 0。\n那么 a_j+x_i\\in [ans,ans+2^k-1]。\n若当前位 b_i 位为 0，则我们希望 a_j+x_i 当前位为 1。\n那么 a_j+x_i\\in [ans+2^k,ans+2^{k+1}-1]。\n如果这一位能找到合法的 a_j，那么 ans 就加上 2^k。\n但这为什么是对的？为什么不会在低位的区间里找一个合法的 a_j，但它从未出现在高位的区间里过？\n如果你仔细想，你会发现如果高位有一位选到了合法值，那么低位的区间会变小。\n也就是说，区间大小是单调不增的。\n那么如果你在低位的区间里找到了一个合法值，那么它一定也出现在高位的区间里过。\n那么现在问题变为了序列上在 [l,r] 内，值域在 [L,R] 内的信息。\n因为要求在线，所以需要主席树上区间二分。\n当然树套树也行，但复杂度两个 \\log，太劣了。\n如果题目能离线，那么莫队+值域分块一般也能做。\n复杂度 O(n\\log^2 V)\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e5+10,lgn=30,V=1e5;int n,m,segcnt;int rt[maxn];struct tree&#123;    int ls,rs,sum;&#125;tr[maxn*lgn];inline void up(int p)&#123;tr[p].sum=tr[tr[p].ls].sum+tr[tr[p].rs].sum;&#125;inline void update(int l,int r,int pos,int &amp;p1,int p2)&#123;    p1=++segcnt;    tr[p1]=tr[p2];    if(l==r)&#123;++tr[p1].sum;return;&#125;    int mid=(l+r)&gt;&gt;1;    if(pos&lt;=mid) update(l,mid,pos,tr[p1].ls,tr[p2].ls);    else update(mid+1,r,pos,tr[p1].rs,tr[p2].rs);    up(p1);&#125;inline bool query(int l,int r,int L,int R,int p1,int p2)&#123;    if(tr[p1].sum==tr[p2].sum) return 0;    int mid=(l+r)&gt;&gt;1;    if(l&gt;=L&amp;&amp;r&lt;=R)&#123;        if(l==r) return 1;        bool res=query(l,mid,L,R,tr[p1].ls,tr[p2].ls);        if(res) return 1;        else return query(mid+1,r,L,R,tr[p1].rs,tr[p2].rs);    &#125;    else&#123;        if(L&lt;=mid)&#123;            bool res=query(l,mid,L,R,tr[p1].ls,tr[p2].ls);            if(res) return 1;\t        &#125;        if(R&gt;mid)&#123;            bool res=query(mid+1,r,L,R,tr[p1].rs,tr[p2].rs);            if(res) return 1;        &#125;        return 0;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif\t    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1,x;i&lt;=n;++i)&#123;        cin&gt;&gt;x;        update(0,V,x,rt[i],rt[i-1]);    &#125;    for(re int i=1,ans,b,x,l,r;i&lt;=m;++i)&#123;        cin&gt;&gt;b&gt;&gt;x&gt;&gt;l&gt;&gt;r;        ans=0;        for(re int j=17,L,R,op;j&gt;=0;--j)&#123;            if((b&gt;&gt;j)&amp;1) L=ans-x,R=ans+(1&lt;&lt;j)-1-x,op=0;            else L=ans+(1&lt;&lt;j)-x,R=ans+(1&lt;&lt;(j+1))-1-x,op=1;            if(!query(0,V,max(0ll,L),min(R,V),rt[l-1],rt[r])) op^=1;            ans+=(op&lt;&lt;j);        &#125;        cout&lt;&lt;(ans^b)&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n[SDOI2013] 森林看到链上 kth 想到主席树，看到动态加边想到 LCT。\n但这俩没法同时维护。\n所以考虑每个点维护一颗主席树，然后合并时启发式合并。\n然后把链上 kth 做一下树上差分，同时查四颗主席树然后合并答案即可。\n但有个问题，怎么动态求 lca？\n维护 LCT 即可。\n当然也可以倍增，在启发式合并时重构倍增数组即可。\n动态 lca 模板：DYNALCA - Dynamic LCA\n不会写 LCT 了，悲。\n[HNOI2015] 接水果 树套树和整体二分我都不会啊？只能写无脑莫队了。\n查 kth 直接值域分块。\n注意：在一条链的两个点都被加进来时，这条链的权值才能算进来。\n没了。\n[SHUPC 2024] 原神，启动！设 x_i 表示第 i 个被攻击的次数，那么列出方程应该长这样\n\n\\begin{cases}\na_{1,1}x_1+a_{2,1}x_2+\\cdots+a_{n,1}x_n+s_1\\ \\equiv t_1 & (mod\\ m)\n\\\\\na_{1,2}x_1+a_{2,2}x_2+\\cdots+a_{n,2}x_n+s_2\\ \\equiv t_2 & (mod\\ m)\n\\\\\n\\cdots\n\\\\\na_{1,n}x_1+a_{2,n}x_2+\\cdots+a_{n,n}x_n+s_n\\ \\equiv t_n & (mod\\ m)\n\\end{cases}然后高斯消元解就完事了。\n注意是在模意义下解高斯消元，所以除法要注意。\n","categories":["每日记录"],"tags":["数据结构"]},{"title":"2024.10.4","url":"/posts/fbaa48ef/","content":"模拟赛\n\n数据范围：1\\le n \\le 3\\times 10^5\n感觉自己的思路非常自然，所以写一下。\n一开始读错题了，没弄懂它的 s_1=s_2 是啥意思，以为只要元素一样就行了不用管顺序。\n如果不管顺序，那答案就是 \\sum_{i=1}^n \\binom{n}{i} \\times 2^i。\n但是我们是需要考虑顺序的。\n那么我们考虑什么时候是不合法的。\n例如 3773，这种情况下是不能把这两个数都选进去的，因为一定无法满足顺序一样。\n如果我们把每个数看成一条线段，那么可以发现，这种不合法的情况就是两条线段是包含关系。\n然后考虑合法情况。\n例如样例里的 1122，可以发现怎么选都是合法的。\n不难发现，这种情况是两条线段无交。\n再例如 1212，可以发现只有两种情况是合法的，要么都选左端点要么都选右端点。\n不难发现，这种情况是两条线段有交且不包含。\n但如果是一堆线段怎么办？\n如果连续若干条线段有交，可以发现总贡献依旧为 2。\n如果连续若干条线段无交，可以发现总贡献为 2^{num}。\n那么考虑 dp。\n设 f_i 表示第 i 条线段的贡献，转移为\n\nf_i=\\sum_{l_i>r_j}2\\times f_j+\\sum_{l_ir_j} f_j初始值为 f_i=2，因为每条线段都有两种选择。\n复杂度是 O(n^2) 的。考虑优化。\n不难发现，我们可以用前缀和来转移。\n但这样会少算一部分和多算一部分。\n我们把 dp 值放到每条线段的右端点上，然后用树状数组直接查询就可以了。\n复杂度 O(n\\log n)\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define lb(x) (x&amp;(-x))using namespace std;const int maxn=3e5+10,mod=998244353,inf=6e5;int n,ans;int f[maxn],s[maxn],tr[maxn&lt;&lt;1];struct line&#123;    int l,r;    inline bool operator &lt; (const line &amp;a)const&#123;        return l&lt;a.l;    &#125;&#125;t[maxn];inline void add(int x,int val)&#123;while(x&lt;=inf) tr[x]=(tr[x]+val)%mod,x+=lb(x);&#125;inline int query(int x)&#123;int res=0;while(x) res=(res+tr[x])%mod,x-=lb(x);return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;std.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n;    for(re int i=1,x;i&lt;=2*n;++i)&#123;        cin&gt;&gt;x;        if(!t[x].l) t[x].l=i;        else t[x].r=i;    &#125;    sort(t+1,t+n+1);    for(re int i=1;i&lt;=n;++i)&#123;        f[i]=2;        f[i]=(f[i]+s[i-1])%mod;        f[i]=(f[i]+query(t[i].l))%mod;        f[i]=((f[i]-(query(inf)-query(t[i].r))%mod)%mod+mod)%mod;        add(t[i].r,f[i]);        s[i]=(s[i-1]+f[i])%mod;    &#125;    for(re int i=1;i&lt;=n;++i) ans=(ans+f[i])%mod;    cout&lt;&lt;ans;    return 0;&#125;\n","categories":["每日记录"],"tags":["数据结构","dp","模拟赛"]},{"title":"2024.10.8","url":"/posts/f21c04c4/","content":"这几天一直在写各种分块，要写吐了。\n今天不剩啥时间了，写道板子题吧。\n[LnOI2019] 来者不拒，去者不追\n首先看到这个复杂度区间询问且能离线，肯定想到莫队。\n但第一感觉是不是以为这东西特别难维护？每次插入删除一个数，那排名不都变了吗？\n但你仔细想想，就会发现很好维护。\n假设现在插入一个 x，那么新增贡献就是 ((\\sum_{i=l}^r [a_i","categories":["每日记录"],"tags":["数据结构","莫队"]},{"title":"2024.9.27","url":"/posts/57d8e29d/","content":"一直在搭博客没怎么做题啊···\nTourism *2200\n首先手玩样例可以发现：环上的点可以都拿，连接环的点也可以都拿。\n然后考虑剩下的点。\n因为剩下的点只能选一条点权和最大的路径，所以考虑拓扑 dp。\n那么答案就是起点到环经过的点 + 环上的点的点权和 + \\max f_i\n学到的东西：看到这种类似不能重复走一条边的东西可以考虑缩点双（因为割边走过去不能回来）\nHappy Line *2200\n感觉很困难。我是性质低手/kk。\n假设当前 a_i,a_{i+1}  需要操作，那么操作完后会变成 a_{i+1}+1,a_i-1。\n对于 a_i，可以发现 a_i+i=(a_i-1)+(i+1)。\n即 val_i+pos_i=val_i'+pos_i'。\n不难推出，对于所有 i，都有 a_i+i 为定值。\n那么将 a_i+i 排序得到序列 b，答案就是 b_i-i。\n无解就是存在 b_i=b_{i+1}。\n学到的东西：对于这种交换位置的题，要往排序想，分析两个元素交换带来的影响（类似微扰法）。\nShort Code *2200\n读完题瞬间想到一个假做法：按长度从小到大排序，然后模拟。\n但这很容易 hack。对于一个很长的串，我们完全可以让它取很短的一部分，让一些短串取稍微长一些。这样比长串取很长短串取很短要优。\n那从大到小呢？也不行。\n因为很有可能长串取完以后，一些短串作为长串的前缀，就算全取也无法避免重复，这就不合法了。\n然后不会了。\n正解：\n建立 trie 树。此时问题变为：\n给一棵树，有一些黑点。可以把黑点移到祖先处，但两个黑点不能在同一个位置。求最小的黑点深度和。\n用堆维护每颗子树中黑点的深度，如果根上没有黑点就把最深的移到根。\n学到的东西：看到字符串前缀想到 trie（还是字符串做少了）。\n","categories":["每日记录"],"tags":["Codeforces","贪心"]},{"title":"2024.9.28","url":"/posts/c767ff0c/","content":"LaIS *2200\n没太想出来。\n设 f_i 表示以 i 为结尾的最长子序列长度。\n考虑如何从 j 转移到 i。\n若 a_j\\le a_i，那么直接转移即可。\n若 a_j > a_i，则需要考虑 j 的前驱 k。\n因为需要满足 \\min(a_k,a_j)\\le \\min(a_j,a_i)，即 a_k \\le a_i。\n那么我们贪心的想，让 j 越靠右越好，因为这样前驱 k 的范围就更大。\n那么我们维护一个单调栈，求出每个 i 左侧的第一个 j，使得 a_j > a_i。\n转移用树状数组即可。\n复杂度 O(n\\log n)\nHelping Hiasat *2200\n开到抽象题了。\n第一遍读错题了，没看到每一次都得一样。\n如果没有这个限制的话就很简单了，把相邻两个 1 之间划分成一个区间，找每个区间的众数即可。\n但现在有这个限制，怎么办？\n依旧考虑划分成若干区间，那么两个人可以共存当且仅当两个人从未同时出现过。\n如果两个人不能共存，那么就连一条边。最后求出这个图的最大独立集即可。\n这是一个 NPC 问题。\n不过有结论：原图的最大独立集=补图的最大团。\n最大团可以用 Bron–Kerbosch 算法在 O(2^{\\frac{n}{2}}) 的复杂度内求出。\n复杂度 O(nm^2+2^{\\frac{m}{2}})\nDemiurges Play Again *2200\n首先考虑权值给定怎么做。\n设 f_{u,0/1} 表示 u 点先/后手能取到的值。转移为\n\nf_{u,0}=\\max_{v \\in sub_u} f_{v,1}\n\\\\\nf_{u,1}=\\min_{v \\in sub_u} f_{v,0}然后考虑放权值。\n依旧设 f_{u,0/1}，表示 u 点先/后手能取到的值是该子树内第 f_{u,0/1} 大的数。\n那么转移是类似的，不过变成了第几大。\n对于 f_{u,0}，取 \\min 即可。\n对于 f_{u,1}，下一步由对方取最大值，而无论怎么放权值，对方都有可能不选择某子树。所以问题可以看作我们需要放多少个数进入叶子结点才可以让此时的玩家保证能够取到数。而能取到的最小值就是这些数的最后一个。因为是子树内的第几大，所以可以直接求和。\n综上，转移为\n\nf_{u,0}=\\min_{v \\in sub_u} f_{v,1}\n\\\\\nf_{u,1}=\\sum_{v \\in sub_u} f_{v,0}那么答案分别为 m-f_{1,0}+1,f_{1,1}。\n复杂度 O(n)\n因为有单调性，所以也可以二分变成判定性问题，不过似乎有点多此一举？\nYet Another Array Counting Problem *2300\n开到了笛卡尔树上 dp 板子。\n以下标为键，a_i 为值建立大根笛卡尔树，那么 [l,r] 的最左端最大值位置就是 l,r 在笛卡尔树上的 \\operatorname{lca}。\n那么所有最左端最大值位置都相等，就意味着笛卡尔树的形态相同。\n此时转化为树计数问题。\n设 f_{u,i} 表示 u 取值 1 \\sim i 的方案数。\n左儿子可以填 [1,i-1]，右儿子可以填 [1,i]\n转移就是 f_{u,i}=f_{u,i-1}+f_{ls_u,i-1}\\times f_{rs_u,i}\n复杂度 O(nm)\n","categories":["每日记录"],"tags":["Codeforces","dp"]},{"title":"2024.9.29","url":"/posts/b060cf9a/","content":"Funny Game *2200\n看了半个小时不会后看题解被嘲讽简单题后破防。\nKirill and Company *2200\n终于做到会的题了。\n看到 k 这么小，直接考虑状压。\n在处理最短路时，我们还要处理出每个点的搭载朋友情况。\n最后就是一个背包。\n复杂度 O((n+m)2^k+f(2^k)^2)\nRailguns *2200\n你指尖跃动的电光，是我此生不变的信仰。\n似乎不太难想？\n首先可以发现，答案上界为 n+m+r，因此可以枚举答案。\n设 f_{i,j,k} 表示第 k 秒时能否到达 (i,j)。转移为\n\nf_{i,j,k}|=(f_{i-1,j,k-1}|f_{i,j-1,k-1}|f_{i,j,k-1})我们在最外层枚举时间，然后 dp 即可。\n至于超电磁炮，我们都已经枚举时间了，那 dp 之前把对应状态直接限制一下就行了。\n复杂度 O(nmr)\n","categories":["每日记录"],"tags":["Codeforces","dp"]},{"title":"2024.9.30","url":"/posts/d0a7467f/","content":"Darth Vader and Tree *2200\n首先考虑暴力。\n设 f_i 表示距离根距离恰好为 i 的数量。转移为\n\nf_i=\\sum_{j=1}^n f_{i-d_j}但观察数据范围，发现 d_i\\le 100，说明不同的 d_i 很少。\n那么只需要对这些不同的 d_i 转移就行了。\n设 num_i=\\sum_{j=1}^n [d_j=i]，那么转移为\n\nf_i=\\sum_{j=1}^V num_j\\times f_{i-j} 这是一个常系数齐次线性递推方程，BM算法矩阵快速幂即可。\n最终答案为 \\sum_{i=1}^x f_i，可以在矩阵里顺便维护一下。\n复杂度 O(V^3\\log x)\nVladik and cards *2200\n容易想到状压。\n但第一个条件感觉很难搞，没法记录每个元素出现次数，怎么办？\n我们可以二分出所有的数字的最小出现次数 mid，那么每个元素出现次数只能为 mid 和 mid+1（经常在错解里想到这种思路，终于在这道题成为正解了）。\n设 f_{i,S} 表示到第 i 个位置，数字出现状态为 S 时，出现次数为 mid+1 的数的最大个数。\n这么设状态是因为，一个数的出现次数只能为 mid 和 mid+1，那肯定让 mid+1 的个数越多越好。\n转移比较简单，看每个数字出现 mid 次还是 mid+1 次即可。\n我们可以把每个数字出现的位置记录下来，方便转移。\n注意每种数字必须连续，也就是出现过后就不能再转移了。\n复杂度 O(2^Vn\\log n)\nTreeland Tour *2200\n树上路径问题直接考虑点分治。\n设当前分治重心为 rt，我们求出从叶子往 rt 走且以 i 结尾的 LIS 和 LDS。\n这个东西怎么求呢？\n每个点都只能从子树转移来，所以问题就是单点加子树查，弄个 dfn 序后线段树维护即可。\n统计答案时，考虑包不包含 rt。\n设 up_i 表示以 i 结尾的 LIS 长度， down_i 表示以 i 结尾的 LDS 长度。\n对 up_i 和 down_i 分别做前缀 max 和后缀 max。\n包含 rt：ans=\\max up_{a_{rt}-1}+down_{a_{rt}+1}+1\n不包含 rt：ans=\\max up_i+down_{i+1}\n然后完了？\n显然没有，因为如果两条路径来自同一颗子树内就寄了。\n那么线段树在维护时，记录最大值和次大值，以及来自哪棵子树即可。\n统计答案时特判一下。\n复杂度 O(n\\log^2 n)\nFelicity’s Big Secret Revealed *2200\n简单性质题。\n不难发现答案 x 不会很大。因为 n\\le 75，所以 x\\le 20。 \n那就考虑状压，设 f_{i,S} 表示这一刀切在 i 前，状态为 S 时的方案数。\n转移就枚举上一刀切在哪。\n转移为 \n\nf_{i,S}=\\sum f_{j,S/T}把 [j,i-1] 组成的数去掉即可。\n答案为 \\sum f_{i,2^j-1}\n复杂度 O(n2^V)\nAbbreviation *2200\n唐唐唐，下次读题能不能读仔细点。\n做了半个小时+看了半天题解才发现翻译里最后一句写着“至多进行一次操作”\n绷不住了。\n那就好做了。枚举缩哪一段区间即可。\n具体的，我们可以先处理出 f_{i,j} 表示 i 和 j 向后匹配的最长长度。\n然后枚举缩哪段区间，然后向后暴力缩就行了。\n复杂度 O(n^3+n|\\sum s_i|)\n代码可参考官方题解。\nThree Pieces *2200\n很厉害的一道题，完全没想出来。\n考虑 dp。\n设 f_{i,j,k,0/1/2} 表示当前在 (i,j)，已经填了 1\\sim k，且当前是 0/1/2 棋子的最小花费。\n但这个 dp 有一个问题：不知道转移顺序。\n所以考虑用最短路转移。\n转移分三种：\n\n换棋子，代价为 inf+1\n移动棋子，代价为 inf\n填数（即 (i,j) 所在的数是下一个数），代价为 0\n\n这里有一个 trick：因为还要求换的次数最小，所以可以设一个极大值，将移动棋子设为 inf，换棋子设为 inf+1，这样就可以做到双关键字了。\n输出答案时，时间就是 ans/inf，换的次数就是 ans\\%inf。\n一共 O(n^4) 个点，O(n^5) 条边。\n","categories":["每日记录"],"tags":["数据结构","Codeforces","dp","贪心","矩阵乘法"]},{"title":"bitset学习笔记","url":"/posts/8ee3bcd9/","content":"参考文章\n一直不会用 bitset，今天终于下定决心学一下。\nbitset 是一个很好用的 STL，且时间复杂度和空间复杂度都很优秀。\nbitset 是一个 01 串，每一位占一个 bit。\nbitset 的下标是从右往左的。例如 f_1=1，那么得到的 bitset 应该是 00010 之类的东西。\n所以后面的左移右移才是那样。\n如何声明首先，我们需要引用 &lt;bitset&gt; 头文件。\n声明方式为\nbitset&lt;maxn&gt; s;\nmaxn 为长度。\n修改与运算bitset 中每一个元素可以通过下标的方式访问。\n进行单点修改时，直接访问位置然后赋值即可。\ns[pos]=1;\nbitset 还支持位运算，返回值为一个 bitset。\ns&lt;&lt;=x;s&gt;&gt;=x;s&amp;=s1;s|=s1;s^=s1;\n复杂度设计算机字长为 \\omega，则一次操作的复杂度为 O(\\frac{n}{\\omega})。\n因为 \\omega 位才占一个整形长度，所以空间复杂度为 O(\\frac{n}{\\omega})。\n成员函数1.reset\n将 bitset 每一位都置为 0。\ns.reset();\n2.set\n如果不传参数，会将每一位都置为 1。复杂度 O(\\frac{n}{\\omega})。\n如果传参数，那么第一个参数为 pos，第二个参数为 val，意为把第 pos 位置为 val。\n如果不传 val，那么默认为 1。\ns.set();s.set(1);s.set(1,0);\n3.test\n有一个参数 pos，返回第 pos 位的值。\ns.test(1);\n4.any\n若 bitset 内存在 1，则返回 1，否则返回 0。\ncout&lt;&lt;s.any();\n5.none\n若 bitset 内所有位都是 0，则返回 1，否则返回 0。\ncout&lt;&lt;s.none();\n6.all\n若 bitset 内所有位都是 1，则返回 1，否则返回 0。\ncout&lt;&lt;s.all();\n7.count\n返回 bitset 内 1 的个数。\ncout&lt;&lt;s.count();\n8.flip\n把每一位取反。\n如果传参数 pos，那么就把第 pos 位取反。\ns.flip();s.flip(1);\n9._Find_first\n返回 bitset 第一个 1 的位置，不存在则返回 bitset 大小。\ncout&lt;&lt;s._Find_first();\n10._Find_next\n需要传参数 pos，返回下标严格大于 pos 的位置中第一个 1 的位置。\ncout&lt;&lt;s._Find_next(1);\n应用bitset 优化 dp对于一些可行性 dp，可以 bitset 优化。\nP1537 弹珠这是一道多重背包，不过可以当 01 背包做。\n但这是可行性背包，所以用 bitset 优化一下就可以了。\n复杂度为 O(\\frac{n\\sum w_i}{\\omega})\n这里给出优化 01 背包的代码。\nf.set(0);for(re int i=1;i&lt;=n;++i) f|=(f&lt;&lt;w[i]);\nEarn or Unlock *2200首先可以发现，如果最后一共解锁了 x 张牌，那么分数为 (\\sum_{i=1}^x a_i)-(x-1)。\n因为我们一开始只有一张牌，想解锁剩下的 x-1 张就必须花 x-1 的代价。\n然后显然解锁的牌可以都拿，那么就是一个前缀和再减去代价。\n所以我们只需要判断是否存在一种方案使得恰好解锁 x 张牌即可。\n复杂度 O(n^2) 的 dp 显然，考虑优化。\n但这是可行性 dp，可以用 bitset 优化。\n事实上也是个 01 背包。\n复杂度 O(\\frac {n^2}{\\omega})\n一些细节：\n\nx 可以达到 2n。\n\n这里的背包比较特殊，因为如果我们用第 i 张牌解锁后面的牌，那么恰好解锁 i 张牌这个状态也就不能为后续提供转移了。所以我们还需要再开个数组，记录每种值能否被恰好取到。\n\n\nbitset 结合莫队[Ynoi2017] 由乃的玉米田区间询问可离线，考虑莫队。\n我们维护两个 bitset，分别为 v1 和 v2。\n设值域为 V。\n如果 x 在当前区间出现，那么 v1[x]=v2[V-x]=1。\n对于减法操作，答案为 (v1&amp;(v1&lt;&lt;x)).any()。\n这很好理解。\n假设 a-b=x，那么当前区间一定存在 a 和 a-x。\n所以我们把 v1 和 (v1&lt;&lt;x) 与一下，看看能否满足即可。\n对于加法操作，答案为 (v1&amp;(v2&gt;&gt;(V-x))).any()。\n设 b'=V-b，那么 b 在 v1 和 b' 在 v2 中是对应的。\n假设 a+b=x，那么 a+V-b'=x。\n再移项一下，那么 a-b'=x-V。\n这里已经转化成减法了。\n因为 x-V 是负数，所以把左移变成右移。\n所以我们把 v1 和 (v2&gt;&gt;(V-x)) 与一下，看看能否满足即可。\n对于乘法操作，我们可以考虑枚举约数，然后看 i 和 \\frac {x}{i} 是否都存在。\n这个复杂度是 O(\\sqrt n) 的。\n对于除法操作，考虑根号分治。\n对于 x \\ge \\sqrt V，直接暴力枚举，然后看 i 和 i\\times x 是否都存在即可。\n这个复杂度是 O(\\sqrt n) 的。\n对于 x < \\sqrt V，我们不使用莫队，而是单独处理。\n首先将询问离线，然后枚举 x。\n对于每个 x，我们扫一遍序列。\n记 last_i 表示 i 当前最后一次出现的位置。\n记 ans_i 表示满足在 [l,i] 中，同时存在 a_i 和 a_i \\times x 或同时存在 a_i 和 \\frac {a_i}{x} 的最靠右的 l 的位置。 \n设当前扫到 i，那么先更新 last_{a_i}，再用 last_{a_i\\times x} 和 last_{\\frac {a_i}{x}} 更新 res_i 即可。\n扫完以后，我们回答以当前枚举到的 x 作为 x 的询问。\n设询问区间为 [l,r]，那么只要 l \\le res_r，该询问就合法。\n因为 x 只有 \\sqrt V 个，所以复杂度为 O(n\\sqrt n)\n综上，总复杂度为 O(n\\sqrt n)。\ncode：\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e5+10,V=1e5,lim=300;int n,m,Q,siz;int a[maxn],buc[maxn],lst[maxn],res[maxn];struct query&#123;    int op,l,r,x,id;&#125;q[maxn];bitset&lt;maxn&gt; v1,v2,ans;vector&lt;query&gt; q1[maxn];inline bool cmp(query a,query b)&#123;return ((a.l/siz)^(b.l/siz))?(a.l/siz)&lt;(b.l/siz):((a.l/siz)&amp;1)?a.r&lt;b.r:a.r&gt;b.r;&#125;inline void add(int x)&#123;    ++buc[x];    v1[x]=v2[V-x]=(buc[x]);&#125;inline void del(int x)&#123;    --buc[x];    v1[x]=v2[V-x]=(buc[x]);&#125;inline void solve()&#123;    for(re int x=1,l;x&lt;=lim;++x)&#123;        memset(lst,0,sizeof lst);        memset(res,0,sizeof res);        l=0;        for(re int i=1;i&lt;=n;++i)&#123;            lst[a[i]]=i;            if(x*a[i]&lt;=V) l=max(l,lst[x*a[i]]);            if(a[i]%x==0) l=max(l,lst[a[i]/x]);            res[i]=l;        &#125;        for(auto v:q1[x]) ans[v.id]=(v.l&lt;=res[v.r]);    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;Q;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];    for(re int i=1,op,l,r,x;i&lt;=Q;++i)&#123;        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r&gt;&gt;x;        if(op==4&amp;&amp;x&lt;=lim) q1[x].push_back(&#123;op,l,r,x,i&#125;);        else q[++m]=&#123;op,l,r,x,i&#125;;    &#125;    solve();    siz=sqrt(n)+1;    sort(q+1,q+m+1,cmp);    int l=1,r=0;    for(re int i=1;i&lt;=m;++i)&#123;        while(r&lt;q[i].r) add(a[++r]);        while(l&gt;q[i].l) add(a[--l]);        while(r&gt;q[i].r) del(a[r--]);        while(l&lt;q[i].l) del(a[l++]);        if(q[i].op==1) ans[q[i].id]=(v1&amp;(v1&lt;&lt;q[i].x)).any();        if(q[i].op==2) ans[q[i].id]=(v1&amp;(v2&gt;&gt;(V-q[i].x))).any();        if(q[i].op==3) for(re int j=1;j*j&lt;=q[i].x;++j) if(!(q[i].x%j)) if(v1[j]&amp;&amp;v1[q[i].x/j]) ans[q[i].id]=1;        if(q[i].op==4) for(re int j=1;j*q[i].x&lt;=V;++j) if(v1[j]&amp;&amp;v1[j*q[i].x]) ans[q[i].id]=1;    &#125;    for(re int i=1;i&lt;=Q;++i) cout&lt;&lt;(ans[i]?&quot;yuno&quot;:&quot;yumi&quot;)&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n","categories":["学习笔记"],"tags":["数据结构","莫队","dp"]},{"title":"Slope Trick学习笔记","url":"/posts/58d4c0dc/","content":"参考文章\n引入太困难了···\nSlope Trick 是一种维护凸包的方法，通常用来优化 dp。\n一般可以使用 Slope Trick 优化的 dp 方程需要满足：\n\n是连续的\n是分段一次函数\n有凸性\n\n一些性质：\n\n两个凸函数相加还是凸函数\n凸函数加一次函数还是凸函数\n\n一些名词：\n\n拐点：函数斜率改变的点\n决策点：纵坐标为答案的点\n\n\n具体内容通过例题讲解，不然还是太难懂了。\n例题Sequence *2200首先考虑暴力 dp。\n因为要将序列变为非降数列，所以有一个性质：最终序列的数集不会变大。\n证明很好证：\n因为只有序列某一位置严格递减时，我们才会进行修改。\n而修改要么将前面的数减到和后面的数一样大，要么将后面的数加到和前面的数一样大。\n这两个操作都不会让数集变大。\n所以设 f_{i,j} 表示将第 i 个数变为 j 的最小代价，转移为\n\nf_{i,j}=\\min_{k \\le j} f_{i-1,k}+|a_i-j|这是 O(n^2) 的，虽然能通过本题，但我们考虑优化。\n我们把这个 dp 变一下，方便理解。\n设 f_{i,j} 表示将第 i 个数变为 j 的最小代价，g_{i,j} 表示将第 i 个数变为 \\le j 的最小代价。\n则转移为\n\nf_{i,j}=g_{i-1,j}+|a_i-j|\n\\\\\ng_{i,j}=\\min_{k\\le j} f_{i,k}我们固定 i ，以 j 为横坐标，dp 值为纵坐标建系。\n这里偷同学几张图。\n可以得到，f_1 为：\n\n因为 g 是 f 的前缀 \\min，所以 g_1 为：\n\n根据 dp 式可以发现，g_2 是由 f_1 这个函数加一个绝对值函数得到的。\n这里需要分类讨论：绝对值函数的拐点在 f_1 的决策点的左/右侧。\n如果在右侧，那么是这样的\n\n相加后可以得到 g_2 为\n\n从而可以得到 f_2 为\n\n如果在左侧，那么是这样的\n\n相加后可以得到 g_2 为\n\n从而可以得到 f_2 为\n\n答案为 f_n 的最小值。\n可以发现，只有绝对值函数的拐点在决策点左侧时，答案才会更新。\n那么答案变化了多少呢？\n\n图中 BAGH 为原来的 f_i，JCK 为加的绝对值函数，BMNO 为加完以后的 f_i'。\n那么答案的变化量为 N 和 G 的纵坐标之差。\n通过观察几何性质，可以发现这东西就等于原绝对值函数拐点的横坐标。\n然后考虑怎么维护函数 f_i。（接下来我可能会说的比较抽象且啰嗦，因为我实在不知道怎么才能说明白）\n我们可以维护一个堆，堆里存函数的所有拐点。这道题中我们需要维护大根堆，这样堆顶就是我们需要的决策点。\n然后我们把斜率挂到点上维护，当然我们需要钦定每个点维护的是左侧的线段还是右侧的线段。\n这里我们钦定每个点维护左侧的线段的斜率。\n\n那这个斜率到底怎么表示呢？别急，看下面。\n然后考虑加绝对值函数的操作。可以发现，这个操作事实上就是在让绝对值函数拐点左侧的函数斜率 -1，拐点右侧的函数斜率 +1。\n当拐点在决策点右侧或决策点上时，我们会让拐点左侧的函数斜率 -1，右侧的函数斜率 +1。但因为取 \\min 了，所以右侧函数斜率还是 0。\n对应到操作上，就是把绝对值函数拐点加进堆里。\n可以发现，此时堆中每个点维护的对应线段的斜率就是其在堆中排名 -1 的相反数（因为这个函数的斜率都是负数）。\n如果如果相邻两个点间的斜率差  > 1 怎么办？\n那就把一个点插入多次。\n但这样会存在一些假点，这些点并没有意义。\n所以我们的斜率要变一下：堆中每个点维护的对应线段的斜率就是与其值相同的最左侧的点在堆中排名 -1 的相反数。\n当拐点在决策点左侧时，因为要让拐点左侧的函数斜率 -1，右侧的函数斜率 +1，所以对应到操作上应该插入两个拐点，因为斜率变化为 2。\n插入完后，我们还要把原来的决策点扔掉，因为它已经不是当前的决策点了。\n然后我们维护完了这个函数，且求出了答案。\n复杂度 O(n\\log n)\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;int n,ans;priority_queue&lt;int&gt; q;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    int x;    cin&gt;&gt;n&gt;&gt;x;    q.push(x);//第一个点先直接插进去    for(re int i=2;i&lt;=n;++i)&#123;        cin&gt;&gt;x;        if(x&gt;=q.top()) q.push(x);//拐点在决策点的右侧或决策点原位        else&#123;            //拐点在决策点左侧            ans+=q.top()-x;//加上答案变化量            q.push(x);//插两个是因为斜率变化量为2            q.push(x);            q.pop();//把原来的决策点扔掉，因为它已经不是当前的决策点了        &#125;    &#125;    cout&lt;&lt;ans;    return 0;&#125;\nBuy Low Sell High *2400首先考虑暴力 dp。\n设 f_{i,j} 表示第 i 天有 j 股的最大值，转移为\n\nf_{i,j}=\\max (f_{i-1,j},f_{i-1,j+1}+a_i,f_{i-1,j-1}-a_i)答案为 f_{n,0}。\n感性理解一下，可以发现这个函数是凸的。\n但这个函数的变化就不是每次加一个凸函数了，而是函数平移然后取 \\max。\n第一个转移可以直接转移过来，这样后面的取 \\max 都是和原函数取 \\max 了。\n后面的两个转移可以看成把函数加一个平移向量 (-1,a_i) 和 (1,-a_i)。\n先考虑左上平移：\n图中 A1B1C1D1 为平移后的函数。\n\n取完 \\max 后长这样\n\n对于左上平移，可以发现，原函数中斜率 \\ge 移动斜率的的部分都会被平移后的函数在取 \\max 时覆盖掉，而 ","categories":["学习笔记"],"tags":["dp"]},{"title":"test","url":"/posts/d87f7e0c/","content":"\n      \n        9909b57be5bf2715bfc0414762049c626a1198c83447f36b58b5f10e3e41898bb49bc53f64735cdad06ebaf55196d29598358afa816a5fb655af071f1ffc3cda5170426a0717c4edfa36f8458816955d0ea94e3abb8eb36ebed6149f9cb48580665e9738d4ef1ee4604bd3501b96e93659a8caeaae3f8d9a37977f4554e82a61ea51512a4e942f15ef573d38dddbb370\n      \n      \n        \n          \n          \n            请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n          \n        \n        \n      \n    \n    "},{"title":"值域分块学习笔记","url":"/posts/323f9b89/","content":"参考文章\n又是一个很有用但一直不会的东西，今天学习一下。\n不过写的还是比较浅显，可以看参考文章，讲的很好。\n什么是值域分块普通的分块都学过，它是对序列分块的。\n而值域分块，顾名思义，是对值域分块。\n序列分块和值域分块的关系就像线段树和权值线段树的关系一样，一个维护序列，一个维护值域。\n两种常用的值域分块第一种：修改 O(1)，查询 O(\\sqrt n)\n维护每个值域上每个值的值和每个值域块内的值的总和。\ninline void add(int x)&#123;++cnt1[x],++cnt2[bel[x]];&#125;inline int query1(int l,int r)&#123;    int L=bel[l],R=bel[r],res=0;    if(L==R) for(re int i=l;i&lt;=r;++i) res+=cnt1[i];    else&#123;        for(re int i=l;i&lt;=ed[L];++i) res+=cnt1[i];        for(re int i=st[R];i&lt;=r;++i) res+=cnt1[i];        for(re int i=L+1;i&lt;=R-1;++i) res+=cnt2[i];    &#125;    return res;&#125;\n第二种：修改 O(\\sqrt n)，查询 O(1)\n维护每个值域上每个值的值的前缀和，修改时整块打标记，散块暴力加。\n区间查询可以差分成两个前缀和。\ninline void add(int x)&#123;    if(tag1[bel[x]])&#123;        for(re int i=st[bel[x]];i&lt;=ed[bel[x]];++i) cnt[i]+=tag1[bel[x]];        tag1[bel[x]]=0;    &#125;    if(tag2[bel[x]])&#123;        for(re int i=st[bel[x]];i&lt;=ed[bel[x]];++i) sum[i]+=tag2[bel[x]];        tag2[bel[x]]=0;    &#125;    for(re int i=x;i&lt;=ed[bel[x]];++i) ++cnt[i],sum[i]+=x;    for(re int i=bel[x]+1;i&lt;=tot;++i) ++tag1[i],tag2[i]+=x;&#125;inline int query1(int x)&#123;return tag1[bel[x]]+cnt[x];&#125;inline int query2(int x)&#123;return tag2[bel[x]]+sum[x];&#125;\n应用值域分块一般用来平衡复杂度。\n例如莫队，我们有 O(n\\sqrt n) 次修改和  O(n) 次查询，这时可以用 O(1) 修改，O(\\sqrt n) 查询的值域分块平衡复杂度。\n而如果用 O(\\log n) 修改，O(\\log n) 查询的其他数据结构，复杂度就来到了混乱邪恶的 O(n\\sqrt n \\log n)，不可接受。\n值域分块配合莫队[AHOI2013] 作业可以说是板子题了。\n使用 O(1) 修改，O(\\sqrt n) 查询的值域分块。\n复杂度 O(n\\sqrt n)。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e5+10,maxm=500;int n,m,siz,tot;int a[maxn];int ans1[maxn],ans2[maxn];int st[maxm],ed[maxm],bel[maxn];int cnt1[maxm],cnt2[maxn],cnt3[maxm];struct query&#123;    int l,r,a,b,id;&#125;q[maxn];inline bool cmp(query a,query b)&#123;return ((a.l/siz)^(b.l/siz))?(a.l/siz)&lt;(b.l/siz):((a.l/siz)&amp;1)?a.r&lt;b.r:a.r&gt;b.r;&#125;inline void init()&#123;    siz=sqrt(n);    tot=n/siz;    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;n) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=n;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i;&#125;inline void add(int x)&#123;    if(!cnt2[x]) ++cnt3[bel[x]];    ++cnt1[bel[x]];    ++cnt2[x];&#125;inline void del(int x)&#123;    --cnt1[bel[x]];    --cnt2[x];    if(!cnt2[x]) --cnt3[bel[x]];&#125;inline int get_ans1(int l,int r)&#123;    int L=bel[l],R=bel[r];    int res=0;    if(L==R) for(re int i=l;i&lt;=r;++i) res+=cnt2[i];    else&#123;        for(re int i=l;i&lt;=ed[L];++i) res+=cnt2[i];        for(re int i=st[R];i&lt;=r;++i) res+=cnt2[i];        for(re int i=L+1;i&lt;=R-1;++i) res+=cnt1[i];    &#125;    return res;&#125;inline int get_ans2(int l,int r)&#123;    int L=bel[l],R=bel[r];    int res=0;    if(L==R) for(re int i=l;i&lt;=r;++i) res+=(bool)cnt2[i];    else&#123;        for(re int i=l;i&lt;=ed[L];++i) res+=(bool)cnt2[i];        for(re int i=st[R];i&lt;=r;++i) res+=(bool)cnt2[i];        for(re int i=L+1;i&lt;=R-1;++i) res+=cnt3[i];    &#125;    return res;&#125;signed main()&#123;    #ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);    #endif\t    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];    for(re int i=1;i&lt;=m;++i) cin&gt;&gt;q[i].l&gt;&gt;q[i].r&gt;&gt;q[i].a&gt;&gt;q[i].b,q[i].id=i;    init();    sort(q+1,q+m+1,cmp);    int l=1,r=0;    for(re int i=1;i&lt;=m;++i)&#123;        while(r&lt;q[i].r) add(a[++r]);        while(l&gt;q[i].l) add(a[--l]);        while(r&gt;q[i].r) del(a[r--]);        while(l&lt;q[i].l) del(a[l++]);        ans1[q[i].id]=get_ans1(q[i].a,q[i].b);        ans2[q[i].id]=get_ans2(q[i].a,q[i].b);    &#125;    for(re int i=1;i&lt;=m;++i) cout&lt;&lt;ans1[i]&lt;&lt;&quot; &quot;&lt;&lt;ans2[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n[Ynoi2019 模拟赛] Yuno loves sqrt technology II区间逆序对，不难想到用树状数组维护修改。\n但这样复杂度是 O(n\\sqrt n \\log n) 的，不能接受。\n但可以发现，这个贡献是可以差分的，所以考虑莫队二次离线。\n这里还是把二离详细说一下吧（毕竟我也不太懂）。\n假设当前在区间 [l,r]。\n我们分四种情况讨论指针的移动。\n1.右指针右移\n考虑当前到的位置 r+1，此时会产生的新贡献是 [l,r] 里大于 a_{r+1} 的个数。\n可以差分成 [1,r] 中大于 a_{r+1} 的个数减去 [1,l-1] 大于 a_{r+1} 的个数。\n2.右指针左移\n考虑当前到的位置 r-1，此时会减少的贡献是 [l,r-1] 里大于 a_r 的个数。\n可以差分成 [1,r-1] 中大于 a_r 的个数减去 [1,l-1] 大于 a_r 的个数。\n3.左指针左移\n考虑当前到的位置 l-1，此时会产生的新贡献是 [l,r] 里小于 a_{l-1} 的个数。\n可以差分成 [1,r] 中小于 a_{l-1} 的个数减去 [1,l-1] 小于 a_{l-1} 的个数。\n4.左指针右移\n考虑当前到的位置 l+1，此时会减少的贡献是 [l+1,r] 里小于 a_l 的个数。\n可以差分成 [1,r] 中小于 a_l 的个数减去 [1,l] 小于 a_l 的个数。\n请注意上文的减少，因为是减少下面的那个东西，所以要记得变号。\n然后可以发现有一些可以预处理出来。\n例如 [1,i-1] 中 > a_i 的个数，[1,i] 中 < a_i 的个数。\n然后剩下的部分离线下来，一共 O(n\\sqrt n) 次修改和 O(n) 次询问。\n然后扫描线，用数据结构维护剩下形如：每次求一个前缀中 > x 或 < x 的数的个数。\n这让你想到了什么？值域分块！\n我们用 O(1) 修改，O(\\sqrt n) 查询的值域分块维护这个东西。\n最后，别忘了我们上面讨论的都是变化量，相当于答案的差分，所以最后还要求个前缀和得到答案。\n然后大概就做完了，吗？\nYnoi，怎么能不卡常呢？\n首先是卡空间。\n我们如果直接存 O(n\\sqrt n) 次修改，空间复杂度是 O(n\\sqrt n) 的。\n但是不难发现，莫队每次的指针移动是一段区间，所以直接把这一段区间一块存下来就行了。\n空间复杂度变为 O(n)。\n然后是卡时间。\n预处理的那部分最好直接处理前缀和（然而代码里没这么写）。\n少开 long long。\n值域分块最好这么分：\n维护值域上每个数的出现次数的前缀和，然后单点修改打标记。这样常数很小。\n而不是这么分：\n维护值域块的前缀和以及每个值域块内的前缀和，单点修改直接改前缀和即可。常数较大。\n代码里是第二种，因为第一种写挂了。\n改成第一种就能过了。\n下面是一份可以在 300ms 左右通过所有数据的代码。\n不想卡常了。\nupd：我终于调出来了。\n所以下面是一份正确代码。\n#include&quot;bits/stdc++.h&quot;#define re register// #define int long long#define lb(x) (x&amp;(-x))using namespace std;const int maxn=1e5+10,maxm=500;int n,m,siz,tot,len;int a[maxn],b[maxn],tr[maxn];int st[maxm],ed[maxm],bel[maxn],idx[maxn];int fl[maxn],fr[maxn];int cnt[maxn],tag[maxm];long long ans[maxn];struct query&#123;    int l,r,id;    long long ans;&#125;q[maxn];struct node&#123;    int l,r,id,op;&#125;;vector&lt;node&gt; g1[maxn],g2[maxn];inline bool cmp(query a,query b)&#123;return ((a.l/siz)^(b.l/siz))?(a.l/siz)&lt;(b.l/siz):((a.l/siz)&amp;1)?a.r&lt;b.r:a.r&gt;b.r;&#125;inline void add(int x,int val)&#123;while(x&lt;=maxn) tr[x]+=val,x+=lb(x);&#125;inline int query(int x)&#123;int res=0;while(x&gt;0) res+=tr[x],x-=lb(x);return res;&#125;inline void pre()&#123;    for(re int i=1;i&lt;=n;++i)&#123;        fr[i]=i-1-query(a[i]);        add(a[i],1);    &#125;    for(re int i=1;i&lt;=n;++i) add(a[i],-1);    for(re int i=1;i&lt;=n;++i)&#123;        add(a[i],1);        fl[i]=query(a[i]-1);    &#125;&#125;inline void init()&#123;    siz=sqrt(len);    tot=ceil(len/siz);    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;len) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=len;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i,idx[j]=j-st[i]+1;&#125;inline void update(int x,int val)&#123;    if(tag[bel[x]])&#123;        for(re int i=st[bel[x]];i&lt;=ed[bel[x]];++i) cnt[i]+=tag[bel[x]];        tag[bel[x]]=0;    &#125;    for(re int i=x;i&lt;=ed[bel[x]];++i) cnt[i]+=val;    for(re int i=bel[x]+1;i&lt;=tot;++i) tag[i]+=val;&#125;inline int query1(int x)&#123;return tag[bel[x]]+cnt[x];&#125;inline void solve_l()&#123;    for(re int i=1;i&lt;=n;++i)&#123;        update(a[i],1);        for(auto t:g1[i])&#123;            for(re int j=t.l;j&lt;=t.r;++j)&#123;                q[t.id].ans+=t.op*(i-query1(a[j]));            &#125;        &#125;    &#125;    for(re int i=1;i&lt;=n;++i) update(a[i],-1);&#125;inline void solve_r()&#123;    for(re int i=1;i&lt;=n;++i)&#123;        update(a[i],1);        for(auto t:g2[i])&#123;            for(re int j=t.l;j&lt;=t.r;++j)&#123;                q[t.id].ans+=t.op*query1(a[j]-1);            &#125;        &#125;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],b[i]=a[i];    sort(b+1,b+n+1);    len=unique(b+1,b+n+1)-(b+1);    for(re int i=1;i&lt;=n;++i) a[i]=lower_bound(b+1,b+len+1,a[i])-b;    pre();    for(re int i=1;i&lt;=m;++i) cin&gt;&gt;q[i].l&gt;&gt;q[i].r,q[i].id=i;    siz=sqrt(n);    sort(q+1,q+m+1,cmp);    int l=1,r=0;    for(re int i=1;i&lt;=m;++i)&#123;        if(r&lt;q[i].r)&#123;            g1[l-1].push_back(&#123;r+1,q[i].r,i,-1&#125;);            while(r&lt;q[i].r) q[i].ans+=fr[++r];        &#125;        if(l&gt;q[i].l)&#123;            g2[r].push_back(&#123;q[i].l,l-1,i,1&#125;);            while(l&gt;q[i].l) q[i].ans-=fl[--l];        &#125;        if(r&gt;q[i].r)&#123;            g1[l-1].push_back(&#123;q[i].r+1,r,i,1&#125;);            while(r&gt;q[i].r) q[i].ans-=fr[r--];        &#125;        if(l&lt;q[i].l)&#123;            g2[r].push_back(&#123;l,q[i].l-1,i,-1&#125;);            while(l&lt;q[i].l) q[i].ans+=fl[l++];        &#125;    &#125;    init();    solve_l();    solve_r();    for(re int i=1;i&lt;=m;++i) q[i].ans+=q[i-1].ans;    for(re int i=1;i&lt;=m;++i) ans[q[i].id]=q[i].ans;    for(re int i=1;i&lt;=m;++i) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n值域分块配合根号分治[JRKSJ R4] risrqnis很好的一道题，加深了我对根号分治和平衡复杂度的理解。\n首先考虑 m=1 怎么做。\n这个对值域上的操作很讨厌，因为值域很大。\n但不难发现，把所有操作离线后离散化，可以做到值域 O(n)，且每个数至多被加入一次。\n所以我们把每个数挂到对应的值上，然后用 set 维护还没有被加入的数，每次加入时查值域上的前驱后继即可。至于求和，树状数组维护即可。\n这样做的话，均摊复杂度是 O(n\\log n) 的。\n那 m \\le 10^9 怎么办？\n首先可以把 m 离散化到 O(n)。\n然后关键来了：考虑对每个集合的操作次数根号分治。\n对于操作次数 > \\sqrt n 的集合，个数是 O(\\sqrt n) 的，那么我们直接按上面那个做法做，总复杂度是 O(n\\sqrt n \\log n) 的。\n但这个复杂度是不能接受的。\n但可以发现，我们一共有 O(n\\sqrt n) 次修改和 O(n) 次查询（这里可能会有疑惑：每个集合的修改和询问不都是 O(n) 的吗？那总的操作为什么不都是 O(n\\sqrt n)？因为总的操作次数一共是 O(n) 的，而修改是值域上的修改，所以可以保证每个集合都做到 O(n) 次修改，但查询是有总和保证的，总询问一定也是 O(n) 的）。\n所以可以用序列分块来平衡复杂度，这样可以做到 O(1) 修改，O(\\sqrt n) 查询。\n然后瓶颈就是 set 每次查找的 O(\\log n) 了，我们考虑去掉这个 \\log 。\n一开始想到的是链表，但链表删除虽然是 O(1)，但每次还得找第一个没被删的，这是 O(n) 的。\n然后想到并查集，发现可以做。\n思路还是和链表一样，每删一个就更新父亲，相当于把那个数删除了。\n每次找的时候也是找父亲。\n总复杂度为 O(n\\sqrt n \\alpha(n))\n然后考虑操作次数 < \\sqrt n 的集合。\n这种集合的个数是 O(n) 的，但操作次数是 O(\\sqrt n) 的。\n这可以得到一个很关键的性质：操作后的值域上的连续段个数不超过 O(\\sqrt n)。\n然后我们再想想询问在干什么：求值域上在已经出现过的连续段内且序列上下标在 [l,r] 之间的点的个数。\n这是个标准的二维数点。\n因为连续段个数不超过 O(\\sqrt n)，所以询问可以看成对 O(\\sqrt n) 个连续段分别查询。\n那么一共有 O(n) 次修改和 O(n\\sqrt n) 次询问（这里可能又有疑惑：一共 O(n) 个集合，每个集合修改次数都是 O(n) 的，那为什么总修改次数还是 O(n) 的？因为可以发现，具体是哪个集合对答案没有影响，所以我们可以先把所有询问离线下来，这样一共有 O(n\\sqrt n) 次询问，但我们只需要修改 O(n) 次即可）。\n考虑扫描序列维，然后用值域分块维护另一维。\n总复杂度 O(n\\sqrt n)\n综上，总复杂度为 O(n\\sqrt n \\alpha(n))。\n但你先别急，因为这东西空间复杂度是 O(n\\sqrt n)，直接炸了。\n然后有一些神奇技巧来优化空间，例如离线逐块处理，分散层叠等。\n但我摆了。\n还有个坑点，在处理小块的时候，我们要离线询问，但是不能直接离线。\n例如第一次修改，把值域 [l_1,r_1] 加进去，第二次修改，把值域 [l_2,r_2] 加进去。\n如果这两段有交，那么交集部分不能算两次，只能算一次。\n所以离线询问时要处理这个东西。\n注意特殊处理 m=1 ，因为空间开不下。\n还有注意离散化后值域是 3\\times 10^6\n代码是空间 O(n\\sqrt n) 的，只能得 45 pts。\n#include&quot;bits/stdc++.h&quot;#define re register// #define int long long#define pii pair&lt;int,int&gt; #define fi first#define se second#define lb(x) (x&amp;(-x))using namespace std;const int maxn=1e6+10,maxm=1750;int n,m,Q,siz,tot,cnt;int a[maxn],b[3*maxn],ans[maxn],fa[maxn*3];int st[maxm],ed[maxm],bel[maxn],idx[maxn];int sum1[maxn],sum2[maxm];pii stk[maxn];int cnt1[maxn*3],cnt2[maxm][maxm];struct query&#123;    int op,l,r,k,id;&#125;q[maxn];vector&lt;int&gt; g[maxn],s[maxn];vector&lt;query&gt; q1[maxn];inline void init()&#123;    int tmp=max(n,cnt);    siz=sqrt(tmp);    tot=ceil(tmp/siz);    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;tmp) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=tmp;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i,idx[j]=j-st[i]+1;&#125;inline void clear()&#123;    for(re int i=1;i&lt;=cnt+1;++i) fa[i]=i;    memset(sum1,0,sizeof sum1),memset(sum2,0,sizeof sum2);&#125;inline void add(int x)&#123;++sum1[x],++sum2[bel[x]];&#125;inline int query(int l,int r)&#123;    int L=bel[l],R=bel[r],res=0;    if(L==R) for(re int i=l;i&lt;=r;++i) res+=sum1[i];    else&#123;        for(re int i=l;i&lt;=ed[L];++i) res+=sum1[i];        for(re int i=st[R];i&lt;=r;++i) res+=sum1[i];        for(re int i=L+1;i&lt;=R-1;++i) res+=sum2[i];    &#125;    return res;&#125;inline int find(int x)&#123;if(x!=fa[x]) fa[x]=find(fa[x]);return fa[x];&#125;inline void solve1(int id)&#123;    clear();    for(auto x:g[id])&#123;        if(q[x].op==1)&#123;            int pos=find(q[x].l);            while(pos&lt;=q[x].r)&#123;                for(auto v:s[pos]) add(v);                fa[pos]=fa[pos+1];                pos=find(pos+1);            &#125;        &#125;        else ans[q[x].id]=query(q[x].l,q[x].r);    &#125;&#125;inline void solve2(int id)&#123;    int top=0;    for(auto x:g[id])&#123;        if(q[x].op==1) stk[++top]=&#123;q[x].l,q[x].r&#125;;        else&#123;            if(!top) continue;            sort(stk+1,stk+top+1);            int nowl=stk[1].fi,nowr=stk[1].se;            for(re int i=2;i&lt;=top;++i)&#123;                if(stk[i].fi&lt;=nowr) nowr=max(nowr,stk[i].se);                else&#123;                    q1[q[x].l-1].push_back(&#123;-1,nowl,nowr,998244353,q[x].id&#125;);                    q1[q[x].r].push_back(&#123;1,nowl,nowr,998244353,q[x].id&#125;);\t                    nowl=stk[i].fi,nowr=stk[i].se;                &#125;            &#125;            q1[q[x].l-1].push_back(&#123;-1,nowl,nowr,998244353,q[x].id&#125;);            q1[q[x].r].push_back(&#123;1,nowl,nowr,998244353,q[x].id&#125;);\t        &#125;    &#125;&#125;inline void update(int x)&#123;    int id=bel[x];    for(re int i=id;i&lt;=tot;++i) ++cnt1[i];    for(re int i=idx[x];i&lt;=idx[ed[id]];++i) ++cnt2[id][i];&#125;inline int query1(int l,int r)&#123;    int L=bel[l],R=bel[r];    long long res=0;    if(L==R) res+=(cnt2[L][idx[r]]-cnt2[L][idx[l]-1]);    else&#123;        res+=(cnt2[L][idx[ed[L]]]-cnt2[L][idx[l]-1]);        res+=(cnt2[R][idx[r]]);        res+=(cnt1[R-1]-cnt1[L]);    &#125;    return res;&#125;inline void solve()&#123;    for(re int i=1;i&lt;=n;++i)&#123;        update(a[i]);        for(auto x:q1[i])&#123;            ans[x.id]+=x.op*query1(x.l,x.r);        &#125;    &#125;&#125;int tr[maxn];inline void add(int x,int val)&#123;while(x&lt;=n) tr[x]+=val,x+=lb(x);&#125;inline int query(int x)&#123;int res=0;while(x) res+=tr[x],x-=lb(x);return res;&#125;inline void solve0()&#123;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],b[i]=a[i],stk[i]=&#123;a[i],i&#125;;    sort(b+1,b+n+1);sort(stk+1,stk+n+1);    for(re int i=1;i&lt;=n+1;++i) fa[i]=i;    int op,l,r,k;    while(Q--)&#123;        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r&gt;&gt;k;        if(op==1)&#123;            l=lower_bound(b+1,b+n+1,l)-b,r=upper_bound(b+1,b+n+1,r)-b-1;            int pos=find(l);            while(pos&lt;=r)&#123;                add(stk[pos].se,1);                fa[pos]=fa[pos+1];                pos=find(pos+1);            &#125;        &#125;        else cout&lt;&lt;query(r)-query(l-1)&lt;&lt;&#x27;\\n&#x27;;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;Q&gt;&gt;m;    if(m==1)&#123;solve0();return 0;&#125;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];    for(re int i=1;i&lt;=Q;++i) cin&gt;&gt;q[i].op&gt;&gt;q[i].l&gt;&gt;q[i].r&gt;&gt;q[i].k,q[i].id=i,b[i]=q[i].k;    sort(b+1,b+Q+1);    m=unique(b+1,b+Q+1)-(b+1);    for(re int i=1;i&lt;=Q;++i) q[i].k=lower_bound(b+1,b+m+1,q[i].k)-b,g[q[i].k].push_back(i);    cnt=0;    for(re int i=1;i&lt;=n;++i) b[++cnt]=a[i];    for(re int i=1;i&lt;=Q;++i) if(q[i].op==1) b[++cnt]=q[i].l,b[++cnt]=q[i].r;    sort(b+1,b+cnt+1);    cnt=unique(b+1,b+cnt+1)-(b+1);    for(re int i=1;i&lt;=n;++i) a[i]=lower_bound(b+1,b+cnt+1,a[i])-b,s[a[i]].push_back(i);    for(re int i=1;i&lt;=Q;++i) if(q[i].op==1) q[i].l=lower_bound(b+1,b+cnt+1,q[i].l)-b,q[i].r=lower_bound(b+1,b+cnt+1,q[i].r)-b;    init();    for(re int i=1;i&lt;=m;++i)&#123;        if(g[i].size()&gt;=sqrt(Q)) solve1(i);        else solve2(i);    &#125;    solve();    for(re int i=1;i&lt;=Q;++i) if(q[i].op==2) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n序列分块套值域分块先来个简单问题：全局 kth。\n权值线段树很好维护对吧，线段树上二分即可。\n考虑值域分块怎么做。\n事实上是类似的。枚举整块，如果超了就枚举块内。\n复杂度 O(n\\sqrt n)\n那现在加强一下：区间 kth。\n【模板】可持久化线段树 2主席树可以做，那分块呢？\n在学值域分块前，我的第一想法是序列分块+二分。\n然而复杂度是 O(n\\sqrt n \\log n)\n能不能把 log 去掉呢？\n我们考虑序列分块套值域分块。\n这种值域类数据结构都有非常好的性质：单调性。\n我们先对序列分块，维护块内每个数的出现次数。\n然后对值域分块，维护每个序列块内每个值域块中数的出现次数。\n然后对序列块做上面两个信息的前缀和，这样就可以 O(1) 查询一段块内每个数的出现次数以及每个值域块中数的出现次数。\n这个预处理的复杂度是 O(n\\sqrt n) 的。\n查询时，我们先把散块里的元素放到一个桶里，再把值域块中的数放到一个桶里。\n然后跳值域块，超过 k 时就跳块内的数。\n复杂度 O(n\\sqrt n)\n代码实现里序列块和值域块共用了块长和所有编号，请分清哪个是序列块，哪个是值域块。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e5+10,maxm=500;int n,m,siz,tot;int a[maxn],b[maxn];int st[maxm],ed[maxm],bel[maxn];int cnt1[maxm][maxn],cnt2[maxm][maxm];int buc1[maxn],buc2[maxm];inline void init()&#123;    siz=sqrt(n);    tot=n/siz;    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;n) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=n;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i;&#125;inline void pre()&#123;    for(re int i=1;i&lt;=tot;++i)&#123;        for(re int j=1;j&lt;=n;++j) cnt1[i][j]=cnt1[i-1][j];        for(re int j=1;j&lt;=tot;++j) cnt2[i][j]=cnt2[i-1][j];        for(re int j=st[i];j&lt;=ed[i];++j) ++cnt1[i][a[j]],++cnt2[i][bel[a[j]]];    &#125;&#125;inline int query(int l,int r,int k)&#123;    int L=bel[l],R=bel[r],res=-1,tmp=0,id=0;    if(L==R)&#123;        for(re int i=l;i&lt;=r;++i) ++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=1;i&lt;=tot;++i)&#123;            tmp+=buc2[i];            if(tmp&gt;=k)&#123;                tmp-=buc2[i];                id=i;                break;            &#125;        &#125;        for(re int i=st[id];i&lt;=ed[id];++i)&#123;            tmp+=buc1[i];            if(tmp&gt;=k)&#123;                res=b[i];                break;            &#125;        &#125;        for(re int i=l;i&lt;=r;++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;    &#125;    else&#123;        for(re int i=l;i&lt;=ed[L];++i) ++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=st[R];i&lt;=r;++i) ++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=1;i&lt;=tot;++i)&#123;            tmp+=buc2[i]+cnt2[R-1][i]-cnt2[L][i];            if(tmp&gt;=k)&#123;                tmp-=buc2[i]+cnt2[R-1][i]-cnt2[L][i];                id=i;                break;            &#125;        &#125;        for(re int i=st[id];i&lt;=ed[id];++i)&#123;            tmp+=buc1[i]+cnt1[R-1][i]-cnt1[L][i];            if(tmp&gt;=k)&#123;                res=b[i];                break;            &#125;        &#125;        for(re int i=l;i&lt;=ed[L];++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;        for(re int i=st[R];i&lt;=r;++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;    &#125;    return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif\t    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],b[i]=a[i];    sort(b+1,b+n+1);    int len=unique(b+1,b+n+1)-(b+1);    for(re int i=1;i&lt;=n;++i) a[i]=lower_bound(b+1,b+len+1,a[i])-b;    init();    pre();    for(re int i=1,l,r,k;i&lt;=m;++i)&#123;        cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;        cout&lt;&lt;query(l,r,k)&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n那再加强一下：单点修。\nDynamic Rankings因为我们预处理的是前缀和，所以要更改 O(\\sqrt n) 的块。\n代码基本相同。\n但如果你还把两种块的编号并用，请注意元素个数可能会 > n。\n代码里的 n=cnt 就是解决这一情况的。\n#include&quot;bits/stdc++.h&quot;#define re register// #define int long longusing namespace std;const int maxn=2e5+10,maxm=500;int n,m,siz,tot,cnt;int a[maxn],b[maxn];int st[maxm],ed[maxm],bel[maxn];int cnt1[maxm][maxn],cnt2[maxm][maxm];int buc1[maxn],buc2[maxm];struct query&#123;    int op;    int l,r,k;    int x,y;&#125;q[maxn];inline void init()&#123;    n=cnt;    siz=sqrt(n);    tot=n/siz;    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;n) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=n;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i;&#125;inline void pre()&#123;    for(re int i=1;i&lt;=tot;++i)&#123;        for(re int j=1;j&lt;=n;++j) cnt1[i][j]=cnt1[i-1][j];        for(re int j=1;j&lt;=tot;++j) cnt2[i][j]=cnt2[i-1][j];        for(re int j=st[i];j&lt;=ed[i];++j) ++cnt1[i][a[j]],++cnt2[i][bel[a[j]]];    &#125;&#125;inline void modify(int x,int y)&#123;    int pos=bel[x];    for(re int i=pos;i&lt;=tot;++i)&#123;        --cnt1[i][a[x]];        --cnt2[i][bel[a[x]]];        ++cnt1[i][y];        ++cnt2[i][bel[y]];    &#125;    a[x]=y;&#125;inline int query(int l,int r,int k)&#123;    int L=bel[l],R=bel[r],res=-1,tmp=0,id=0;    if(L==R)&#123;        for(re int i=l;i&lt;=r;++i) ++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=1;i&lt;=tot;++i)&#123;            tmp+=buc2[i];            if(tmp&gt;=k)&#123;                tmp-=buc2[i];                id=i;                break;            &#125;        &#125;        for(re int i=st[id];i&lt;=ed[id];++i)&#123;            tmp+=buc1[i];            if(tmp&gt;=k)&#123;                res=b[i];                break;            &#125;        &#125;        for(re int i=l;i&lt;=r;++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;    &#125;    else&#123;        for(re int i=l;i&lt;=ed[L];++i) ++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=st[R];i&lt;=r;++i) ++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=1;i&lt;=tot;++i)&#123;            tmp+=buc2[i]+cnt2[R-1][i]-cnt2[L][i];            if(tmp&gt;=k)&#123;                tmp-=buc2[i]+cnt2[R-1][i]-cnt2[L][i];                id=i;                break;            &#125;        &#125;        for(re int i=st[id];i&lt;=ed[id];++i)&#123;            tmp+=buc1[i]+cnt1[R-1][i]-cnt1[L][i];            if(tmp&gt;=k)&#123;                res=b[i];                break;            &#125;        &#125;        for(re int i=l;i&lt;=ed[L];++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;        for(re int i=st[R];i&lt;=r;++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;    &#125;    return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif\t    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],b[++cnt]=a[i];    char op;    for(re int i=1;i&lt;=m;++i)&#123;        cin&gt;&gt;op;        if(op==&#x27;Q&#x27;) cin&gt;&gt;q[i].l&gt;&gt;q[i].r&gt;&gt;q[i].k,q[i].op=1;        else cin&gt;&gt;q[i].x&gt;&gt;q[i].y,q[i].op=2,b[++cnt]=q[i].y;    &#125;    sort(b+1,b+cnt+1);    cnt=unique(b+1,b+cnt+1)-(b+1);    for(re int i=1;i&lt;=n;++i) a[i]=lower_bound(b+1,b+cnt+1,a[i])-b;    init();    pre();    for(re int i=1;i&lt;=m;++i)&#123;        if(q[i].op==1) cout&lt;&lt;query(q[i].l,q[i].r,q[i].k)&lt;&lt;&#x27;\\n&#x27;;        else modify(q[i].x,lower_bound(b+1,b+cnt+1,q[i].y)-b);    &#125;    return 0;&#125;\n那再加强一下：区间修。\n[Ynoi2018] 未来日记望月悲叹的最初分块。\n每个序列块用并查集把所有值相同的缩在一起。然后维护 rt[i][x]，表示第 i 个块中某个值为 x 的数的位置。\n对于整块修改，如果 x 不存在，直接无视。\n否则，如果 y 不存在，那么就把 x 映射成 y。\n否则暴力重构。\n然后还要把我们维护的前缀和修改掉。\n因为是区间修，所以我们还得再记录一下每个序列块内每个数的出现次数，用于修改后面的前缀和。\n对于散块修改，直接暴力重构即可。\n具体的，我们把并查集的信息全部重新维护一遍，然后再把后面块的前缀和修改一下。\n感觉说的也不是很清楚？那放一下lxl的题解吧。\n实现参考了题解（我太菜了写不出来QWQ）。\n#include&quot;bits/stdc++.h&quot;#define re register// #define int long longusing namespace std;const int maxn=1e5+10,maxm=170;int n,m,siz,tot;int a[maxn];int st[maxm],ed[maxm],bel[maxn];int cnt1[maxm][maxn],cnt2[maxm][maxm],cnt3[maxm][maxn];int buc1[maxn],buc2[maxm];int fa[maxn],rt[maxm][maxn];int stk[maxn];inline int find(int x)&#123;if(x!=fa[x]) fa[x]=find(fa[x]);return fa[x];&#125;inline void init()&#123;    siz=600;    tot=n/siz;    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;n) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=n;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i;&#125;inline void pre()&#123;    for(re int i=1;i&lt;=tot;++i)&#123;        for(re int j=st[i];j&lt;=ed[i];++j)&#123;            if(!rt[i][a[j]]) rt[i][a[j]]=j;             else fa[j]=rt[i][a[j]];        &#125;        for(re int j=1;j&lt;=n;++j) cnt1[i][j]=cnt1[i-1][j];        for(re int j=1;j&lt;=tot;++j) cnt2[i][j]=cnt2[i-1][j];        for(re int j=st[i];j&lt;=ed[i];++j) ++cnt1[i][a[j]],++cnt2[i][bel[a[j]]],++cnt3[i][a[j]];    &#125;&#125;inline void update(int p,int l,int r,int x,int y)&#123;    int tmp=0,top=0,L=st[p],R=ed[p];    rt[p][x]=rt[p][y]=0;    for(re int i=L;i&lt;=R;++i)&#123;        a[i]=a[find(i)];        if(a[i]==x||a[i]==y) stk[++top]=i;    &#125;    for(re int i=l;i&lt;=r;++i) if(a[i]==x) a[i]=y,++tmp;    for(re int i=1;i&lt;=top;++i) fa[stk[i]]=stk[i];    for(re int i=1;i&lt;=top;++i)&#123;        if(!rt[p][a[stk[i]]]) rt[p][a[stk[i]]]=stk[i];        else fa[stk[i]]=rt[p][a[stk[i]]];    &#125;    cnt3[p][x]-=tmp,cnt3[p][y]+=tmp;    for(re int i=p;i&lt;=tot;++i)&#123;        cnt1[i][x]-=tmp,cnt1[i][y]+=tmp;        if(bel[x]!=bel[y]) cnt2[i][bel[x]]-=tmp,cnt2[i][bel[y]]+=tmp;    &#125;&#125;inline void modify(int l,int r,int x,int y)&#123;    if(x==y) return;    int L=bel[l],R=bel[r];    if(L==R) update(L,l,r,x,y);    else&#123;        update(L,l,ed[L],x,y),update(R,st[R],r,x,y);        int tmp1=0,tmp2=0;        for(re int i=L+1;i&lt;=R-1;++i)&#123;            if(rt[i][x])&#123;                if(!rt[i][y]) rt[i][y]=rt[i][x],a[rt[i][x]]=y;                else fa[rt[i][x]]=rt[i][y];                rt[i][x]=0;                tmp1=cnt3[i][x],tmp2+=tmp1;                cnt3[i][y]+=tmp1,cnt3[i][x]=0;            &#125;            cnt1[i][x]-=tmp2,cnt1[i][y]+=tmp2;            if(bel[x]!=bel[y]) cnt2[i][bel[x]]-=tmp2,cnt2[i][bel[y]]+=tmp2;        &#125;        for(re int i=R;i&lt;=tot;++i)&#123;            cnt1[i][x]-=tmp2,cnt1[i][y]+=tmp2;            if(bel[x]!=bel[y]) cnt2[i][bel[x]]-=tmp2,cnt2[i][bel[y]]+=tmp2;        &#125;    &#125;&#125;inline int query(int l,int r,int k)&#123;    int L=bel[l],R=bel[r],res=-1,tmp=0,id=0;    if(L==R)&#123;        for(re int i=l;i&lt;=r;++i) a[i]=a[find(i)],++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=1;i&lt;=tot;++i)&#123;            tmp+=buc2[i];            if(tmp&gt;=k)&#123;                tmp-=buc2[i];                id=i;                break;            &#125;        &#125;        for(re int i=st[id];i&lt;=ed[id];++i)&#123;            tmp+=buc1[i];            if(tmp&gt;=k)&#123;                res=i;                break;            &#125;        &#125;        for(re int i=l;i&lt;=r;++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;    &#125;    else&#123;        for(re int i=l;i&lt;=ed[L];++i) a[i]=a[find(i)],++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=st[R];i&lt;=r;++i) a[i]=a[find(i)],++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=1;i&lt;=tot;++i)&#123;            tmp+=buc2[i]+cnt2[R-1][i]-cnt2[L][i];            if(tmp&gt;=k)&#123;                tmp-=buc2[i]+cnt2[R-1][i]-cnt2[L][i];                id=i;                break;            &#125;        &#125;        for(re int i=st[id];i&lt;=ed[id];++i)&#123;            tmp+=buc1[i]+cnt1[R-1][i]-cnt1[L][i];            if(tmp&gt;=k)&#123;                res=i;                break;            &#125;        &#125;        for(re int i=l;i&lt;=ed[L];++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;        for(re int i=st[R];i&lt;=r;++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;    &#125;    return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif\t    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],fa[i]=i;    init();    pre();    for(re int i=1,op,l,r,x,y,k;i&lt;=m;++i)&#123;        cin&gt;&gt;op;        if(op==1) cin&gt;&gt;l&gt;&gt;r&gt;&gt;x&gt;&gt;y,modify(l,r,x,y);        else cin&gt;&gt;l&gt;&gt;r&gt;&gt;k,cout&lt;&lt;query(l,r,k)&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n事实上这东西和主席树很像，都是维护前缀信息，然后通过差分求区间信息。\n一般来说，我们都会维护前缀序列块的某个值域块的前缀和，这样可以方便修改。\n有时候，我们还会维护前缀序列块的前缀值域块的前缀和。\n例如[ABC339G] Smaller Sum，我们维护前缀序列块的前缀值域块的前缀和。\n在序列上，我们把询问差分成 [1,r]-[1,l-1]，然后因为我们还维护了前缀值域块的前缀和，所以 \\le x 的和也直接求出来了。\n倍增值域分块倍增值域分块，就是把值域分成 [b^k,b^{k+1}) 的形式，一般取 b=2。\n通常用来解决 a_i\\ge x,a_i\\leftarrow a_i-x 的操作。\n常见做法是每块建一颗线段树维护。\nPhoenix and Diamonds *3400考虑倍增值域分块。\n我们把值域按 [2^k,2^{k+1}) 分块。\n设 c 当前在的块是 [2^k,2^{k+1})，那么 w_i 有三种情况：w_i < 2^k，w_i \\in [2^k,2^{k+1})，w_i \\ge 2^{k+1}。\n最后一种情况显然不需要考虑。\n如果选了第二种情况，那么 c 就会向下掉一层。\n如果选了第一种情况，那么也有两种情况：一直选，然后掉到下一层；或者直接选完。\n考虑对每一块开一颗线段树维护。\n线段树上维护 w_i < 2^k 的 \\sum w_i 和 \\sum v_i，以及选一个 w_i \\in [2^k,2^{k+1}) 所需的 c 的最小值（别忘了拿 [2^k,2^{k+1}) 的条件是先把前面拿完）。\n查询就是线段树上二分。\n还有另一种写法，不过差不多。\n线段树上每个节点维护所有块信息，维护的东西不变。\n设 sw_k=\\sum_{w_i < 2^k} w_i,sv_k=\\sum_{w_i < 2^k} v_i，mn 为上文提到的 c 的最小值。\n那么查询时，如果 c\\ge sw_k，那么说明小物品都能拿，那么直接返回 sw_k。\n如果 sw_{k-1}\\le c < mn_{k-1}，说明比 c 所在层的下一层还要小的物品可以全拿（拿完以后可能掉下去也可能不掉下去），但是下一层的物品一个也拿不了，那么直接返回 sw_{k-1}。\n否则向两边递归。可以证明复杂度为 O(\\log V)。\n感性理解就是每次递归都至少往下走一层，最多走 O(\\log V) 层。\n复杂度 O(n\\log n \\log V)\n实现时，查询里要实时维护当前在哪一层。\n代码实现了第二种（感觉线段树上二分不太好写）\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e5+10,maxv=20,inf=2e18;int n,m,c,rt,segcnt,now;int seq[maxn],id[maxn];struct node&#123;    int num,w,v,id;&#125;a[maxn];struct node1&#123;    int sw,sv,tot;&#125;;struct tree&#123;    int ls,rs;    node1 s[maxv];&#125;tr[maxn&lt;&lt;1];inline bool cmp(int x,int y)&#123;    if(a[x].v==a[y].v) return a[x].w&lt;a[y].w;    return a[x].v&gt;a[y].v;&#125;inline void up(int p)&#123;    for(re int i=1;i&lt;=18;++i)&#123;        tr[p].s[i].sw=tr[tr[p].ls].s[i].sw+tr[tr[p].rs].s[i].sw;        tr[p].s[i].sv=tr[tr[p].ls].s[i].sv+tr[tr[p].rs].s[i].sv;        tr[p].s[i].tot=min(tr[tr[p].ls].s[i].tot,tr[tr[p].ls].s[i].sw+tr[tr[p].rs].s[i].tot);    &#125;&#125;inline void init(int p,int pos)&#123;    for(re int i=1;i&lt;=18;++i)&#123;        tr[p].s[i].sw=tr[p].s[i].sv=0,tr[p].s[i].tot=inf;        if(a[pos].w&lt;(1&lt;&lt;(i-1))) tr[p].s[i].sw=a[pos].w*a[pos].num,tr[p].s[i].sv=a[pos].v*a[pos].num;        else if(a[pos].w&lt;(1&lt;&lt;i)&amp;&amp;a[pos].num) tr[p].s[i].tot=a[pos].w;     &#125;&#125;inline void build(int l,int r,int &amp;p)&#123;    if(!p) p=++segcnt;    if(l==r)&#123;init(p,id[l]);return;&#125;    int mid=(l+r)&gt;&gt;1;    build(l,mid,tr[p].ls),build(mid+1,r,tr[p].rs);    up(p);&#125;inline void update(int l,int r,int pos,int p)&#123;    if(l==r)&#123;init(p,id[pos]);return;&#125;    int mid=(l+r)&gt;&gt;1;    if(pos&lt;=mid) update(l,mid,pos,tr[p].ls);    else update(mid+1,r,pos,tr[p].rs);    up(p);&#125;inline void calc()&#123;while(now&gt;1&amp;&amp;(1&lt;&lt;((now-1)-1))&gt;c) --now;&#125;inline int query(int l,int r,int p)&#123;    if(l==r)&#123;        int num=min(a[id[l]].num,c/a[id[l]].w);        c-=num*a[id[l]].w;calc();        return num*a[id[l]].v;    &#125;    if(c&gt;=tr[p].s[now].sw)&#123;int tmp=tr[p].s[now].sv;c-=tr[p].s[now].sw,calc();return tmp;&#125;    else if(c&gt;=tr[p].s[now-1].sw&amp;&amp;c&lt;tr[p].s[now-1].tot)&#123;int tmp=tr[p].s[now-1].sv;c-=tr[p].s[now-1].sw,calc();return tmp;&#125;    else&#123;        int mid=(l+r)&gt;&gt;1;        return query(l,mid,tr[p].ls)+query(mid+1,r,tr[p].rs);    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i].num&gt;&gt;a[i].w&gt;&gt;a[i].v,id[i]=i;    sort(id+1,id+n+1,cmp);    for(re int i=1;i&lt;=n;++i) seq[id[i]]=i;    build(1,n,rt);    while(m--)&#123;        int op,num,pos;        cin&gt;&gt;op;        if(op==3)&#123;            cin&gt;&gt;c;now=18;calc();            cout&lt;&lt;query(1,n,1)&lt;&lt;&#x27;\\n&#x27;;        &#125;        else&#123;            cin&gt;&gt;num&gt;&gt;pos;            if(op==1) a[pos].num+=num;            else a[pos].num-=num;            update(1,n,seq[pos],1);        &#125;    &#125;    return 0;&#125;\n[Ynoi2007] rgxsxrs摆\n[Ynoi Easy Round 2022] 堕天作战 TEST_98摆\n","categories":["学习笔记"],"tags":["数据结构","莫队","分块"]},{"title":"圆方树学习笔记","url":"/posts/218474d4/","content":"经常见到圆方树，但一直不会，正好在复习连通性，顺便学一下。\n但我学的是广义圆方树，所以下文都是有关广义圆方树的介绍。\n定义及构建在圆方树中，原图的每个点对应一个圆点，每个点双对应一个方点。\n在一个联通分量内，对于每个点双，我们把它对应的方点和在其内的所有点对应的圆点连边，会得到一棵树。\n这棵树就叫圆方树。\n如果图由若干个联通分量构成，则会形成圆方树森林。\n特殊的，对于孤点应该特殊处理（然而我的处理就是不管它但一直没错过）。\n以下是对给定无向图建圆方树的一个图示：\n\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e5+10,maxm=5e5+10;int n,m,cnt,tim,top,tot;int head[maxn];int dfn[maxn],low[maxn];int stk[maxn];struct edge&#123;    int to,nxt;&#125;e[maxm&lt;&lt;1];vector&lt;int&gt; g[maxn&lt;&lt;1];inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u,int fa)&#123;    dfn[u]=low[u]=++tim;    stk[++top]=u;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            tarjan(v,u);            low[u]=min(low[u],low[v]);            if(low[v]&gt;=dfn[u])&#123;                ++tot;                int x;                do&#123;                    x=stk[top--];                    g[tot].push_back(x),g[x].push_back(tot);                &#125;while(x!=v);                g[tot].push_back(u),g[u].push_back(tot);            &#125;        &#125;        else if(v!=fa) low[u]=min(low[u],dfn[v]);    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;tot=n;    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    for(re int i=1;i&lt;=n;++i) if(!dfn[i]) tarjan(i,i);    return 0;&#125;\n性质\n圆方树的点数会达到 2n 级别，所以数组别开小。\n树上圆点仅会和方点相连，方点仅会和圆点相连。\n\n度数大于 1 的圆点在原图中一定是割点。\n\n\n例题道路相遇双倍经验：Traffic Real Time Query System\n结论：两个点之间必经点个数=圆方树上对应圆点路径上圆点数。\n这里的必经点包含这两个点。\n所以建出圆方树后树剖维护即可。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=5e5+10,maxm=1e6+10;int n,m,Q,cnt,tim,top,tot,id,rt,segcnt;int head[maxn];int dfn[maxn],low[maxn];int stk[maxn];struct edge&#123;    int to,nxt;&#125;e[maxm&lt;&lt;1];struct node&#123;    int fa,siz,top,hson,dep,dfn,seq;&#125;t[maxn&lt;&lt;1];struct tree&#123;    int ls,rs,sum;&#125;tr[maxn&lt;&lt;2];vector&lt;int&gt; g[maxn&lt;&lt;1];inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u,int fa)&#123;    dfn[u]=low[u]=++tim;    stk[++top]=u;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            tarjan(v,u);            low[u]=min(low[u],low[v]);            if(low[v]&gt;=dfn[u])&#123;                ++tot;                int x;                do&#123;                    x=stk[top--];                    g[tot].push_back(x),g[x].push_back(tot);                &#125;while(x!=v);                g[tot].push_back(u),g[u].push_back(tot);            &#125;        &#125;        else if(v!=fa) low[u]=min(low[u],dfn[v]);    &#125;&#125;inline void dfs1(int u,int fa)&#123;    t[u].fa=fa;    t[u].siz=1;    t[u].dep=t[fa].dep+1;    for(auto v:g[u])&#123;        if(v==fa) continue;        dfs1(v,u);        t[u].siz+=t[v].siz;        if(!t[u].hson||t[v].siz&gt;t[t[u].hson].siz) t[u].hson=v;    &#125;&#125;inline void dfs2(int u,int top)&#123;    t[u].dfn=++id;    t[id].seq=u;    t[u].top=top;    if(!t[u].hson) return;    dfs2(t[u].hson,top);    for(auto v:g[u])&#123;        if(v==t[u].hson||v==t[u].fa) continue;        dfs2(v,v);    &#125;&#125;inline void up(int p)&#123;tr[p].sum=tr[tr[p].ls].sum+tr[tr[p].rs].sum;&#125;inline void build(int l,int r,int &amp;p)&#123;    if(!p) p=++segcnt;    if(l==r)&#123;tr[p].sum=(t[l].seq&lt;=n);return;&#125;    int mid=(l+r)&gt;&gt;1;    build(l,mid,tr[p].ls),build(mid+1,r,tr[p].rs);    up(p);&#125;inline int query(int l,int r,int L,int R,int p)&#123;    if(l&gt;=L&amp;&amp;r&lt;=R) return tr[p].sum;    int mid=(l+r)&gt;&gt;1,res=0;    if(L&lt;=mid) res+=query(l,mid,L,R,tr[p].ls);    if(R&gt;mid) res+=query(mid+1,r,L,R,tr[p].rs);    return res;&#125;inline int query(int u,int v)&#123;    int res=0;    while(t[u].top!=t[v].top)&#123;        if(t[t[u].top].dep&lt;t[t[v].top].dep) swap(u,v);        res+=query(1,tot,t[t[u].top].dfn,t[u].dfn,1);        u=t[t[u].top].fa;    &#125;    if(t[u].dep&gt;t[v].dep) swap(u,v);    res+=query(1,tot,t[u].dfn,t[v].dfn,1);    return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;tot=n;    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    tarjan(1,0),dfs1(1,0),dfs2(1,1),build(1,tot,rt);    cin&gt;&gt;Q;    while(Q--)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        cout&lt;&lt;query(u,v)&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n[SDOI2018] 战略游戏双倍经验：国土规划\n上一题的加强版。\n这次从两个点变成若干点了，但保证了总和，所以想到虚树。\n将每次询问点拎出来建虚树，建完后可以发现：虚树上所有是非询问点的圆点（包括建虚树需要用到的关键点和虚树的边上经过的那些非关键点）都合法。\n为了方便，我把 1 也强制加到虚树了，但 1 不一定能产生贡献，所以必须特判。\n注意：树剖的重儿子数组要清空！\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e5+10;int n,m,Q,cnt;int top,tim,tot;int id;int ans,num,len;int head[maxn];int dfn[maxn],low[maxn],stk[maxn];int a[maxn],b[maxn&lt;&lt;1];int sum[maxn&lt;&lt;1];bitset&lt;maxn&gt; vis;vector&lt;int&gt; g[maxn&lt;&lt;1];struct node&#123;    int fa,dfn,top,hson,siz,dep;&#125;t[maxn&lt;&lt;1];struct edge&#123;    int to,nxt;&#125;e[maxn&lt;&lt;1];inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u,int fa)&#123;    dfn[u]=low[u]=++tim;    stk[++top]=u;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            tarjan(v,u);            low[u]=min(low[u],low[v]);            if(low[v]&gt;=dfn[u])&#123;                ++tot;                g[tot].push_back(u),g[u].push_back(tot);                int x;                do&#123;                    x=stk[top--];                    g[tot].push_back(x),g[x].push_back(tot);                &#125;while(x!=v);            &#125;        &#125; else if(v!=fa) low[u]=min(low[u],dfn[v]);    &#125;&#125;inline void dfs1(int u,int fa)&#123;    t[u].fa=fa;    t[u].siz=1;    t[u].dep=t[fa].dep+1;    sum[u]=sum[fa]+(u&lt;=n);    for(auto v:g[u])&#123;        if(v==fa) continue;        dfs1(v,u);        t[u].siz+=t[v].siz;        if(!t[u].hson||t[v].siz&gt;t[t[u].hson].siz) t[u].hson=v;    &#125;&#125;inline void dfs2(int u,int top)&#123;    t[u].top=top;    t[u].dfn=++id;    if(!t[u].hson) return;    dfs2(t[u].hson,top);    for(auto v:g[u])&#123;        if(v==t[u].hson||v==t[u].fa) continue;        dfs2(v,v);    &#125;&#125;inline int lca(int u,int v)&#123;    while(t[u].top!=t[v].top)&#123;        if(t[t[u].top].dep&lt;t[t[v].top].dep) swap(u,v);        u=t[t[u].top].fa;    &#125;    return t[u].dep&lt;t[v].dep?u:v;&#125;inline bool cmp(int a,int b)&#123;return t[a].dfn&lt;t[b].dfn;&#125;inline void build()&#123;    len=0;    sort(a+1,a+num+1,cmp);    for(re int i=1;i&lt;num;++i)&#123;        b[++len]=a[i];        b[++len]=lca(a[i],a[i+1]);    &#125;    b[++len]=a[num];    b[++len]=1;    sort(b+1,b+len+1,cmp);    len=unique(b+1,b+len+1)-(b+1);    for(re int i=1,lc;i&lt;len;++i)&#123;        lc=lca(b[i],b[i+1]);        g[lc].push_back(b[i+1]),g[b[i+1]].push_back(lc);    &#125;&#125;inline void dfs3(int u,int fa)&#123;    for(auto v:g[u])&#123;        if(v==fa) continue;        ans+=(sum[v]-sum[u]-(v&lt;=n));        dfs3(v,u);    &#125;    if(!vis[u]&amp;&amp;u&lt;=n&amp;&amp;(u!=1||g[u].size()!=1)) ++ans;    if(!vis[u]&amp;&amp;u==1&amp;&amp;g[u].size()==1) ans-=(sum[g[u][0]]-sum[u]-(g[u][0]&lt;=n));    g[u].clear();&#125;inline void clear()&#123;    tot=n;    cnt=tim=top=id=0;    for(re int i=1;i&lt;=n;++i) head[i]=0,dfn[i]=0,low[i]=0;&#125;inline void solve()&#123;    cin&gt;&gt;n&gt;&gt;m;clear();    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    tarjan(1,0),dfs1(1,0),dfs2(1,1);    for(re int i=1;i&lt;=tot;++i) g[i].clear();    cin&gt;&gt;Q;    while(Q--)&#123;        cin&gt;&gt;num;ans=0;        for(re int i=1;i&lt;=num;++i) cin&gt;&gt;a[i],vis[a[i]]=1;        build(),dfs3(1,0);        cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;        for(re int i=1;i&lt;=num;++i) vis[a[i]]=0;    &#125;    for(re int i=1;i&lt;=tot;++i)&#123;        sum[i]=0;        t[i].hson=0;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    int T;cin&gt;&gt;T;while(T--) solve();    return 0;&#125;\n[DBOI2019] 巫女的职责综合版：EntropyIncreaser 与 动态图，动态维护割边割点。\n动态维护割点，考虑 LCT 维护圆方树。\n如果不考虑加边，那么单点修改和链查询链推平都是 LCT 基础操作。\n然后考虑加边。\n事实上，只需要在连边前，判断这两个点是否连通，如果已经连通了，那连上这条边就会产生一个环，也就是点双，给路径上的边全部断开然后暴力重构圆方树即可。\n复杂度是对的，因为每个点最多只会被合并一次，而每次复杂度都是 O(\\log n) 的。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define ls(x) tr[x].ch[0]#define rs(x) tr[x].ch[1]#define fa(x) tr[x].fa#define get(x) (rs(fa(x))==x)#define isroot(x) (ls(fa(x))!=x&amp;&amp;rs(fa(x))!=x)using namespace std;const int maxn=1e6+10;int n,m,tot,lastans,top;int stk[maxn];struct node&#123;    int w,fa,ch[2],tag,siz,add,sum;&#125;tr[maxn];inline void up(int x)&#123;    tr[x].sum=tr[ls(x)].sum+tr[rs(x)].sum+tr[x].w;    tr[x].siz=tr[ls(x)].siz+tr[rs(x)].siz+(x&lt;=n);&#125;inline void upadd(int x)&#123;    tr[x].sum=tr[x].w=0;    tr[x].add=1;&#125;inline void rev(int x)&#123;swap(ls(x),rs(x));tr[x].tag^=1;&#125;inline void down(int x)&#123;    if(tr[x].add)&#123;        upadd(ls(x));        upadd(rs(x));        tr[x].add=0;    &#125;    if(tr[x].tag)&#123;        rev(ls(x)),rev(rs(x));        tr[x].tag=0;    &#125;&#125;inline void update(int x)&#123;if(!isroot(x))&#123;update(fa(x));&#125;down(x);&#125;inline void rotate(int x)&#123;    int y=fa(x),z=fa(y),t=get(x);    if(!isroot(y)) tr[z].ch[get(y)]=x;    fa(tr[x].ch[t^1])=y,tr[y].ch[t]=tr[x].ch[t^1];    tr[x].ch[t^1]=y;    fa(y)=x,fa(x)=z;    up(y),up(x);&#125;inline void splay(int x)&#123;    update(x);    for(re int f=fa(x);f=fa(x),!isroot(x);rotate(x))&#123;        if(!isroot(f)) rotate(get(f)==get(x)?f:x);    &#125;&#125;inline void access(int x)&#123;for(re int p=0;x;p=x,x=fa(x))&#123;splay(x),rs(x)=p,up(x);&#125;&#125;inline void makeroot(int x)&#123;access(x),splay(x),rev(x);&#125;inline int find(int x)&#123;    access(x),splay(x);    while(ls(x)) x=ls(x),down(x);    splay(x);    return x;&#125;inline void split(int x,int y)&#123;makeroot(x),access(y),splay(y);&#125;inline void link(int x,int y)&#123;makeroot(x);if(find(y)!=x) fa(x)=y;&#125;inline void cut(int x,int y)&#123;makeroot(x);if(find(y)==x&amp;&amp;fa(y)==x&amp;&amp;!ls(y)) fa(y)=rs(x)=0;&#125;inline const void decode(int &amp;x)&#123;x^=lastans%n;if(x&gt;n)x%=n;if(!x)x=1;&#125;inline int query(int x,int y)&#123;    if(find(x)!=find(y)) return 0;    split(x,y);    int res=tr[y].sum;    upadd(y);    return res;&#125;inline void dfs(int u)&#123;    if(!u) return;down(u);    dfs(ls(u));    stk[++top]=u;    dfs(rs(u));&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;tot=n;    int op,x,y;    while(m--)&#123;        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;        decode(x),decode(y);        if(op==1)&#123;            if(find(x)==find(y))&#123;                split(x,y);                if(tr[y].siz&lt;=2) continue;                top=0;dfs(y);++tot;                for(re int i=1;i&lt;top;++i) cut(stk[i],stk[i+1]);                for(re int i=1;i&lt;=top;++i) link(stk[i],tot);            &#125;            else link(x,y);        &#125;        if(op==2) splay(x),tr[x].w+=y;        if(op==3)&#123;            lastans=query(x,y);            cout&lt;&lt;lastans&lt;&lt;&#x27;\\n&#x27;;        &#125;    &#125;    return 0;&#125;\n综合版代码\n#include&quot;bits/stdc++.h&quot;#define re register#define ls(x) tr[x].ch[0]#define rs(x) tr[x].ch[1]#define fa(x) tr[x].fa#define get(x) (rs(fa(x))==x)#define isroot(x) (ls(fa(x))!=x&amp;&amp;rs(fa(x))!=x)using namespace std;const int maxn=2e5+10;int n,m,lastans,tot;namespace LCT1&#123;    int tot;    struct node&#123;        int w,fa,ch[2],tag,add,sum;    &#125;tr[maxn];    inline void up(int x)&#123;tr[x].sum=tr[ls(x)].sum+tr[rs(x)].sum+tr[x].w;&#125;    inline void upadd(int x)&#123;        tr[x].sum=tr[x].w=0;        tr[x].add=1;    &#125;    inline void rev(int x)&#123;swap(ls(x),rs(x));tr[x].tag^=1;&#125;    inline void down(int x)&#123;        if(tr[x].add)&#123;            upadd(ls(x)),upadd(rs(x));            tr[x].add=0;        &#125;        if(tr[x].tag)&#123;            rev(ls(x)),rev(rs(x));            tr[x].tag=0;        &#125;    &#125;    inline void update(int x)&#123;if(!isroot(x))&#123;update(fa(x));&#125;down(x);&#125;    inline void rotate(int x)&#123;        int y=fa(x),z=fa(y),t=get(x);        if(!isroot(y)) tr[z].ch[get(y)]=x;        fa(tr[x].ch[t^1])=y,tr[y].ch[t]=tr[x].ch[t^1];        tr[x].ch[t^1]=y;        fa(y)=x,fa(x)=z;        up(y),up(x);    &#125;    inline void splay(int x)&#123;        update(x);        for(re int f=fa(x);f=fa(x),!isroot(x);rotate(x))&#123;            if(!isroot(f)) rotate(get(f)==get(x)?f:x);        &#125;    &#125;    inline void access(int x)&#123;for(re int p=0;x;p=x,x=fa(x))&#123;splay(x),rs(x)=p,up(x);&#125;&#125;    inline void makeroot(int x)&#123;access(x),splay(x),rev(x);&#125;    inline int find(int x)&#123;        access(x),splay(x);        while(ls(x)) x=ls(x),down(x);        splay(x);        return x;    &#125;    inline void split(int x,int y)&#123;makeroot(x),access(y),splay(y);&#125;    inline void link(int x,int y)&#123;makeroot(x);if(find(y)!=x) fa(x)=y;&#125;    inline void cut(int x,int y)&#123;makeroot(x);if(find(y)==x&amp;&amp;fa(y)==x&amp;&amp;!ls(y)) fa(y)=rs(x)=0;&#125;    inline int query(int x,int y)&#123;        if(find(x)!=find(y)) return -1;        split(x,y);        return tr[y].sum;    &#125;    inline void link1(int x,int y)&#123;        int u=find(x),v=find(y);        if(u==v) split(x,y),upadd(y);        else ++tot,tr[tot].w=1,link(x,tot),link(tot,y);    &#125;&#125;namespace LCT2&#123;    int tot,top;    int stk[maxn];    struct node&#123;        int fa,ch[2],tag,siz;    &#125;tr[maxn];    inline void up(int x)&#123;tr[x].siz=tr[ls(x)].siz+tr[rs(x)].siz+(x&lt;=n);&#125;    inline void rev(int x)&#123;swap(ls(x),rs(x));tr[x].tag^=1;&#125;    inline void down(int x)&#123;if(tr[x].tag) rev(ls(x)),rev(rs(x));tr[x].tag=0;&#125;    inline void update(int x)&#123;if(!isroot(x))&#123;update(fa(x));&#125;down(x);&#125;    inline void rotate(int x)&#123;        int y=fa(x),z=fa(y),t=get(x);        if(!isroot(y)) tr[z].ch[get(y)]=x;        fa(tr[x].ch[t^1])=y,tr[y].ch[t]=tr[x].ch[t^1];        tr[x].ch[t^1]=y;        fa(y)=x,fa(x)=z;        up(y),up(x);    &#125;    inline void splay(int x)&#123;        update(x);        for(re int f=fa(x);f=fa(x),!isroot(x);rotate(x))&#123;            if(!isroot(f)) rotate(get(f)==get(x)?f:x);        &#125;    &#125;    inline void access(int x)&#123;for(re int p=0;x;p=x,x=fa(x))&#123;splay(x),rs(x)=p,up(x);&#125;&#125;    inline void makeroot(int x)&#123;access(x),splay(x),rev(x);&#125;    inline int find(int x)&#123;        access(x),splay(x);        while(ls(x)) x=ls(x),down(x);        splay(x);        return x;    &#125;    inline void split(int x,int y)&#123;makeroot(x),access(y),splay(y);&#125;    inline void link(int x,int y)&#123;makeroot(x);if(find(y)!=x) fa(x)=y;&#125;    inline void cut(int x,int y)&#123;makeroot(x);if(find(y)==x&amp;&amp;fa(y)==x&amp;&amp;!ls(y)) fa(y)=rs(x)=0;&#125;    inline int query(int x,int y)&#123;        if(find(x)!=find(y)) return -1;        split(x,y);        return tr[y].siz;    &#125;    inline void dfs(int u)&#123;        if(!u) return;down(u);        dfs(ls(u));        stk[++top]=u;        dfs(rs(u));    &#125;    inline void link1(int x,int y)&#123;        if(find(x)==find(y))&#123;            split(x,y);            if(tr[y].siz&lt;=2) return;            top=0;dfs(y);++tot;            for(re int i=1;i&lt;top;++i) cut(stk[i],stk[i+1]);            for(re int i=1;i&lt;=top;++i) link(stk[i],tot);        &#125;        else link(x,y);    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;LCT1::tot=LCT2::tot=n;    int op,x,y,ans;    while(m--)&#123;        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;x^=lastans,y^=lastans;        if(op==1) LCT1::link1(x,y),LCT2::link1(x,y);        if(op==2) ans=LCT1::query(x,y),lastans=(ans==-1?lastans:ans),cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;        if(op==3) ans=LCT2::query(x,y),lastans=(ans==-1?lastans:ans),cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n[APIO2018] 铁人两项关于点双有一个很好的性质：对于一个点双中的两点，它们之间简单路径的并集，恰好完全等于这个点双。\n证明略，因为不会。\n那么放到圆方树上，就有结论：两圆点在圆方树上的路径，与路径上经过的方点相邻的圆点的集合，就等于原图中两点简单路径上的点集。\n那么在本题中，如果固定 s,f，那么合法的 c 的个数就等于 s,f 之间简单路径的并集的点数减 2（去掉 s,f 本身）。\n那么，我们给方点赋上对应点双大小的权值，给圆点赋上 -1 的权值。\n答案就是任意两个圆点之间路径的权值和。\n套路的，考虑每个点被计算的次数。\n考虑每个点 u 作为 c 时的贡献。\n若 s,f 都在其子树内，则贡献为\n\n\\sum_{v \\in sub_u} 2\\times siz_v\\times (siz_u-siz_v)\\times w_u若 s,f 只有一个在其子树内，则贡献为\n\n2\\times siz_u \\times (now-siz_u)\\times w_u其中 now 为当前连通块内圆点个数。\n乘 2 是因为题目要求统计有序对。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e5+10,maxm=2e5+10;int n,m,cnt,top,tim,tot,ans,now;int head[maxn];int dfn[maxn],low[maxn];int stk[maxn];int siz[maxn&lt;&lt;1],w[maxn&lt;&lt;1];vector&lt;int&gt; g[maxn&lt;&lt;1];struct edge&#123;    int to,nxt;&#125;e[maxm&lt;&lt;1];inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u,int fa)&#123;    ++now;    dfn[u]=low[u]=++tim;    stk[++top]=u;w[u]=-1;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            tarjan(v,u);            low[u]=min(low[u],low[v]);            if(low[v]&gt;=dfn[u])&#123;                g[++tot].push_back(u),g[u].push_back(tot),++w[tot];                int x;                do&#123;                    x=stk[top--];                    g[tot].push_back(x),g[x].push_back(tot),++w[tot];                &#125;while(x!=v);            &#125;        &#125;        else if(v!=fa) low[u]=min(low[u],dfn[v]);    &#125;&#125;inline void dfs(int u,int fa)&#123;    siz[u]=(u&lt;=n);    for(auto v:g[u])&#123;        if(v==fa) continue;        dfs(v,u);        siz[u]+=siz[v];        ans+=2ll*(siz[u]-siz[v])*siz[v]*w[u];    &#125;    ans+=2ll*siz[u]*(now-siz[u])*w[u];&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;tot=n;    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    for(re int i=1;i&lt;=n;++i) if(!dfn[i]) now=0,tarjan(i,i),dfs(i,0);    cout&lt;&lt;ans;    return 0;&#125;\nTourists如果不带修，那么给方点赋上对应点双内所有点的权值最小值，圆点赋对应点权值，查询就是链上最小值。\n然后考虑带修。一个想法是给每个方点维护一个 multiset，修改时要修改对应点点权和相连方点点权。\n但这样做给个菊花就卡死了。\n不过我们可以这样做：令每个方点的权值为其儿子中的最小权值，且 multiset 只维护其儿子的点权。\n这样修改时只需要额外修改父亲即可。\n询问时正常询问，但如果询问的两个点的 lca 是一个方点，那还要额外统计 lca 的父亲的贡献。\n卡常，需要加快读。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define ls(p) tr[p].ls#define rs(p) tr[p].rsusing namespace std;const int maxn=5e5+10,inf=1e18;int n,m,Q,cnt,tim,top,tot,rt,segcnt,id;int a[maxn],head[maxn];int dfn[maxn],low[maxn],stk[maxn];vector&lt;int&gt; g[maxn&lt;&lt;1];multiset&lt;int&gt; s[maxn];struct edge&#123;    int to,nxt;&#125;e[maxn&lt;&lt;1];struct node&#123;    int fa,dep,siz,hson,top,dfn,seq;&#125;t[maxn&lt;&lt;1];struct tree&#123;    int ls,rs,mn;&#125;tr[maxn&lt;&lt;2];inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u,int fa)&#123;    dfn[u]=low[u]=++tim;    stk[++top]=u;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            tarjan(v,u);            low[u]=min(low[u],low[v]);            if(low[v]&gt;=dfn[u])&#123;                g[++tot].push_back(u),g[u].push_back(tot);                int x;                do&#123;                    x=stk[top--];                    g[tot].push_back(x),g[x].push_back(tot);                &#125;while(x!=v);            &#125;        &#125;        else if(v!=fa) low[u]=min(low[u],dfn[v]);    &#125;&#125;inline void dfs1(int u,int fa)&#123;    t[u].fa=fa;t[u].siz=1;t[u].dep=t[fa].dep+1;    for(auto v:g[u])&#123;        if(v==fa) continue;        dfs1(v,u);        t[u].siz+=t[v].siz;        if(!t[u].hson||t[v].siz&gt;t[t[u].hson].siz) t[u].hson=v;    &#125;&#125;inline void dfs2(int u,int top)&#123;    t[u].dfn=++id;t[id].seq=u;t[u].top=top;    if(!t[u].hson) return;    dfs2(t[u].hson,top);    for(auto v:g[u])&#123;        if(v==t[u].hson||v==t[u].fa) continue;        dfs2(v,v);    &#125;&#125;inline void up(int p)&#123;tr[p].mn=min(tr[ls(p)].mn,tr[rs(p)].mn);&#125;inline void build(int l,int r,int &amp;p)&#123;    if(!p) p=++segcnt;    if(l==r)&#123;tr[p].mn=a[t[l].seq];return;&#125;    int mid=(l+r)&gt;&gt;1;    build(l,mid,ls(p)),build(mid+1,r,rs(p));    up(p);&#125;inline void update(int l,int r,int pos,int val,int p)&#123;    if(l==r)&#123;tr[p].mn=val;return;&#125;    int mid=(l+r)&gt;&gt;1;    if(pos&lt;=mid) update(l,mid,pos,val,ls(p));    else update(mid+1,r,pos,val,rs(p));    up(p);&#125;inline int query(int l,int r,int L,int R,int p)&#123;    if(l&gt;=L&amp;&amp;r&lt;=R) return tr[p].mn;    int mid=(l+r)&gt;&gt;1,res=inf;    if(L&lt;=mid) res=min(res,query(l,mid,L,R,ls(p)));    if(R&gt;mid) res=min(res,query(mid+1,r,L,R,rs(p)));    return res;&#125;inline int query(int u,int v)&#123;    int res=inf;    while(t[u].top!=t[v].top)&#123;        if(t[t[u].top].dep&lt;t[t[v].top].dep) swap(u,v);        res=min(res,query(1,tot,t[t[u].top].dfn,t[u].dfn,1));        u=t[t[u].top].fa;    &#125;    if(t[u].dep&gt;t[v].dep) swap(u,v);    res=min(res,query(1,tot,t[u].dfn,t[v].dfn,1));    if(u&gt;n) res=min(res,a[t[u].fa]);    return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;Q;tot=n;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    tarjan(1,0),dfs1(1,0),dfs2(1,1);    for(re int i=2;i&lt;=n;++i) s[t[i].fa-n].insert(a[i]);    for(re int i=n+1;i&lt;=tot;++i) a[i]=s[i-n].empty()?inf:*s[i-n].begin();    build(1,tot,rt);    char op;int x,y;    while(Q--)&#123;        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;        if(op==&#x27;C&#x27;)&#123;            update(1,tot,t[x].dfn,y,1);            if(x==1)&#123;a[x]=y;continue;&#125;            s[t[x].fa-n].erase(s[t[x].fa-n].lower_bound(a[x]));            s[t[x].fa-n].insert(y);            int mn=*s[t[x].fa-n].begin();            if(mn==a[t[x].fa])&#123;a[x]=y;continue;&#125;            update(1,tot,t[t[x].fa].dfn,mn,1);            a[t[x].fa]=mn,a[x]=y;         &#125;        else cout&lt;&lt;query(x,y)&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n【模板】静态仙人掌双倍经验： Freda的传呼机\n不会，摆。\n【MX-S1-T3】电动力学困难 dp，摆。\n「SWTR-8」地地铁铁困难性质，摆。\n","categories":["学习笔记"],"tags":["图论"]},{"title":"字符串哈希学习笔记","url":"/posts/72aa3132/","content":"字符串学到现在只会 SA，绷不住了。\n还是得学学哈希，不然真考字符串就寄了。\n什么是字符串哈希通过一个函数把一个字符串映射为一个整数，这个函数就是哈希函数。\n如何计算我们通常采用多项式哈希。\n设 base 为底数，p 为模数，则\n\nf(s)=\\sum_{i=1}^n s_i\\times base^{n-i} \\quad (mod\\ p)底数通常选择一个质数，模数通常选择一个大质数。\n推荐：底数 131，模数 1926081719491001071\n如果要用的话记得开 int128，不然你一乘就炸了。\n比较好记，就是江泽民主席的诞辰和建国时间拼起来再拼上071。\n如果没想起来用 1e9+7 也行，不过容易被卡。\n自然溢出还是算了吧，真怕被卡。\n如何计算子串哈希值首先处理出来前缀哈希值。\n设第 i 位哈希值为 h_i，则\n\nh_i=h_{i-1}\\times base+s_i\\quad (mod\\ p)则 s[l,r] 的哈希值，为 h_r-h_{l-1}\\times base^{r-l+1}\n如何判断是否是回文串正着算一遍哈希值，反着算一遍哈希值，如果一样说明是回文串。\n如何得到两个串接起来得到的新串的哈希值设两个字符串分别为 s,t，若把 t 接到 s 后面，则新串哈希值为 f(s)\\times base^{len_t}+f(t)\n如果题目涉及到以上问题（即需要相乘）且你使用了大模数，请先想想会不会炸，需不需要 int128。\n应用大概就字符串匹配吧？还有别的用途吗？\n字符串哈希厉害之处就在于可以在预处理后 O(1) 匹配。\n哈希还有一个常用搭配：二分。\n因为字符串的匹配是有单调性的，长的匹配说明短的也匹配，所以可以二分长度然后用哈希判断。\n例题【模板】字符串哈希第一道题肯定要放模板啦。\n求出每个字符串的哈希值，那么问题就变成了序列中有几个不同的数。\n非常简单吧。\n[CTSC2014] 企鹅 QQ因为要求恰好一位不同，所以考虑枚举哪一位不同。\n因为要把枚举到的那一位删掉，所以得处理所有串的前缀哈希，然后删这一位就是把前后的拼起来。\n求子串哈希和怎么拼起来都在上文提到过。\n然后就变成模板了。\n复杂度 O(nL\\log n)\n[POI2010] KOR-Beads首先枚举 k，然后枚举每一段。\n听上去很暴力对不对？但复杂度其实是有保证的。\n总时间复杂度应该是 \\sum_{k=1}^n \\lfloor \\frac{n}{k} \\rfloor。\n把 n 提出来，剩下的是个调和级数。\n所以时间复杂度 O(n\\log n)。\n用哈希匹配是 O(1) 的，所以总复杂度 O(n\\log n)。\n但有个需要注意的：这道题的串正着和反着视为相同，所以既要处理前缀哈希还要处理后缀哈希，只有都不相同时才能记录到答案。\n[POI2012] OKR-A Horrible Poem首先，设 len 为答案，则 len 为答案的充要条件为 s[l,r-len]=s[l+len,r]。\n其次，答案一定是区间长度的约数。\n所以我们从小到大枚举约数，然后哈希 O(1) 判断。\n复杂度 O(q\\omega(n))\n虽然约数个数是一个比 \\sqrt n 小一点的数，但依旧会 T。\n考虑优化一下这个东西。\n如果一个循环节出现了 2 次，另一个出现了 3 次，那么一定有一个会出现 6 次。\n所以我们对每个质因数分别做，最后把它们合起来。\n质因数个数是 \\log 级别的，可以通过。\n[CQOI2014] 通配符匹配因为通配符不超过 10，所以考虑把原串分成若干段，然后分段匹配，每段第一位为通配符。\n设 f_{i,j} 表示分出来的第 i 个串能否匹配上查询串的 第 j 位。\n转移为\n\nf_{i,j}=f_{i-1,j-len_i} \\quad 该段无通配符\n\\\\\nf_{i,j}=f_{i-1,j-len_i-1} \\quad 通配符为 ？\n\\\\\nf_{i,j}=\\oplus_{k=0}^{j-len_i} f_{i-1,k} \\quad 通配符为 *这里的 \\oplus 代表按位或。\n能否转移用哈希判断一下即可。\n设通配符个数为 m，复杂度为 O(nm|S|)\n[POI2006] PAL-Palindromes这不就是把上面那两个东西拼一块了吗。\n设两个字符串分别为 s,t，那么这对字符串合法的条件为 f(s)\\times base^{len_t}+f(t)=f(t)\\times base^{len_s}+f(s)。\n移项，得到 \\frac {f(s)}{base^{len_s}-1}=\\frac {f(t)}{base^{len_t}-1}\n对每个字符串求出这个东西，然后随便统计一下即可。\n[TJOI2017] DNA允许 k 次失配的字符串匹配。\n考虑二分+哈希。\n首先枚举所有可能匹配的子串，然后二分找到第一个失配的位置，把这个位置及之前的东西删掉，然后再进行这个过程。\n如果失配次数 \\le k，说明合法。\n设原串长度为 n，模式串长度为 m，复杂度 O(m+kn\\log m)\n「TAOI-2」Ciallo～(∠・ω&lt; )⌒★Ciallo～(∠・ω&lt; )⌒★\n洛谷题解传送门\n一道很好玩的题。\n直接做可能没什么想法，那我们先对 [l,r] 和 [l',r'] 讨论一下。\n这里的 l,r,l',r' 都是以原串为下标的。\n1.[l,r] 和 [l',r'] 无交\n那说明删除没任何影响。我们先找出所有匹配位置，然后随便算一下方案数就行了。\n2.[l,r] 和 [l',r'] 有交。\n不难发现，合法的 [l,r] 和 [l',r'] 一定形如下图\n\n图中的 x_i,y_i 分别代表 \\operatorname{LCP}(S(i,n),T),\\operatorname{LCS}(S(1,i),T)。\n设 S 长为 n，T 长为 m。\n红色部分为重复部分，长为 x_{l'}+y_{r'}-m。\n不难发现，对于这种情况，合法的方案数为 x_{l'}+y_{r'}-m+1。\n然后观察这种情况需要满足什么条件，不难发现，需要满足\n\nr'-l'\\ge m\n\\\\\nx_{l'}+y_{r'} \\ge m\n\\\\\nx_{l'} \\neq m\n\\\\\ny_{r'} \\neq m不能等于 m 是因为这部分贡献已经在前面算过了，不能重复计算。\n然后这东西就是个二维数点，数就完了。\n数点时记得减去贡献。\n树状数组 add 时可能会用到 0，整体加偏移量即可。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define lb(x) (x&amp;(-x))using namespace std;const int maxn=4e5+10,base=131,mod=1e9+7;int n,m,ans;char s1[maxn],s2[maxn];int pw[maxn];int h1[maxn],h2[maxn];int x[maxn],y[maxn];struct BIT&#123;    int tr[maxn];    inline void add(int x,int val)&#123;++x;while(x&lt;maxn) tr[x]+=val,x+=lb(x);&#125;    inline int query(int x)&#123;++x;int res=0;while(x&gt;0) res+=tr[x],x-=lb(x);return res;&#125;&#125;a,b;inline int calc1(int l,int r)&#123;return ((h1[r]-h1[l-1]*pw[r-l+1]%mod)%mod+mod)%mod;&#125;inline int calc2(int l,int r)&#123;return ((h2[r]-h2[l-1]*pw[r-l+1]%mod)%mod+mod)%mod;&#125;inline bool check1(int pos,int len)&#123;    if(pos+len-1&gt;n) return 0;    return calc1(pos,pos+len-1)==calc2(1,len);&#125;inline bool check2(int pos,int len)&#123;    if(pos-len+1&lt;1) return 0;    return calc1(pos-len+1,pos)==calc2(m-len+1,m);&#125;inline void init()&#123;    pw[0]=1;    for(re int i=1;i&lt;maxn;++i) pw[i]=pw[i-1]*base%mod;    for(re int i=1;i&lt;=n;++i) h1[i]=(h1[i-1]*base+s1[i])%mod;    for(re int i=1;i&lt;=m;++i) h2[i]=(h2[i-1]*base+s2[i])%mod;    for(re int i=1,l,r,mid,res;i&lt;=n;++i)&#123;        l=0,r=m,res=0;        while(l&lt;=r)&#123;            mid=(l+r)&gt;&gt;1;            if(check1(i,mid)) res=mid,l=mid+1;            else r=mid-1;        &#125;        x[i]=res;        l=0,r=m,res=0;        while(l&lt;=r)&#123;            mid=(l+r)&gt;&gt;1;            if(check2(i,mid)) res=mid,l=mid+1;            else r=mid-1;        &#125;        y[i]=res;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;(s1+1)&gt;&gt;(s2+1);n=strlen(s1+1),m=strlen(s2+1);    init();    for(re int i=1;i&lt;=n;++i) if(y[i]==m) ans+=((i-m)*(i-m+1)/2+(n-i)*(n-i+1)/2);    for(re int i=m+1;i&lt;=n;++i)&#123;        a.add(m-x[i-m],1),b.add(m-x[i-m],x[i-m]);        ans+=b.query(y[i])+(y[i]-m+1)*a.query(y[i]);        if(y[i]==m) ans-=a.query(y[i]);         ans-=a.query(0);    &#125;    cout&lt;&lt;ans;    return 0;&#125;\n[蓝桥杯 2016 国 AC] 碱基数据范围开这么小随便做吧。\n直接爆搜选哪些串，然后把长度为 k 的子串的哈希值存起来。\n这样对于每一个哈希值可以求出它在每个串中各出现了多少次，乘起来即可。\n复杂度 O(n2^nL)\n【模板】manacher马拉车过于困难，考虑用哈希搞搞部分分。\n部分分还是很好做的，我们处理出正着的哈希值和倒着的哈希值，然后枚举对称轴并二分长度，就做完了。\n复杂度 O(n\\log n)\n事实上哈希也是能做到线性的，且思路和马拉车差不多。\n[POI2010] ANT-Antisymmetry二分+哈希。\n基本和上题一样。\n处理出原串的哈希值和取反后的哈希值，然后枚举对称轴并二分长度。\n对于统计答案，可以发现只有总长为偶数才可能合法。\n然后没了。\n[USACO17OPEN] Bovine Genomics G简单题。\n枚举左端点，然后二分长度，然后哈希判断有没有重复。\n二分正确性也比较显然：如果当前长度不合法，那就必须变长，否则可以变短。\n复杂度 O(m\\log m n\\log n)\n感觉做不到 O(nm\\log m)，因为不管用 set，map 还是离散化都得带 \\log，所以题解复杂度是不是都写错了？\n[BalticOI 2014 Day1] Three Friends枚举哪个是插入的，然后把它删掉。\n然后看剩下的东西能不能组成两个相同串即可。\n这里还是稍微有点细节的，因为涉及到子串哈希值和把两个串拼接起来。\n观察样例一，你会发现把枚举的那个删掉以后，因为要组成两个相同串，所以要保证两段长度相等。\n所以要给短的那一段拼上一部分。\n大概就是这样吧，其他应该没什么细节。\n复杂度 O(n)\n[NOIP2020] 字符串匹配如果 AB 确定了，那么 C 也是确定的。\n所以考虑枚举 AB 和 i，这样做的好处是 i 是 \\log 级别的，所以总复杂度是 O(n\\log n)。\n然后要解决的问题就是出现次数了。\n我们可以维护出现次数为奇数次的个数的前缀和以及后缀和，那么查询用树状数组搞一下即可。\n设 V 为字符集大小，复杂度 O(n\\log n\\log V)。\n似乎需要卡常。\n","categories":["学习笔记"],"tags":["字符串"]},{"title":"快速沃尔什变换(FWT)学习笔记","url":"/posts/dccb649f/","content":"在 OI 中，FWT 是用于解决对下标进行位运算卷积问题的一种方法。\n引入给出序列 a,b，我们想要求出 c，满足\n\nc_i=\\sum_{j \\oplus k=i}a_j\\times b_k其中 \\oplus 代表按位与，按位或，按位异或中的一种。\n直接求是 O(n^2) 的，而 FWT 通过构造出一种可逆的变换 F，使得 F(c)=F(a) \\cdot F(b)，从而快速解决下标位运算卷积。\nFWT 的运算以下设 \\cup 为按位或，\\cap 为按位与，\\oplus 为按位异或。\n按位或考虑构造 F_i(a)=\\sum_{j \\cup i=i} a_j，则\n\n\\begin{align*}\nF_i(a)\\times F_i(b)&=(\\sum_{j\\cup i=i}a_j)(\\sum_{k\\cup i=i}b_k)\n\\\\\n&=\\sum_{j\\cup i=i}\\sum_{k \\cup i=i} a_j\\times b_k\n\\\\\n&=\\sum_{(j\\cup k)\\cup i=i} a_j\\times b_k\n\\\\\n&=F_i(c)\n\\end{align*}如果没看明白就把 F_i(c) 展开推一遍，然后就能发现这是一样的。\n那么我们现在只需要能做到快速求出 F_i(a) 且能快速进行逆运算就做完了。\n可以发现，这个 F_i(a)，不就是求子集和吗？\n对每个子集求子集和，这不是高维前缀和吗？\n考虑逆运算，显然只需要做一遍高维差分即可。\n复杂度 O(n2^n)，这里的 n 指的是维数。如果把 n 变成序列长度，则复杂度为 O(n\\log n)。\n按位与考虑构造 F_i(a)=\\sum_{j \\cap i=i} a_j，可以发现形式和按位或的情况一模一样。\n证明也类似按位或，这里不再赘述。\n可以发现，和按位或的唯一区别在于之前是求子集和，现在是求超集和。\n依旧可以高维前缀和。\n复杂度 O(n\\log n)\n按位异或因为还没学明白，所以基本都是抄的 OI Wiki。\n设 x \\otimes y=\\operatorname{popcount}(x \\cap y) \\ mod \\ 2 。\n那么可以得到 \\otimes 对 \\oplus 有分配律：\n\nx\\otimes (y\\oplus z)=(x\\otimes y)\\oplus (x\\otimes z)考虑构造 F_i(a)=\\sum_{i \\otimes j=0}a_j-\\sum_{i \\otimes j=1}a_j，则\n\n\\begin{align*}\nF_i(a)\\times F_i(b)&=(\\sum_{i \\otimes j=0}a_j-\\sum_{i \\otimes j=1}a_j)\\times (\\sum_{i \\otimes k=0}b_k-\\sum_{i \\otimes k=1}b_k)\n\\\\\n&=(\\sum_{i \\otimes j=0}a_j\\sum_{i \\otimes k=0}b_k+\\sum_{i \\otimes j=1}a_j\\sum_{i \\otimes k=1}b_k)-(\\sum_{i \\otimes j=0}a_j\\sum_{i \\otimes k=1}b_k+\\sum_{i \\otimes j=1}a_j\\sum_{i \\otimes k=0}b_k)\n\\\\\n&=\\sum_{i\\otimes(j\\oplus k)=0}a_jb_k-\\sum_{i\\otimes(j\\oplus k)=1}a_jb_k\n\\\\\n&=F_i(c)\n\\end{align*}如何快速计算 F(a)？考虑分治。\n设 i 在当前位为 0 的子数列为 F(a_0)，在当前位为 1 的子数列为 F(a_1)，则\n\nF(a)=merge(F(a_0)+F(a_1),F(a_0)-F(a_1))其中 merge 表示拼接，+,- 表示对应位置加/减。\n逆变换为\n\nF'(a)=merge(\\frac{F'(a_0)+F'(a_1)}{2},\\frac{F'(a_0)-F'(a_1)}{2})复杂度 O(n\\log n)\n例题：【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=(1&lt;&lt;17)+10,mod=998244353,inv2=499122177;int n,S;int A[maxn],B[maxn];int a[maxn],b[maxn],c[maxn];inline void in()&#123;for(re int i=0;i&lt;=S;++i) a[i]=A[i],b[i]=B[i];&#125;inline void get()&#123;for(re int i=0;i&lt;=S;++i) c[i]=a[i]*b[i]%mod;&#125;inline void out()&#123;for(re int i=0;i&lt;=S;++i) cout&lt;&lt;c[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;&#x27;\\n&#x27;;&#125;inline void OR(int f[],int op)&#123;    for(re int i=0;i&lt;n;++i)&#123;        for(re int s=0;s&lt;=S;++s)&#123;            if((s&gt;&gt;i)&amp;1) f[s]=((f[s]+f[s^(1&lt;&lt;i)]*op)%mod+mod)%mod;        &#125;    &#125;&#125;inline void AND(int f[],int op)&#123;    for(re int i=0;i&lt;n;++i)&#123;        for(re int s=0;s&lt;=S;++s)&#123;            if((s&gt;&gt;i)&amp;1) f[s^(1&lt;&lt;i)]=((f[s^(1&lt;&lt;i)]+f[s]*op)%mod+mod)%mod;        &#125;    &#125;&#125;inline void XOR(int f[],int op)&#123;    for(re int i=0,len=1;i&lt;n;++i,len&lt;&lt;=1)&#123;        for(re int s=0;s&lt;=S;s+=len*2)&#123;            for(re int j=0;j&lt;len;++j)&#123;                f[s+j]=(f[s+j]+f[s+j+len])%mod;                f[s+j+len]=((f[s+j]-f[s+j+len]*2)%mod+mod)%mod;                f[s+j]=((f[s+j]*op)%mod+mod)%mod;                f[s+j+len]=((f[s+j+len]*op)%mod+mod)%mod;            &#125;        &#125;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n;S=(1&lt;&lt;n)-1;    for(re int i=0;i&lt;=S;++i) cin&gt;&gt;A[i];    for(re int i=0;i&lt;=S;++i) cin&gt;&gt;B[i];    in(),OR(a,1),OR(b,1),get(),OR(c,-1),out();    in(),AND(a,1),AND(b,1),get(),AND(c,-1),out();    in(),XOR(a,1),XOR(b,1),get(),XOR(c,inv2),out();    return 0;&#125;\n","categories":["学习笔记"],"tags":["数学"]},{"title":"拉格朗日插值学习笔记","url":"/posts/1126bb36/","content":"引入在初中时，我们都学过一次函数，一定也都做过这种题：\n\n给定两个点，求经过这两个点的一次函数的解析式。\n\n我们只需要待定系数法，然后把点坐标带进去解方程即可。\n那么推广一下，可以得到结论：\n\n在平面直角坐标系中，n+1 个点能唯一确定一个 n 次多项式。\n\n但如果我们暴力高斯消元，复杂度是 O(n^3) 的。\n而拉格朗日插值法可以在 O(n^2) 的复杂度内解决这个问题。\n单点求值设 f(x) 为待求多项式，(x_i,y_i) 为第 i 个点的坐标。\n设拉格朗日基本多项式为\n\ng_j(x)=\\prod_{i=0,i\\neq j}^n \\frac {x-x_i}{x_j-x_i}这个多项式十分巧妙。\n可以发现，\\forall i\\in[0,n],g_j(x_i)=[i=j]。\n根据基本多项式，我们可以构造出 f(x)：\n\nf(x)=\\sum_{i=0}^n y_ig_i(x)根据基本多项式的性质，我们可以得到 f(x_i)=y_i，也就是恰好经过这 n+1 个点。\n那么单点求值时，只需要把那个点带进去即可。\n复杂度 O(n^2)\n事实上应该线性求逆元才是严格 O(n^2) 的，但我懒了，所以写的是 O(n^2\\log n) 的。\n例题：【模板】拉格朗日插值\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e3+10,mod=998244353;int n,k,ans;int x[maxn],y[maxn];inline int qpow(int a,int b)&#123;    int res=1;    while(b)&#123;        if(b&amp;1) res=res*a%mod;        b&gt;&gt;=1;        a=a*a%mod;    &#125;    return res;&#125;inline int inv(int x)&#123;return qpow(x,mod-2);&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;k;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;x[i]&gt;&gt;y[i];    for(re int i=1;i&lt;=n;++i)&#123;        int s1=y[i],s2=1;        for(re int j=1;j&lt;=n;++j)&#123;            if(i!=j) s1=s1*((k-x[j])%mod+mod)%mod,s2=s2*((x[i]-x[j])%mod+mod)%mod;        &#125;        ans=(ans+s1%mod*inv(s2)%mod)%mod;    &#125;    cout&lt;&lt;ans;    return 0;&#125;\n求出系数现在我们已经可以做到 O(n^2) 复杂度的单点求值了。\n但这还不够，因为我想具体求出来这个多项式。\n把上面那个东西拿过来：\n\nf(x)=\\sum_{i=0}^n y_i\\prod_{j=0,j\\neq i}^n\\frac {x-x_j}{x_i-x_j}提出常数部分：\n\na_i=\\frac{y_i}{\\prod_{j=0,j\\neq i}^n(x_i-x_j)}然后设 g(k)=\\prod_{i=0}^n(k-x_i)，则\n\nf(x)=\\sum_{i=0}^n a_i\\frac {g(x)}{x-x_i}我们可以暴力的把 g(x) 这个多项式算出来，这是 O(n^2) 的。\n然后对于每一项，我们暴力模拟长除法，总复杂度是 O(n^2) 的。\n综上，我们在 O(n^2) 的复杂度内得到了多项式的系数。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e3+10,mod=998244353;int n,k;int x[maxn],y[maxn];int f[maxn],g[maxn];int a[maxn];int tmp[maxn];inline int qpow(int a,int b)&#123;    int res=1;    while(b)&#123;        if(b&amp;1) res=res*a%mod;        b&gt;&gt;=1;        a=a*a%mod;    &#125;    return res;&#125;inline int Inv(int x)&#123;return qpow(x,mod-2);&#125;inline void pre()&#123;    for(re int i=1;i&lt;=n;++i)&#123;        int res=1;        for(re int j=1;j&lt;=n;++j)&#123;            if(i!=j) res=res*(x[i]-x[j]+mod)%mod;         &#125;        a[i]=y[i]*Inv(res)%mod;    &#125;    g[0]=1;    for(re int i=1;i&lt;=n;++i,swap(g,tmp))&#123;        tmp[0]=0;        for(re int j=1;j&lt;=i;++j) tmp[j]=g[j-1];        for(re int j=0;j&lt;=i;++j) tmp[j]=(tmp[j]+g[j]*(-x[i]+mod)%mod)%mod;    &#125;&#125;inline void Lagrange()&#123;    for(re int i=1;i&lt;=n;++i)&#123;        int lst=0,inv=Inv(-x[i]+mod);        for(re int j=0;j&lt;n;++j)&#123;            tmp[j]=(g[j]-lst+mod)*inv%mod;            f[j]=(f[j]+a[i]*tmp[j]%mod)%mod,lst=tmp[j];        &#125;    &#125;&#125;inline int calc(int x)&#123;    int ans=0,res=1;    for(re int i=0;i&lt;n;++i)&#123;        ans=(ans+res*f[i]%mod)%mod;        res=res*x%mod;    &#125;    return ans;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;k;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;x[i]&gt;&gt;y[i];    pre();    Lagrange();    cout&lt;&lt;calc(k);    return 0;&#125;\nx 取值连续时的优化此时式子变为\n\nf(k)=\\sum_{i=0}^n y_i\\prod_{j=0,i\\neq j}^n \\frac{k-i}{i-j}对于分子，我们维护前缀积和后缀积。\n对于分母，可以发现这是一个阶乘形式。\n所以式子变为\n\nf(k)=\\sum_{i=0}^n y_i\\frac {pre_{i-1}\\times suf_{i+1}}{(i-1)!\\times (n-i)!}当 n-i 为奇数时，分母应为负号。\n复杂度 O(n)\n例题：求 \\sum_{i=1}^n i^k。\nThe Sum of the k-th Powers\n可以证明，\\sum_{i=1}^n i^k 为 k+1 次多项式。\n所以直接取 k+2 个点把它插出来即可。\n取值连续，所以可以做到 O(n)。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e6+10,mod=1e9+7;int n,m,k,ans;int fac[maxn],pre[maxn],suf[maxn];inline int qpow(int a,int b)&#123;    int res=1;    while(b)&#123;        if(b&amp;1) res=res*a%mod;        b&gt;&gt;=1;        a=a*a%mod;    &#125;    return res;&#125;inline int inv(int x)&#123;return qpow(x,mod-2);&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;k;m=k+2;    pre[0]=fac[0]=suf[m+1]=1;    for(re int i=1;i&lt;=m;++i) pre[i]=pre[i-1]*(n-i)%mod;    for(re int i=m;i&gt;=1;--i) suf[i]=suf[i+1]*(n-i)%mod;    for(re int i=1;i&lt;=m;++i) fac[i]=fac[i-1]*i%mod;    int y=0;    for(re int i=1;i&lt;=m;++i)&#123;        y=(y+qpow(i,k)%mod)%mod;        int s1=pre[i-1]%mod*suf[i+1]%mod;        int s2=((m-i)&amp;1?-1ll:1ll)*fac[i-1]%mod*fac[m-i]%mod;        ans=(ans+(y%mod*s1%mod*inv(s2)%mod)%mod+mod)%mod;    &#125;    cout&lt;&lt;ans;    return 0;&#125;\n","categories":["学习笔记"],"tags":["数学"]},{"title":"操作树学习笔记","url":"/posts/7f69f632/","content":"参考文章\n引入有些题目有这样的特点：\n\n允许离线\n需要回退历史版本\n\n这种情况下，我们可以离线所有操作，建立操作树，每个版本对应一个节点，其父亲就是其来源的版本。对于修改操作，回溯时回退即可。\n当然，如果强制在线的话还是上可持久化数据结构吧。\n例题[HBCPC2024] Enchanted第一次见到这个 trick 是在这个题。\n不考虑操作树的话，剩下的和 Mark and Professor Koro 还是很像的。\n对于这种两个相同的数合并成 +1 的数的操作，我们可以把它看成二进制意义下的加法，然后进行维护。\n这道题值域很小，所以可以直接把二进制用整数表示。\n考虑建立操作树，操作四就解决了。\n操作三是单点修改，比较简单。\n操作一就是表示成二进制以后求和找最高位。\n操作二就是表示成二进制以后求和，然后找第 k 位向上的连续位数。\n单点修区间和，树状数组即可。\n复杂度 O(n\\log n)\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define lb(x) (x&amp;(-x))using namespace std;const int maxn=1e6+10,mod=1e9+7;int n,m,seed,P,Q;\tint a[maxn],ans[maxn];struct Query&#123;    int op,x,y,k;&#125;q[maxn];struct BIT&#123;    int tr[maxn];    inline void add(int x,int val)&#123;while(x&lt;=n) tr[x]+=val,x+=lb(x);&#125;    inline int query(int x)&#123;int res=0;while(x) res+=tr[x],x-=lb(x);return res;&#125;&#125;b;vector&lt;int&gt; g[maxn];inline int rnd()&#123;    seed=(7*seed+13)%19260817;    return seed;&#125;inline void dfs(int u)&#123;    int op=q[u].op,x=q[u].x,y=q[u].y,k=q[u].k;    if(op==1)&#123;        int res=b.query(y)-b.query(x-1);        ans[u]=floor(__lg(res))+1;    &#125;    if(op==2)&#123;        int res=b.query(y)-b.query(x-1);        res&gt;&gt;=(k-1);        int bs=(1ll&lt;&lt;(k+1));        while(res&amp;1) ans[u]=(ans[u]+bs)%mod,bs&lt;&lt;=1,res&gt;&gt;=1;    &#125;    if(op==3)&#123;        b.add(x,(1ll&lt;&lt;(q[u].y-1))-(1ll&lt;&lt;(a[x]-1)));        swap(a[x],q[u].y);    &#125;    for(auto v:g[u]) dfs(v);    if(op==3)&#123;        b.add(x,(1ll&lt;&lt;(q[u].y-1))-(1ll&lt;&lt;(a[x]-1)));        swap(a[x],q[u].y);    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;seed&gt;&gt;P&gt;&gt;Q;    for(re int i=1;i&lt;=n;++i) a[i]=rnd()%Q+1,b.add(i,1ll&lt;&lt;(a[i]-1));    for(re int i=1,op,x,y,k;i&lt;=m;++i)&#123;        op=rnd()%P+1;        if(op==1)&#123;            x=rnd()%n+1,y=rnd()%n+1;            if(x&gt;y) swap(x,y);        &#125;        if(op==2)&#123;            x=rnd()%n+1,y=rnd()%n+1,k=rnd()%Q+1;            if(x&gt;y) swap(x,y);        &#125;        if(op==3) x=rnd()%n+1,y=rnd()%Q+1;        if(op==4) x=rnd()%i;        q[i]=&#123;op,x,y,k&#125;;        op==4?g[x].push_back(i):g[i-1].push_back(i);    &#125;    dfs(0);    for(re int i=1;i&lt;=m;++i) if(q[i].op==1||q[i].op==2) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n「TOCO Round 1」History 考虑建立操作树，操作三就解决了。\n操作一是单点修改，比较简单。\n考虑操作二如何实现。\n看到相同深度想到 bfs 序，那么这些点事实上就是 x 的 \\frac {y}{2} 级祖先的子树内和 x 在相同深度的点。\n不难发现这些点的 bfs 序是连续的。\n然后考虑怎么得到  \\frac {y}{2} 级祖先的子树内和 x 在相同深度的点。\n可以发现，这些点的 dfs 序也是连续的。\n所以我们把所有和 x 在相同深度的点拿出来，然后二分找到 dfs 序在 [dfn_{fa},dfn_{fa}+siz_{fa}-1] 的点，那么操作二就变成了区间查询。\n别忘了把 \\frac {y}{2}-1 级祖先的子树内和 x 在相同深度的点扣掉，因为这些点并不合法。\n复杂度 O(n\\log n)\n有些细节，例如 y 可以不合法，而且还能为 0，都需要特判。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define lb(x) (x&amp;(-x))#define pii pair&lt;int,int&gt;#define fi first#define se secondusing namespace std;const int maxn=1e5+10;int n,m,cnt,tim;int a[maxn];int head[maxn],ans[maxn];int fa[maxn][18];int c[maxn];vector&lt;int&gt; g[maxn],Dep[maxn];struct edge&#123;    int to,nxt;&#125;e[maxn&lt;&lt;1];struct Query&#123;    int op,x,y;&#125;q[maxn];struct node&#123;    int dfn,bfn,siz,dep,seq;&#125;t[maxn];struct BIT&#123;    int tr[maxn];    inline void add(int x,int val)&#123;++x;while(x&lt;=n+1) tr[x]+=val,x+=lb(x);&#125;    inline int query(int x)&#123;++x;int res=0;while(x) res+=tr[x],x-=lb(x);return res;&#125;&#125;b;inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void bfs(int s)&#123;    queue&lt;pii&gt; q;    q.push(&#123;s,1&#125;);    while(!q.empty())&#123;        int u=q.front().fi,dep=q.front().se;        q.pop();        t[u].bfn=++tim,Dep[dep].push_back(t[u].dfn),t[u].dep=dep;        for(re int i=head[u];i;i=e[i].nxt)&#123;            int v=e[i].to;            if(!t[v].bfn) q.push(&#123;v,dep+1&#125;);        &#125;    &#125;&#125;inline void dfs1(int u,int ft)&#123;    t[u].siz=1;fa[u][0]=ft;    t[u].dfn=++tim;t[tim].seq=u;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(v==ft) continue;        dfs1(v,u);        t[u].siz+=t[v].siz;    &#125;&#125;inline void init()&#123;    for(re int j=1;j&lt;=17;++j)&#123;        for(re int u=1;u&lt;=n;++u)&#123;            fa[u][j]=fa[fa[u][j-1]][j-1];        &#125;    &#125;&#125;inline int find(int u,int dep)&#123;    for(re int i=17;i&gt;=0;--i) if(dep&gt;=(1ll&lt;&lt;i)) u=fa[u][i],dep-=(1ll&lt;&lt;i);    return u;&#125;inline void dfs(int u)&#123;    int op=q[u].op,x=q[u].x,y=q[u].y;    if(op==1) a[x]?b.add(t[x].bfn,-1):b.add(t[x].bfn,1),a[x]^=1;    if(op==2&amp;&amp;!(y&amp;1))&#123;        if(y==0) ans[u]=a[x];        else&#123;            int fa=find(x,y/2),dep=t[x].dep;            if(fa)&#123;                int l=Dep[dep][lower_bound(Dep[dep].begin(),Dep[dep].end(),t[fa].dfn)-Dep[dep].begin()];                int r=Dep[dep][upper_bound(Dep[dep].begin(),Dep[dep].end(),t[fa].dfn+t[fa].siz-1)-Dep[dep].begin()-1];                l=t[l].seq,r=t[r].seq;                ans[u]+=(b.query(t[r].bfn)-b.query(t[l].bfn-1));\t            &#125;            if(fa) fa=find(x,y/2-1);            if(fa)&#123;                int l=Dep[dep][lower_bound(Dep[dep].begin(),Dep[dep].end(),t[fa].dfn)-Dep[dep].begin()];                int r=Dep[dep][upper_bound(Dep[dep].begin(),Dep[dep].end(),t[fa].dfn+t[fa].siz-1)-Dep[dep].begin()-1];                l=t[l].seq,r=t[r].seq;                ans[u]-=(b.query(t[r].bfn)-b.query(t[l].bfn-1));            &#125;\t        &#125;    &#125;    for(auto v:g[u]) dfs(v);    if(op==1) a[x]?b.add(t[x].bfn,-1):b.add(t[x].bfn,1),a[x]^=1;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n;    for(re int i=1,u,v;i&lt;n;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    cin&gt;&gt;m;    for(re int i=1;i&lt;=m;++i)&#123;        cin&gt;&gt;q[i].op&gt;&gt;q[i].x;        if(q[i].op==2) cin&gt;&gt;q[i].y;        q[i].op==3?g[q[i].x].push_back(i):g[i-1].push_back(i);    &#125;    dfs1(1,0);tim=0;bfs(1);init();    dfs(0);    for(re int i=1;i&lt;=m;++i) if(q[i].op==2) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\nPersistent Bookcase *2200建操作树后暴力 bitset 维护即可。\n对一行取反可以先把一个全为 1 的 bitset 处理出来，然后异或这个 bitset 即可。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e3+10,maxq=1e5+10;int n,m,Q,now;int ans[maxq];bitset&lt;maxn&gt; a[maxn],A;vector&lt;int&gt; g[maxq];struct query&#123;    int op,x,y;&#125;q[maxq];inline void dfs(int u)&#123;    int op=q[u].op,x=q[u].x,y=q[u].y;    bool sta=0;    if(op==1)&#123;        sta=a[x][y];        if(!a[x][y]) ++now;        a[x][y]=1;    &#125;    if(op==2)&#123;        sta=a[x][y];        if(a[x][y]) --now;        a[x][y]=0;    &#125;    if(op==3)&#123;        int res=a[x].count();        a[x]^=A;        now+=a[x].count()-res;    &#125;    ans[u]=now;    for(auto v:g[u]) dfs(v);    if(op==1)&#123;        if(!sta) --now;        a[x][y]=sta;    &#125;    if(op==2)&#123;        if(sta) ++now;        a[x][y]=sta;    &#125;    if(op==3)&#123;        int res=a[x].count();        a[x]^=A;        now+=a[x].count()-res;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;Q;    for(re int i=1;i&lt;=m;++i) A[i]=1;    for(re int i=1,op,x,y;i&lt;=Q;++i)&#123;        cin&gt;&gt;op;        if(op==1||op==2) cin&gt;&gt;x&gt;&gt;y;        else cin&gt;&gt;x;        q[i]=&#123;op,x,y&#125;;        op==4?g[x].push_back(i):g[i-1].push_back(i);     &#125;    dfs(0);    for(re int i=1;i&lt;=Q;++i) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n可持久化并查集没有强制在线，所以考虑操作树。\n维护个可撤销并查集就行了。\n没写代码。\n[Ynoi2014] 等这场战争结束之后如果没有回撤，那么这是[HNOI2012] 永无乡，并查集+线段树合并即可。\n那我暴力线段树合并+分裂行不行？不行，因为每次撤销都可以卡成 O(n) 次分裂，那就寄了。\n那我 LCT 上维护 set 行不行？不行，理由同上。\n我们真的需要 LCT 维护这个东西吗？事实上不用，因为我们只关心连通性，所以可撤销并查集就足够了。\n那 kth 怎么解决？线段树用不了了，那就值域分块！\n我们对每个联通块维护所有整块的信息，合并时暴力合并。\n查询也很简单，因为相当于查全局 kth，直接枚举每个整块，然后找到落在哪个块时就枚举这个块里的值。\n枚举值的时候要判断这个值对应的点是否在联通块内，所以要给值和点对应一个关系（下面提到了）。\n时间复杂度 O(n\\log n+q(\\frac {n}{B}+B\\log n))，空间复杂度 O(\\frac {n^2}{B})。\n块长取 B=\\sqrt \\frac{n}{\\log n} 时最优。\n时间复杂度 O(n\\log n+q\\sqrt {n\\log n})，空间复杂度 O(n\\sqrt {n\\log n})\n代码倒是没有很难写，主要是卡空间卡的要死。\n卡空间的一些技巧：\n\n块长调大点\n能开 short 的数组开 short\n别用 vector 存图，用链式前向星\n能不存的就别存，例如每个块的起始终点之类的\n\n还有一些需要注意的点：\n\n离散化时，相同的数不能视为一个，因为在查询时，我们查到一个整块的里面时，需要知道每个值对应的下标是否在当前连通块里，所以编号要注意。\n别写 UB 或你弄不懂到底会怎么运行的代码。例如我参考的题解里写了一句 a[i]+=cnt[a[i]]++;，这东西你真能弄清吗。\n\n因为一直卡不过去所以最后参考了题解，代码也跟题解差不多了，而且写的也很丑，所以不放代码了。\n","categories":["学习笔记"],"tags":["数据结构","其他技巧"]},{"title":"笛卡尔树学习笔记","url":"/posts/9c20eda6/","content":"笛卡尔树是一种二叉树，它既满足二叉搜索树的性质，又满足堆的性质。\n例如 treap，就属于笛卡尔树的一种。\n以下规定：第一键值为满足二叉搜索树的键值，第二键值为满足堆的键值。\n构建我们可以用单调栈做到 O(n) 建树。\n我们考虑将下标作为第一键值，权值作为第二键值。\n那么每次我们插入的元素必然在这棵树的右链（右链：即从根节点一直往右子树走，经过的节点形成的链）的末端。\n所以我们可以用栈来维护笛卡尔树的右链。\n假设我们要建一颗大根笛卡尔树。\n设当前位置为 i，前 i-1 个位置已经构建好了。设栈顶元素为 a_{top}。\n我们维护值单调递增的单调栈。\n若 a_i \\le a_{top}，直接将 i 入栈（也就是把 i 挂在右链上）。\n否则一直弹栈，直到栈空或 a_i \\le a_{top}。把最后一个弹出的元素设为 i 的左儿子。\nfor(re int i=1;i&lt;=n;++i)&#123;    int tmp=top;    while(tmp&amp;&amp;a[stk[tmp]]&lt;a[i]) --tmp;    if(tmp) rs[stk[tmp]]=i;    if(tmp&lt;top) ls[i]=stk[tmp+1];    stk[++tmp]=i;    top=tmp;&#125;\n事实上，如果要按某个值作为第一键值，那么按这个值排序即可。\n可以发现，笛卡尔树的根就是 stk_1。\n应用笛卡尔树大多用来 dp。\n对原问题转化后，变为笛卡尔树上的 dp 问题。\n而且一般只会用到思想，并不会真把树建出来。\n以及一些直方图似乎也会用到。\n对于直方图类问题，我们常把下标作为第一键值，h_i 作为第二键值建立小根笛卡尔树。\n例题[TJOI2011] 树的序一道考察笛卡尔树定义的题。\n题目给的很明白了，要按权值当第一键值。\n因为要求字典序最小的生成序列，所以我们把每个数在序列中的位置当作第二键值，然后建小根笛卡尔树即可。\n因为插入顺序是父亲-&gt;左儿子-&gt;右儿子，所以输出先序遍历即可。\n注意输出的是键而不是编号。\nLargest Rectangle in a Histogram笛卡尔树求矩形面积板子题。\n我们把下标作为第一键值，h_i 作为第二键值建立小根笛卡尔树。\n枚举点 u，看当 h_u 作为矩形的高度时的最大面积。\n因为我们建的是小根树，所以子树内的点的 h_i 都大于 h_u。\n因为下标是键，所以子树内的点构成一段连续区间。\n那么以 h_u 作为高时的最大面积为 siz_u\\times h_u。\n[COCI2008-2009#4] PERIODNI我们考虑把这个多边形转成树。\n受上题启发，我们把下标作为第一键值，h_i 作为第二键值建立小根笛卡尔树。\n\n我们每次找到最低点，分成左右两边，然后递归处理。\n不难发现，这些矩形对应笛卡尔树上的所有节点。\n对于点 u,它代表的长为 siz_u，宽为 h_u-h_{fa}。\n因为两个儿子是分开的，所以可以直接合并，没有影响。\n设 f_{u,i} 表示以 u 为根的子树放了 i 个的方案数，g_{u,i} 表示以 u 为根的子树放了 i 个，且不包括 u 代表的矩形的方案数。\n那么 g 的转移就是背包。\n\ng_{u,i}=\\sum_{j=0}^i f_{ls,j}\\times f_{rs,i-j}至于 f 的转移，就是考虑 u 放几个。\n有结论：大小为 n\\times m 的棋盘，放 k 个互不攻击的车，方案数为 \\binom{n}{k}\\times \\binom{m}{k}\\times k!\n那么枚举子树一共用了几个，剩下的就是自己用的。\n注意子树用了的自己不能用。\n\nf_{u,i}=\\sum_{j=0}^i \\binom{siz_u}{i-j}\\times \\binom{h_u-h_{fa}}{i-j}\\times (i-j)!\\times g_{u,j}复杂度 O(nk^2+n^2)\nYet Another Array Counting Problem以下标为第一键值，a_i 为第二键值建立大根笛卡尔树，那么 [l,r] 的最左端最大值位置就是 l,r 在笛卡尔树上的 \\operatorname{lca}。\n那么所有最左端最大值位置都相等，就意味着笛卡尔树的形态相同。\n此时转化为树计数问题。\n设 f_{u,i} 表示 u 取值 1 \\sim i 的方案数。\n左儿子可以填 [1,i-1]，右儿子可以填 [1,i]\n转移就是 f_{u,i}=f_{u,i-1}+f_{ls_u,i-1}\\times f_{rs_u,i}\n复杂度 O(nm)\n","categories":["学习笔记"],"tags":["数据结构"]},{"title":"连通性问题学习笔记","url":"/posts/2dbb3c01/","content":"联通性这东西学一次忘一次，只能背板子了。\n原理？太困难了算了吧，板子也不难背。\n真想学原理去网上找找别的博客吧。\n考 tarjan 原理就爆了。\n还有，tarjan 的复杂度是 O(n+m) 的。\n模板求割边模板#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define pii pair&lt;int,int&gt; #define fi first#define se secondusing namespace std;const int maxn=1e5+10;int n,m,cnt=1,ans,tim;int head[maxn];int dfn[maxn],low[maxn];struct edge&#123;    int to,nxt;&#125;e[maxn&lt;&lt;1];vector&lt;pii&gt; g;inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u,int eid)&#123;    dfn[u]=low[u]=++tim;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            tarjan(v,i);            low[u]=min(low[u],low[v]);            if(low[v]&gt;dfn[u]) g.push_back(&#123;u,v&#125;);        &#125;        else if(i!=(eid^1)) low[u]=min(low[u],dfn[v]);    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    for(re int i=1;i&lt;=n;++i) if(!dfn[i]) tarjan(i,0);    sort(g.begin(),g.end());    for(auto x:g) cout&lt;&lt;x.fi&lt;&lt;&quot; &quot;&lt;&lt;x.se&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n求割点模板#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e5+10,maxm=1e5+10;int n,m,cnt,tim,ans;int head[maxn];int dfn[maxn],low[maxn];bitset&lt;maxn&gt; cut;struct node&#123;    int to,nxt;&#125;e[maxm&lt;&lt;1];vector&lt;int&gt; g;inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u,int fa)&#123;    int son=0;    dfn[u]=low[u]=++tim;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            ++son;            tarjan(v,u);            low[u]=min(low[u],low[v]);            if(u!=fa&amp;&amp;low[v]&gt;=dfn[u]) g.push_back(u);        &#125;        else if(v!=fa) low[u]=min(low[u],dfn[v]);    &#125;    if(u==fa&amp;&amp;son&gt;=2) g.push_back(u);&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    for(re int i=1;i&lt;=n;++i) if(!dfn[i]) tarjan(i,i);    sort(g.begin(),g.end());    g.erase(unique(g.begin(),g.end()),g.end());    for(auto x:g) cout&lt;&lt;x&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n缩点模板#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define pii pair&lt;int,int&gt;#define fi first#define se secondusing namespace std;const int maxn=1e5+10,maxm=1e5+10;int n,m,cnt,top,tim,scc;int head[maxn];int dfn[maxn],low[maxn],stk[maxn];int col[maxn],f[maxn];int in[maxn];bitset&lt;maxn&gt; vis;vector&lt;pii&gt; g;struct edge&#123;    int to,nxt;&#125;e[maxm];inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u)&#123;    dfn[u]=low[u]=++tim;    stk[++top]=u,vis[u]=1;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            tarjan(v);            low[u]=min(low[u],low[v]);        &#125;        else if(vis[v]) low[u]=min(low[u],dfn[v]);    &#125;    if(dfn[u]==low[u])&#123;        ++scc;        int x;        do&#123;            x=stk[top--];            col[x]=scc;            vis[x]=0;        &#125;while(x!=u);    &#125;&#125;inline void clear()&#123;    cnt=0;    memset(head,0,sizeof head);&#125;inline void topo()&#123;    queue&lt;int&gt; q;    for(re int i=1;i&lt;=scc;++i) if(!in[i]) q.push(i);    while(!q.empty())&#123;        int u=q.front();        q.pop();        for(re int i=head[u];i;i=e[i].nxt)&#123;            int v=e[i].to;            if(!(--in[v])) q.push(v);            //do something here        &#125;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),g.push_back(&#123;u,v&#125;);    for(re int i=1;i&lt;=n;++i) if(!dfn[i]) tarjan(i);    clear();    for(auto x:g) if(col[x.fi]!=col[x.se]) add(col[x.fi],col[x.se]),++in[col[x.se]];    topo();    return 0;&#125;\n求点双模板#include&quot;bits/stdc++.h&quot;using namespace std;#define re register#define int long longconst int maxn=5e5+10,maxm=2e6+10;int n,m,cnt,tot,top,tim;int head[maxn];int dfn[maxn],low[maxn];int stk[maxn];bitset&lt;maxn&gt; vis;vector&lt;int&gt; g[maxn];struct edge&#123;    int to,nxt;&#125;e[maxm&lt;&lt;1];inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u,int fa)&#123;    int son=0;    dfn[u]=low[u]=++tim;    stk[++top]=u;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            ++son;            tarjan(v,u);            low[u]=min(low[u],low[v]);            if(low[v]&gt;=dfn[u])&#123;                ++tot;                while(stk[top+1]!=v) g[tot].push_back(stk[top--]);                g[tot].push_back(u);            &#125;        &#125;        else if(v!=fa) low[u]=min(low[u],dfn[v]);    &#125;    if(u==fa&amp;&amp;!son) g[++tot].push_back(u);&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    for(re int i=1;i&lt;=n;++i) if(!dfn[i]) tarjan(i,i);    cout&lt;&lt;tot&lt;&lt;&#x27;\\n&#x27;;    for(re int i=1;i&lt;=tot;++i)&#123;        cout&lt;&lt;g[i].size()&lt;&lt;&quot; &quot;;        for(auto j:g[i]) cout&lt;&lt;j&lt;&lt;&quot; &quot;;        cout&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n求边双模板#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=5e5+10,maxm=2e6+10;int n,m,cnt=1,tot,tim;int head[maxn];int dfn[maxn],low[maxn];int col[maxn];bitset&lt;maxm&lt;&lt;1&gt; vis; vector&lt;int&gt; g[maxn];struct edge&#123;    int to,nxt;&#125;e[maxm&lt;&lt;1];inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u,int eid)&#123;    dfn[u]=low[u]=++tim;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            tarjan(v,i);            low[u]=min(low[u],low[v]);            if(low[v]&gt;dfn[u]) vis[i]=vis[i^1]=1;        &#125;        else if(i!=(eid^1)) low[u]=min(low[u],dfn[v]);    &#125;&#125;inline void dfs(int u,int id)&#123;    col[u]=id;    g[id].push_back(u);    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(col[v]||vis[i]) continue;        dfs(v,id);    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    for(re int i=1;i&lt;=n;++i) if(!dfn[i]) tarjan(i,0);    for(re int i=1;i&lt;=n;++i)&#123;        if(!col[i]) dfs(i,++tot);    &#125;    cout&lt;&lt;tot&lt;&lt;&#x27;\\n&#x27;;    for(re int i=1;i&lt;=tot;++i)&#123;        cout&lt;&lt;g[i].size()&lt;&lt;&quot; &quot;;        for(auto j:g[i]) cout&lt;&lt;j&lt;&lt;&quot; &quot;;        cout&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n常见技巧有一些无向图上的问题需要先缩个点/边双然后变成树上问题。\n有一些有向图上的问题需要先缩个点然后变成 DAG，然后拓扑序上搞事情。\n但一般来说难点都在缩完以后搞得那些东西上，例如 dp，贪心，数据结构啥的。\n点不能重复：缩点双。一条边最多属于一个点双。\n边不能重复：缩边双。一个点最多属于一个边双。\n所以把环缩成点要缩边双。\n例题下面选的基本都是一些简单板子题。\n间谍网络缩点板子。\n首先判断无解，然后缩点，然后把入度为 0 的点的权值拿了就行。\n一个强连通分量构成的点的权值为其内所有点的最小权值。\n有机化学之神偶尔会做作弊把环缩成点要缩边双。\n然后变成一颗树，树上距离随便求。\n[USACO5.3] 校园网Network of Schools 首先缩点，那么第一问答案就是入度为 0 的点的个数（和上面那个题一样）。\n第二问要求最少加几条边使得 DAG 变成强连通。\n我们贪心的想，肯定要让无出度点连向无入度点。那么连的边数就是 \\max(无出度点,无入度点)。\n注意特判本来就是强连通的情况。\n采蘑菇缩点以后变为 DAG 上最长路，dp 一下即可。\n[USACO06JAN] Redundant Paths G经典结论题。\n求最少添加多少条边，使得图变成边双连通。\n缩完点双后，统计入度和出度，答案为：（入度和出度之和为 1 的点+1）/2\n正则表达式板子。\n强连通分量内部不需要价值，所以缩点以后 DAG 上最短路即可。\n[APIO2009] 抢掠计划板子。\n强连通分量显然可以全拿，缩点以后 DAG 上最长路即可，注意只能在是酒吧的点取答案。\n[Wind Festival] Running In The Sky板子。\n缩点以后 DAG 上最长路即可，注意还得求个最大值。\n[SDOI2010] 所驼门王的宝藏怎么降蓝了？在 WLFS 做的时候还是紫。\n如果图建好了，那么它是板子，缩点以后 DAG 上最长路即可。\n但难点就在建图。\n直接建是 O(n^2) 的，肯定不行。\n但是每一行的横门可以相互到达，每一列的纵门也可以相互到达。\n对于优化建边有个常见套路：建虚点，然后把边都连向虚点。\n这样边数就是 O(n) 的了。\n[NOIP2022] 建造军营边双缩点后树形 dp。\n但是我不会这个 dp。\n摆。\n[POI2008] BLO-Blockade分情况讨论。\n若 u 不是割点，那么它会和剩下 n-1 个点不连通。\n若 u 是割点，那么显然会得到若干联通块（u 这个点自己也算个连通块）。\n那么答案就是 2\\sum_{i=1}^k siz_i\\times (n-siz_i)。\n求割点时顺便统计一下子树大小即可。\n[HAOI2010] 软件安装缩点以后变成树形背包板子。\n为什么缩完是树？因为题目保证只依赖一个物品。\n[USACO04DEC] Cow Ski Area G把图建出来以后就是[USACO5.3] 校园网Network of Schools 的第二问。\n「TAOI-1」椎名真昼好玩的博弈论。\n先不考虑博弈，只看这张图能不能全变白，可以发现：如果一个强连通分量里有异色点，那就不能。\n所以可以先缩点，顺便判断无解，此时我们得到一张 DAG。\n如果你思考一会，会发现这个游戏是很难有人获胜的。\n除非一步就能赢，否则对方可以一直模仿你的操作使你赢不了。\n所以可以猜到：只有一步能赢的时候才有人能赢，否则平局。\n那么考虑怎么一步赢。\nAlice 是很好考虑的，因为只能操作一次，所以如果遇到一个黑点，那么往后走就不能出现白点。\n如果搜完以后有没搜到的黑点，那么就寄了。\nBob 比较复杂。\n\n若存在至少一个入度为 0 的点为白点，那么 Bob 获胜当且仅当所有点都是白点。因为 Alice 可以让其中一个点变黑，Bob 为了赢必须把这个点弄回来。\n若所有入度为 0 的点均为黑点，如果只有一个那 Alice 肯定赢。如果有两个，那 Bob 肯定赢。否则平局。\n只有两个点，一黑一白，且黑点指向白点，则 Bob 必胜。\n\n综上，Bob 必胜的情况共三种：\n\n两个孤立黑点。\n两个点，一黑一白，且黑点指向白点。\n所有点均为白点。\n\n「EVOI-RD2」旅行家因为边不可以重复经过，所以缩边双。\n变成一棵树后就很简单了，每次覆盖一条路径，求被覆盖过的点的点权和。\n事实上都不用树剖，树上差分即可。\n","categories":["学习笔记"],"tags":["图论"]},{"title":"高维前缀和学习笔记","url":"/posts/beb6cf6/","content":"引入首先来看这样一个问题：\n\n\\forall s\\in[0,2^n-1]，求 \\sum_{t \\subseteq s} a_t。\n\n显然可以枚举子集做到 O(3^n)，但高维前缀和可以做到 O(n2^n)。\n那么什么是高维前缀和呢？\n我们先来看一些低维的前缀和，例如二维。\n在求二维前缀和时，我们通常用容斥的方法来求，即\n\ns_{i,j}=s_{i-1,j}+s_{i,j-1}-s_{i-1,j-1}+a_{i,j}但事实上，我们还可以把二维前缀和分解成两次一维前缀和，分别对每一维求前缀和。\nfor(int i = 1; i &lt;= n; i++)    for(int j = 1; j &lt;= n; j++)        a[i][j] += a[i - 1][j];for(int i = 1; i &lt;= n; i++)    for(int j = 1; j &lt;= n; j++)        a[i][j] += a[i][j - 1];\n高维前缀和高维前缀和的思路是类似的。\n我们可以把求集合 s 的子集和的过程看成求一个一共 n 维，每一维大小为 2 的前缀和。\nfor(re int i=0;i&lt;n;++i)&#123;    for(re int s=0;s&lt;(1&lt;&lt;n);++s)&#123;        if((s&gt;&gt;i)&amp;1) f[s]+=f[s^(1&lt;&lt;i)];    &#125;&#125;\n代码中的 f_s 表示集合 s 的子集和。\n阅读代码不难发现，我们事实上就是在干一件事：对每一个子集的每一维分别求前缀和。\n因为是对每一维分别求，所以一定是先枚举维再枚举子集。\n事实上，高维前缀和不止能维护前缀和，它可以维护任何半群信息。\n所以在遇到需要维护一个集合的所有子集的所有子集的半群信息时，都可以用高维前缀和做。\n例题[ARC100E] Or Plus Max下文定义 \\oplus 为按位或。\n首先把 i \\oplus j \\le k 的限制转化掉，所以考虑对每个 k 分别计算。\n设 A_k=\\max_{i \\oplus j =k,i \\neq j} a_i+a_j，那么 ans_k=\\max_{i=1}^k A_i。\n但这个 A_i 依旧不好算，我们考虑拓宽限制。\n设 B_k=\\max_{i,j \\subseteq k,i \\neq j} a_i+a_j，那么 ans_k=\\max_{i=1}^k B_i。\n这为什么是对的？A_i 不一定等于 B_i 啊？\n这是因为 i,j \\subseteq k 是 i \\oplus j =k 的必要条件，是 i \\oplus j \\le k 的充分条件。\n所以 i,j \\subseteq k,i \\neq j 的所有元素 (i,j) 一定完全包含 i \\oplus j =k,i \\neq j 的所有元素，且不包含 i \\oplus j >k 的任何元素，但可能会包含 i \\oplus j < k 的元素。\n但这不影响，因为我们的答案是前缀 \\max，所以统计到的答案依旧是对的。\n那么现在问题变成了 \\forall k\\in[1,2^n-1]，求 \\max_{i,j \\subseteq k,i \\neq j} a_i+a_j。\n不难发现，我们的 \\max 一定是最大和次大相加得到，所以只需要对于所有 k，维护子集最大和次大即可。\n这显然可以高维前缀和维护。\n复杂度 O(n2^n)\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define pii pair&lt;int,int&gt;#define fi first#define se secondusing namespace std;const int maxn=(1&lt;&lt;18)+10,inf=1e18;int n,S;pii f[maxn];inline void upd(pii &amp;a,pii b)&#123;    if(b.fi&gt;a.fi) a.se=max(a.fi,b.se),a.fi=b.fi;    else a.se=max(a.se,b.fi);&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n;S=(1&lt;&lt;n)-1;    for(re int i=0;i&lt;=S;++i) cin&gt;&gt;f[i].fi,f[i].se=-inf;    for(re int i=0;i&lt;n;++i)&#123;        for(re int s=0;s&lt;=S;++s)&#123;            if((s&gt;&gt;i)&amp;1) upd(f[s],f[s^(1&lt;&lt;i)]);        &#125;    &#125;    int ans=0;    for(re int i=1;i&lt;=S;++i) ans=max(ans,f[i].fi+f[i].se),cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\nVowels光题意就理解了半天···\n一个非常直接的想法：对于每一个单词，我们都枚举超集，然后贡献到超集上。\n这里的贡献注意不要算重，所以需要容斥一下。\n具体的，我们对每一个子集都枚举超集，然后加贡献时带上容斥系数。\n设 S 为单词长度，V 为字符集大小，则总复杂度为 O(n2^S2^V)\n但这样每次都枚举超集太浪费了，能不能优化？\n所以我们可以这样：对于每一个单词，先把贡献加到子集上，然后最后一块算贡献。\n这样就可以只枚举一次了。\n最后算贡献的时候，事实上就是求每个子集的子集和，高维前缀和即可。\n复杂度为 O(n2^S+V2^V)\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=(1&lt;&lt;24)+10,m=24,S=(1&lt;&lt;24)-1;int n;int f[maxn];signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n;char c;    for(re int i=1;i&lt;=n;++i)&#123;        int t=0,cnt=0;        for(re int j=1;j&lt;=3;++j) cin&gt;&gt;c,t|=(1&lt;&lt;(c-&#x27;a&#x27;));        for(re int s=t;s;s=(s-1)&amp;t)&#123;            if(__builtin_popcountll(s)&amp;1) ++f[s];            else --f[s];        &#125;    &#125;    for(re int i=0;i&lt;m;++i)&#123;        for(re int s=0;s&lt;=S;++s)&#123;            if((s&gt;&gt;i)&amp;1) f[s]+=f[s^(1&lt;&lt;i)];        &#125;    &#125;    int ans=0;    for(re int s=0;s&lt;=S;++s) ans^=(f[s]*f[s]);    cout&lt;&lt;ans;    return 0;&#125;\n拓展子集和能做，超集和呢？\n事实上也很简单，子集和时我们是子集向自己贡献，那超集和只需要自己向子集贡献即可。\nfor(re int i=0;i&lt;n;++i)&#123;    for(re int s=0;s&lt;(1&lt;&lt;n);++s)&#123;        if((s&gt;&gt;i)&amp;1) f[s^(1&lt;&lt;i)]+=f[s];    &#125;&#125;\n前缀和能做，差分呢？\n只需要符号变一下就行了。\n也不难理解，毕竟前缀和的逆运算就是差分。\nfor(re int i=0;i&lt;n;++i)&#123;    for(re int s=0;s&lt;(1&lt;&lt;n);++s)&#123;        if((s&gt;&gt;i)&amp;1) f[s]-=f[s^(1&lt;&lt;i)];    &#125;&#125;\n","categories":["学习笔记"],"tags":["dp","数学"]}]