[{"title":"2024.9.27","url":"/2024/09/27/2024-9-27/","content":"一直在搭博客没怎么做题啊···\nTourism *2200\n首先手玩样例可以发现：环上的点可以都拿，连接环的点也可以都拿。\n然后考虑剩下的点。\n因为剩下的点只能选一条点权和最大的路径，所以考虑拓扑 dp。\n那么答案就是起点到环经过的点 + 环上的点的点权和 + \\max f_i\n学到的东西：看到这种类似不能重复走一条边的东西可以考虑缩点双（因为割边走过去不能回来）\nHappy Line *2200\n感觉很困难。我是性质低手/kk。\n假设当前 a_i,a_{i+1}  需要操作，那么操作完后会变成 a_{i+1}+1,a_i-1。\n对于 a_i，可以发现 a_i+i=(a_i-1)+(i+1)。\n即 val_i+pos_i=val_i'+pos_i'。\n不难推出，对于所有 i，都有 a_i+i 为定值。\n那么将 a_i+i 排序得到序列 b，答案就是 b_i-i。\n无解就是存在 b_i=b_{i+1}。\n学到的东西：对于这种交换位置的题，要往排序想，分析两个元素交换带来的影响（类似微扰法）。\nShort Code *2200\n读完题瞬间想到一个假做法：按长度从小到大排序，然后模拟。\n但这很容易 hack。对于一个很长的串，我们完全可以让它取很短的一部分，让一些短串取稍微长一些。这样比长串取很长短串取很短要优。\n那从大到小呢？也不行。\n因为很有可能长串取完以后，一些短串作为长串的前缀，就算全取也无法避免重复，这就不合法了。\n然后不会了。\n正解：\n建立 trie 树。此时问题变为：\n给一棵树，有一些黑点。可以把黑点移到祖先处，但两个黑点不能在同一个位置。求最小的黑点深度和。\n用堆维护每颗子树中黑点的深度，如果根上没有黑点就把最深的移到根。\n学到的东西：看到字符串前缀想到 trie（还是字符串做少了）。\n","categories":["每日记录"],"tags":["Codeforces","贪心"]},{"title":"2024.9.28","url":"/2024/09/28/2024-9-28/","content":"LaIS *2200\n没太想出来。\n设 f_i 表示以 i 为结尾的最长子序列长度。\n考虑如何从 j 转移到 i。\n若 a_j\\le a_i，那么直接转移即可。\n若 a_j > a_i，则需要考虑 j 的前驱 k。\n因为需要满足 \\min(a_k,a_j)\\le \\min(a_j,a_i)，即 a_k \\le a_i。\n那么我们贪心的想，让 j 越靠右越好，因为这样前驱 k 的范围就更大。\n那么我们维护一个单调栈，求出每个 i 左侧的第一个 j，使得 a_j > a_i。\n转移用树状数组即可。\n复杂度 O(n\\log n)\nHelping Hiasat *2200\n开到抽象题了。\n第一遍读错题了，没看到每一次都得一样。\n如果没有这个限制的话就很简单了，把相邻两个 1 之间划分成一个区间，找每个区间的众数即可。\n但现在有这个限制，怎么办？\n依旧考虑划分成若干区间，那么两个人可以共存当且仅当两个人从未同时出现过。\n如果两个人不能共存，那么就连一条边。最后求出这个图的最大独立集即可。\n这是一个 NPC 问题。\n不过有结论：原图的最大独立集=补图的最大团。\n最大团可以用 Bron–Kerbosch 算法在 O(2^{\\frac{n}{2}}) 的复杂度内求出。\n复杂度 O(nm^2+2^{\\frac{m}{2}})\nDemiurges Play Again *2200\n首先考虑权值给定怎么做。\n设 f_{u,0/1} 表示 u 点先/后手能取到的值。转移为\n\nf_{u,0}=\\max_{v \\in sub_u} f_{v,1}\n\\\\\nf_{u,1}=\\min_{v \\in sub_u} f_{v,0}然后考虑放权值。\n依旧设 f_{u,0/1}，表示 u 点先/后手能取到的值是该子树内第 f_{u,0/1} 大的数。\n那么转移是类似的，不过变成了第几大。\n对于 f_{u,0}，取 \\min 即可。\n对于 f_{u,1}，下一步由对方取最大值，而无论怎么放权值，对方都有可能不选择某子树。所以问题可以看作我们需要放多少个数进入叶子结点才可以让此时的玩家保证能够取到数。而能取到的最小值就是这些数的最后一个。因为是子树内的第几大，所以可以直接求和。\n综上，转移为\n\nf_{u,0}=\\min_{v \\in sub_u} f_{v,1}\n\\\\\nf_{u,1}=\\sum_{v \\in sub_u} f_{v,0}那么答案分别为 m-f_{1,0}+1,f_{1,1}。\n复杂度 O(n)\n因为有单调性，所以也可以二分变成判定性问题，不过似乎有点多此一举？\nYet Another Array Counting Problem *2300\n开到了笛卡尔树上 dp 板子。\n以下标为键，a_i 为值建立大根笛卡尔树，那么 [l,r] 的最左端最大值位置就是 l,r 在笛卡尔树上的 \\operatorname{lca}。\n那么所有最左端最大值位置都相等，就意味着笛卡尔树的形态相同。\n此时转化为树计数问题。\n设 f_{u,i} 表示 u 取值 1 \\sim i 的方案数。\n左儿子可以填 [1,i-1]，右儿子可以填 [1,i]\n转移就是 f_{u,i}=f_{u,i-1}+f_{ls_u,i-1}\\times f_{rs_u,i}\n复杂度 O(nm)\n","categories":["每日记录"],"tags":["Codeforces","dp"]},{"title":"2024.9.29","url":"/2024/09/29/2024-9-29/","content":"Funny Game *2200\n看了半个小时不会后看题解被嘲讽简单题后破防。\nKirill and Company *2200\n终于做到会的题了。\n看到 k 这么小，直接考虑状压。\n在处理最短路时，我们还要处理出每个点的搭载朋友情况。\n最后就是一个背包。\n复杂度 O((n+m)2^k+f(2^k)^2)\nRailguns *2200\n你指尖跃动的电光，是我此生不变的信仰。\n似乎不太难想？\n首先可以发现，答案上界为 n+m+r，因此可以枚举答案。\n设 f_{i,j,k} 表示第 k 秒时能否到达 (i,j)。转移为\n\nf_{i,j,k}|=(f_{i-1,j,k-1}|f_{i,j-1,k-1}|f_{i,j,k-1})我们在最外层枚举时间，然后 dp 即可。\n至于超电磁炮，我们都已经枚举时间了，那 dp 之前把对应状态直接限制一下就行了。\n复杂度 O(nmr)\n","categories":["每日记录"],"tags":["Codeforces","dp"]},{"title":"笛卡尔树学习笔记","url":"/2024/09/28/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"笛卡尔树是一种二叉树，它既满足二叉搜索树的性质，又满足堆的性质。\n例如 treap，就属于笛卡尔树的一种。\n以下规定：第一键值为满足二叉搜索树的键值，第二键值为满足堆的键值。\n如何构建笛卡尔树\n我们可以用单调栈做到 O(n) 建树。\n我们考虑将下标作为第一键值，权值作为第二键值。\n那么每次我们插入的元素必然在这棵树的右链（右链：即从根节点一直往右子树走，经过的节点形成的链）的末端。\n所以我们可以用栈来维护笛卡尔树的右链。\n假设我们要建一颗大根笛卡尔树。\n设当前位置为 i，前 i-1 个位置已经构建好了。设栈顶元素为 a_{top}。\n我们维护值单调递增的单调栈。\n若 a_i \\le a_{top}，直接将 i 入栈（也就是把 i 挂在右链上）。\n否则一直弹栈，直到栈空或 a_i \\le a_{top}。把最后一个弹出的元素设为 i 的左儿子。\nfor(re int i=1;i&lt;=n;++i)&#123;    int tmp=top;    while(tmp&amp;&amp;a[stk[tmp]]&lt;a[i]) --tmp;    if(tmp) rs[stk[tmp]]=i;    if(tmp&lt;top) ls[i]=stk[tmp+1];    stk[++tmp]=i;    top=tmp;&#125;\n事实上，如果要按某个值作为第一键值，那么按这个值排序即可。\n可以发现，笛卡尔树的根就是 stk_1。\n应用\n笛卡尔树大多用来 dp。\n对原问题转化后，变为笛卡尔树上的 dp 问题。\n而且一般只会用到思想，并不会真把树建出来。\n以及一些直方图似乎也会用到。\n对于直方图类问题，我们常把下标作为第一键值，h_i 作为第二键值建立小根笛卡尔树。\n例题\n[TJOI2011] 树的序\n一道考察笛卡尔树定义的题。\n题目给的很明白了，要按权值当第一键值。\n因为要求字典序最小的生成序列，所以我们把每个数在序列中的位置当作第二键值，然后建小根笛卡尔树即可。\n因为插入顺序是父亲-&gt;左儿子-&gt;右儿子，所以输出先序遍历即可。\n注意输出的是键而不是编号。\nLargest Rectangle in a Histogram\n笛卡尔树求矩形面积板子题。\n我们把下标作为第一键值，h_i 作为第二键值建立小根笛卡尔树。\n枚举点 u，看当 h_u 作为矩形的高度时的最大面积。\n因为我们建的是小根树，所以子树内的点的 h_i 都大于 h_u。\n因为下标是键，所以子树内的点构成一段连续区间。\n那么以 h_u 作为高时的最大面积为 siz_u\\times h_u。\n[COCI2008-2009#4] PERIODNI\n我们考虑把这个多边形转成树。\n受上题启发，我们把下标作为第一键值，h_i 作为第二键值建立小根笛卡尔树。\n\n我们每次找到最低点，分成左右两边，然后递归处理。\n不难发现，这些矩形对应笛卡尔树上的所有节点。\n对于点 u,它代表的长为 siz_u，宽为 h_u-h_{fa}。\n因为两个儿子是分开的，所以可以直接合并，没有影响。\n设 f_{u,i} 表示以 u 为根的子树放了 i 个的方案数，g_{u,i} 表示以 u 为根的子树放了 i 个，且不包括 u 代表的矩形的方案数。\n那么 g 的转移就是背包。\n\ng_{u,i}=\\sum_{j=0}^i f_{ls,j}\\times f_{rs,i-j}至于 f 的转移，就是考虑 u 放几个。\n有结论：大小为 n\\times m 的棋盘，放 k 个互不攻击的车，方案数为 \\binom{n}{k}\\times \\binom{m}{k}\\times k!\n那么枚举子树一共用了几个，剩下的就是自己用的。\n注意子树用了的自己不能用。\n\nf_{u,i}=\\sum_{j=0}^i \\binom{siz_u}{i-j}\\times \\binom{h_u-h_{fa}}{i-j}\\times (i-j)!\\times g_{u,j}复杂度 O(nk^2+n^2)\nYet Another Array Counting Problem\n以下标为第一键值，a_i 为第二键值建立大根笛卡尔树，那么 [l,r] 的最左端最大值位置就是 l,r 在笛卡尔树上的 \\operatorname{lca}。\n那么所有最左端最大值位置都相等，就意味着笛卡尔树的形态相同。\n此时转化为树计数问题。\n设 f_{u,i} 表示 u 取值 1 \\sim i 的方案数。\n左儿子可以填 [1,i-1]，右儿子可以填 [1,i]\n转移就是 f_{u,i}=f_{u,i-1}+f_{ls_u,i-1}\\times f_{rs_u,i}\n复杂度 O(nm)\n","categories":["学习笔记"],"tags":["数据结构"]},{"title":"2024.9.30","url":"/2024/09/30/2024-9-30/","content":"Darth Vader and Tree *2200\n首先考虑暴力。\n设 f_i 表示距离根距离恰好为 i 的数量。转移为\n\nf_i=\\sum_{j=1}^n f_{i-d_j}但观察数据范围，发现 d_i\\le 100，说明不同的 d_i 很少。\n那么只需要对这些不同的 d_i 转移就行了。\n设 num_i=\\sum_{j=1}^n [d_j=i]，那么转移为\n\nf_i=\\sum_{j=1}^V num_j\\times f_{i-j} 这是一个常系数齐次线性递推方程，BM算法矩阵快速幂即可。\n最终答案为 \\sum_{i=1}^x f_i，可以在矩阵里顺便维护一下。\n复杂度 O(V^3\\log x)\nVladik and cards *2200\n容易想到状压。\n但第一个条件感觉很难搞，没法记录每个元素出现次数，怎么办？\n我们可以二分出所有的数字的最小出现次数 mid，那么每个元素出现次数只能为 mid 和 mid+1（经常在错解里想到这种思路，终于在这道题成为正解了）。\n设 f_{i,S} 表示到第 i 个位置，数字出现状态为 S 时，出现次数为 mid+1 的数的最大个数。\n这么设状态是因为，一个数的出现次数只能为 mid 和 mid+1，那肯定让 mid+1 的个数越多越好。\n转移比较简单，看每个数字出现 mid 次还是 mid+1 次即可。\n我们可以把每个数字出现的位置记录下来，方便转移。\n注意每种数字必须连续，也就是出现过后就不能再转移了。\n复杂度 O(2^Vn\\log n)\nTreeland Tour *2200\n树上路径问题直接考虑点分治。\n设当前分治重心为 rt，我们求出从叶子往 rt 走且以 i 结尾的 LIS 和 LDS。\n这个东西怎么求呢？\n每个点都只能从子树转移来，所以问题就是单点加子树查，弄个 dfn 序后线段树维护即可。\n统计答案时，考虑包不包含 rt。\n设 up_i 表示以 i 结尾的 LIS 长度， down_i 表示以 i 结尾的 LDS 长度。\n对 up_i 和 down_i 分别做前缀 max 和后缀 max。\n包含 rt：ans=\\max up_{a_{rt}-1}+down_{a_{rt}+1}+1\n不包含 rt：ans=\\max up_i+down_{i+1}\n然后完了？\n显然没有，因为如果两条路径来自同一颗子树内就寄了。\n那么线段树在维护时，记录最大值和次大值，以及来自哪棵子树即可。\n统计答案时特判一下。\n复杂度 O(n\\log^2 n)\nFelicity’s Big Secret Revealed *2200\n简单性质题。\n不难发现答案 x 不会很大。因为 n\\le 75，所以 x\\le 20。 \n那就考虑状压，设 f_{i,S} 表示这一刀切在 i 前，状态为 S 时的方案数。\n转移就枚举上一刀切在哪。\n转移为 \n\nf_{i,S}=\\sum f_{j,S/T}把 [j,i-1] 组成的数去掉即可。\n答案为 \\sum f_{i,2^j-1}\n复杂度 O(n2^V)\nAbbreviation *2200\n唐唐唐，下次读题能不能读仔细点。\n做了半个小时+看了半天题解才发现翻译里最后一句写着“至多进行一次操作”\n绷不住了。\n那就好做了。枚举缩哪一段区间即可。\n具体的，我们可以先处理出 f_{i,j} 表示 i 和 j 向后匹配的最长长度。\n然后枚举缩哪段区间，然后向后暴力缩就行了。\n复杂度 O(n^3+n|\\sum s_i|)\n代码可参考官方题解。\nThree Pieces *2200\n很厉害的一道题，完全没想出来。\n考虑 dp。\n设 f_{i,j,k,0/1/2} 表示当前在 (i,j)，已经填了 1\\sim k，且当前是 0/1/2 棋子的最小花费。\n但这个 dp 有一个问题：不知道转移顺序。\n所以考虑用最短路转移。\n转移分三种：\n\n换棋子，代价为 inf+1\n移动棋子，代价为 inf\n填数（即 (i,j) 所在的数是下一个数），代价为 0\n\n这里有一个 trick：因为还要求换的次数最小，所以可以设一个极大值，将移动棋子设为 inf，换棋子设为 inf+1，这样就可以做到双关键字了。\n输出答案时，时间就是 ans/inf，换的次数就是 ans\\%inf。\n一共 O(n^4) 个点，O(n^5) 条边。\n","categories":["每日记录"],"tags":["Codeforces","贪心","dp","数据结构"]},{"title":"test","url":"/2024/09/27/test/","content":"\n      \n        446e717b465e46ce3d759c7d83ee23ec74d961b6f6cd4dae4aa33f8a2ba5a28018c33d266866cb2a3247a991f7b2b4e20d0be726f62ca24219c9557ca77c50b836bd42c671ecf3ed5cf7b6404490614cd24193c0aa66b41b72d0590e49a0379480be8b10d5db03119193adce3bfe64c6\n      \n      \n        \n          \n          \n            请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n          \n        \n        \n      \n    \n    "}]