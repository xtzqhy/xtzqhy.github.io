[{"title":"2024.10.10","url":"/posts/b9e27ec5/","content":"代码能力怎么这么弱？代码能力怎么这么弱？代码能力怎么这么弱？\n昨天调题调破防了，忘了写。今天补上。\n【模板】回滚莫队&amp;不删除莫队\n增加是好维护的，删除是不好维护的，考虑回滚莫队。\n可以用栈维护一下，然后栈序撤销。\n但是写挂了，不想调，所以没有代码。\nupd：唐。\n今天把代码补了，发现自己以前唐完了。\n以前我对每个颜色只记录了最左侧的位置，然后一直错。\n事实上应该记录最左侧和最右侧的位置。\n不知道自己怎么做到这么唐的。\n代码事实上很好写。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define pii pair&lt;int,int&gt;#define fi first#define se secondusing namespace std;const int maxn=2e5+10,maxm=500;int n,m,siz,tot;int a[maxn],b[maxn],ans[maxn];int st[maxm],ed[maxm],bel[maxn];int buc[maxn],buc1[maxn],tong[maxn];stack&lt;pair&lt;int,pii&gt;&gt; stk;struct query&#123;    int l,r,id;    inline bool operator &lt; (const query &amp;a)const&#123;        if(bel[l]==bel[a.l]) return r&lt;a.r;        return bel[l]&lt;bel[a.l];    &#125;&#125;q[maxn];inline void init()&#123;    siz=sqrt(n);    tot=n/siz;    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;n) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=n;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i;&#125;inline void solve(int l,int r,int id)&#123;    int res=0;    for(re int i=l;i&lt;=r;++i)&#123;        if(!tong[a[i]]) tong[a[i]]=i;        else res=max(res,i-tong[a[i]]);    &#125;    for(re int i=l;i&lt;=r;++i) tong[a[i]]=0;    ans[id]=res;&#125;inline void add(int x,int &amp;res,bool type)&#123;    if(type) stk.push(&#123;x,&#123;buc[a[x]],buc1[a[x]]&#125;&#125;);    if(!buc[a[x]]) buc[a[x]]=x;    else buc[a[x]]=min(buc[a[x]],x);    if(!buc1[a[x]]) buc1[a[x]]=x;    else buc1[a[x]]=max(buc1[a[x]],x);    res=max(res,buc1[a[x]]-buc[a[x]]);&#125;inline void undo()&#123;    pair&lt;int,pii&gt; tmp=stk.top();stk.pop();    buc[a[tmp.fi]]=tmp.se.fi;    buc1[a[tmp.fi]]=tmp.se.se;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],b[i]=a[i];    sort(b+1,b+n+1);    int len=unique(b+1,b+n+1)-(b+1);    for(re int i=1;i&lt;=n;++i) a[i]=lower_bound(b+1,b+len+1,a[i])-b;    cin&gt;&gt;m;    for(re int i=1;i&lt;=m;++i) cin&gt;&gt;q[i].l&gt;&gt;q[i].r,q[i].id=i;    init();    sort(q+1,q+m+1);    int l=1,r=0,lst=0,mx=0;    for(re int i=1;i&lt;=m;++i)&#123;        if(bel[q[i].l]==bel[q[i].r]) solve(q[i].l,q[i].r,q[i].id);        else&#123;            if(lst^bel[q[i].l])&#123;                memset(buc,0,sizeof buc);                memset(buc1,0,sizeof buc1);                l=ed[bel[q[i].l]]+1,r=ed[bel[q[i].l]];                mx=0,lst=bel[q[i].l];            &#125;            while(r&lt;q[i].r) add(++r,mx,0);            int tmp=mx,l1=l;            while(l1&gt;q[i].l) add(--l1,tmp,1);            while(l1&lt;l) ++l1,undo();            ans[q[i].id]=tmp;        &#125;    &#125;    for(re int i=1;i&lt;=m;++i) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n曼哈顿交易\n首先，你要先读对题。\n题目让求的是出现次数的第k小，不是第k小的出现次数。\n且这个第k小是不去重的。\n因为读错题又挂了半天，呃呃。\n区间查询，容易想到莫队。\n值域上的第k小且要平衡复杂度，容易想到值域分块。\n莫队加值域分块即可。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e5+10,maxm=350;int n,m,siz,tot;int a[maxn],b[maxn],ans[maxn];int st[maxm],ed[maxm],bel[maxn];int cnt1[maxn],cnt2[maxn],cnt3[maxm];struct query&#123;    int l,r,k,id;&#125;q[maxn];inline bool cmp(query a,query b)&#123;return ((a.l/siz)^(b.l/siz))?(a.l/siz)&lt;(b.l/siz):((a.l/siz)&amp;1)?a.r&lt;b.r:a.r&gt;b.r;&#125;inline void init()&#123;    siz=sqrt(n);    tot=n/siz;    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;n) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=n;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i;&#125;inline void add(int x)&#123;    --cnt2[cnt1[x]];    --cnt3[bel[cnt1[x]]];    ++cnt1[x];    ++cnt2[cnt1[x]];    ++cnt3[bel[cnt1[x]]];&#125;inline void del(int x)&#123;    --cnt2[cnt1[x]];    --cnt3[bel[cnt1[x]]];    --cnt1[x];    ++cnt2[cnt1[x]];    ++cnt3[bel[cnt1[x]]];&#125;inline int query(int k)&#123;    int id=0;    for(re int i=1;i&lt;=tot;++i)&#123;        if(k-cnt3[i]&lt;=0)&#123;id=i;break;&#125;        k-=cnt3[i];    &#125;    if(!id) return -1;    for(re int i=st[id];i&lt;=ed[id];++i)&#123;        if(k-cnt2[i]&lt;=0) return i;        k-=cnt2[i];    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],b[i]=a[i];    sort(b+1,b+n+1);    int len=unique(b+1,b+n+1)-(b+1);    for(re int i=1;i&lt;=n;++i) a[i]=lower_bound(b+1,b+len+1,a[i])-b;    for(re int i=1;i&lt;=m;++i) cin&gt;&gt;q[i].l&gt;&gt;q[i].r&gt;&gt;q[i].k,q[i].id=i;    init();    sort(q+1,q+m+1,cmp);    int l=1,r=0;    for(re int i=1;i&lt;=m;++i)&#123;        while(r&lt;q[i].r) add(a[++r]);        while(l&gt;q[i].l) add(a[--l]);        while(r&gt;q[i].r) del(a[r--]);        while(l&lt;q[i].l) del(a[l++]);        ans[q[i].id]=query(q[i].k);    &#125;    for(re int i=1;i&lt;=m;++i) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n美好的每一天\n因为是重排以后的回文串，所以这个限制本质上就是对每种字符的出现次数的奇偶性的限制。\n因为我们只关心奇偶性，所以想到异或。\n因为字符集很小，所以考虑状压。\n我们用一个 26 位的数表示每种字符的出现次数的奇偶性。\n那么对于一个区间，我们可以先把前缀异或求出来，然后就很好得到区间异或值了。\n设 s_i 为前缀异或，询问区间为 [l,r]，那么询问就被转化成了：在 [l-1,r] 种选取两个不同位置 x,y，使得 s_x \\oplus s_y 等于 0 或 2 的若干次方（0 代表每种字符都出现偶数次，2 的若干次方代表只有一种字符出现奇数次）。\n指针移动时的修改就对每种字符都算一下就行。\n和[CQOI2018] 异或序列很像。\n事实上可以二离做到更优复杂度，但是没必要，字符集太小了。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=6e4+10,maxv=(1&lt;&lt;26)+10;int n,m,siz,now;int a[maxn],ans[maxn];int buc[maxv];struct query&#123;    int l,r,id;&#125;q[maxn];inline bool cmp(query a,query b)&#123;return ((a.l/siz)^(b.l/siz))?(a.l/siz)&lt;(b.l/siz):((a.l/siz)&amp;1)?a.r&lt;b.r:a.r&gt;b.r;&#125;inline void add(int x)&#123;    now+=buc[x];    ++buc[x];    for(re int i=0;i&lt;26;++i) now+=buc[x^(1&lt;&lt;i)];&#125;inline void del(int x)&#123;    --buc[x];    now-=buc[x];    for(re int i=0;i&lt;26;++i) now-=buc[x^(1&lt;&lt;i)];&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i)&#123;        char c;        cin&gt;&gt;c;        a[i]=1&lt;&lt;(c-&#x27;a&#x27;);        a[i]^=a[i-1];    &#125;    for(re int i=1;i&lt;=m;++i) cin&gt;&gt;q[i].l&gt;&gt;q[i].r,--q[i].l,q[i].id=i;    siz=sqrt(n);    sort(q+1,q+m+1,cmp);    int l=1,r=0;    for(re int i=1;i&lt;=m;++i)&#123;        while(r&lt;q[i].r) add(a[++r]);        while(l&gt;q[i].l) add(a[--l]);        while(r&gt;q[i].r) del(a[r--]);        while(l&lt;q[i].l) del(a[l++]);        ans[q[i].id]=now;    &#125;    for(re int i=1;i&lt;=m;++i) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n「TERRA-OI R1」神，不惧死亡\n首先得先把这个游戏想明白。\n事实上是个简单贪心。\n不难发现，从小往大消除就是最优的。\n然后手玩样例可以发现，最后得到的最优结果就是最小的出现次数为偶数的数的后继。\n不难理解，因为你可以先把小于这个数的数全消成只剩 1 个，然后把这个数消没，最后得到的就是这个数的后继。\n而且这一定是最优的。\n假设它的后继不是最优，那么我们最后能得到一个比它的后继大的数，那么这就要求这个数的后继和这个数最后必须被消没。\n但因为这个数出现次数为偶数，所以它不能被大数消除的亡语给带没。所以如果我们要把它的后继给消没，那么此时的结果就是这个数。这是不优的。\n如果我们先把这个数消没，那么得到的一定是后继。\n命题得证。\n那么现在问题变成了：单点修改，区间查询值域在一段区间上的数里，最小的出现次数为偶数的数的后继。\n先不考虑修改，容易想到莫队。\n那么需要维护值域上的信息，容易想到值域分块。\n因为要带修，所以带修莫队+值域分块即可。\n值域分块维护每个数的出现次数，每个块内出现次数为偶数的数的个数，每个块的数的个数（去重或不去重都行，没必要去重，但我写的去重）。\n查询时，我写成了查两次：先找出来最小的出现次数为偶数的数，然后找这个数的后继。\n感觉比较好理解。\n但我很唐，所以写出来了一堆唐氏错误：\n\n第一次查完得到 x，第二次应该查 [x+1,r]，我写的 [x+1,n]\n第一次查完得到 x，x 可能等于 r，此时再查 [x+1,r] 会查出抽象东西。\n带修莫队的询问编号编错了，导致答案存到了未知地方。\n\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e5+10,maxm=350;int n,m,m1,m2,siz,tot;int a[maxn],ans[maxn];int st[maxm],ed[maxm],bel[maxn];int cnt1[maxn],cnt2[maxm],cnt3[maxm];struct query1&#123;    int pos,val;&#125;q1[maxn];struct query2&#123;    int l,r,l1,r1,tim,id;&#125;q2[maxn];inline bool cmp(query2 a,query2 b)&#123;return a.l/siz==b.l/siz?a.r/siz==b.r/siz?a.tim&lt;b.tim:a.r&lt;b.r:a.l&lt;b.l;&#125;inline void init()&#123;    siz=sqrt(n);    tot=n/siz;    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;n) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=n;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i;&#125;inline void add(int x)&#123;    if(!cnt1[x]) ++cnt3[bel[x]];    ++cnt1[x];    if(cnt1[x]%2==0) ++cnt2[bel[x]];    else if(cnt1[x]%2==1&amp;&amp;cnt1[x]!=1) --cnt2[bel[x]];&#125;inline void del(int x)&#123;    --cnt1[x];    if(!cnt1[x]) --cnt3[bel[x]];    if(cnt1[x]%2==0&amp;&amp;cnt1[x]) ++cnt2[bel[x]];    else if(cnt1[x]%2==1) --cnt2[bel[x]];&#125;inline void move(int tim,int l,int r,int op)&#123;    int pos=q1[tim].pos,val=q1[tim].val;    if(pos&gt;=l&amp;&amp;pos&lt;=r) del(a[pos]);    a[pos]+=val*op;    if(pos&gt;=l&amp;&amp;pos&lt;=r) add(a[pos]);&#125;inline int query2(int l,int r)&#123;    if(l&gt;r) return -1;    int L=bel[l],R=bel[r];    if(L==R)&#123;        for(re int i=l;i&lt;=r;++i) if(cnt1[i]) return i;    &#125;    else&#123;        for(re int i=l;i&lt;=ed[L];++i) if(cnt1[i]) return i;        for(re int i=L+1;i&lt;=R-1;++i)&#123;            if(cnt3[i])&#123;                for(re int j=st[i];j&lt;=ed[i];++j)&#123;                    if(cnt1[j]) return j;                &#125;            &#125;        &#125;        for(re int i=st[R];i&lt;=r;++i) if(cnt1[i]) return i;    &#125;    return -1;&#125;inline int query(int l,int r)&#123;    int L=bel[l],R=bel[r],pos=0;    if(L==R)&#123;        for(re int i=l;i&lt;=r;++i) if(cnt1[i]%2==0&amp;&amp;cnt1[i])&#123;pos=i;break;&#125;        if(pos) return query2(pos+1,r);    &#125;    else&#123;        for(re int i=l;i&lt;=ed[L];++i) if(cnt1[i]%2==0&amp;&amp;cnt1[i])&#123;pos=i;break;&#125;        if(pos) return query2(pos+1,r);        for(re int i=L+1;i&lt;=R-1;++i)&#123;            if(cnt2[i])&#123;                for(re int j=st[i];j&lt;=ed[i];++j)&#123;                    if(cnt1[j]%2==0&amp;&amp;cnt1[j])&#123;pos=j;break;&#125;                &#125;            &#125;            if(pos) return query2(pos+1,r);        &#125;        for(re int i=st[R];i&lt;=r;++i)if(cnt1[i]%2==0&amp;&amp;cnt1[i])&#123;pos=i;break;&#125;        if(pos) return query2(pos+1,r);    &#125;    return -1;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];    for(re int i=1,op;i&lt;=m;++i)&#123;        cin&gt;&gt;op;        if(op==1) ++m1,cin&gt;&gt;q1[m1].pos&gt;&gt;q1[m1].val;        else ++m2,cin&gt;&gt;q2[m2].l&gt;&gt;q2[m2].r&gt;&gt;q2[m2].l1&gt;&gt;q2[m2].r1,q2[m2].tim=m1,q2[m2].id=m2;    &#125;    siz=pow(n,2.0/3.0);    sort(q2+1,q2+m2+1,cmp);    init();    int l=1,r=0,lst=0;    for(re int i=1;i&lt;=m2;++i)&#123;        while(r&lt;q2[i].r) add(a[++r]);        while(l&gt;q2[i].l) add(a[--l]);        while(r&gt;q2[i].r) del(a[r--]);        while(l&lt;q2[i].l) del(a[l++]);        while(lst&lt;q2[i].tim) move(++lst,l,r,1);        while(lst&gt;q2[i].tim) move(lst--,l,r,-1);        ans[q2[i].id]=query(q2[i].l1,q2[i].r1);    &#125;    for(re int i=1;i&lt;=m2;++i) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n[BJWC2018] 基础匹配算法练习题\n二分图匹配肯定是假的，先转化题意。\n首先，把 a_i+c_j\\le z 转化成 c_j\\le z-a_i。\n令 a_i \\leftarrow z-a_i，转化为则 c_j \\le a_i。\n因为点的顺序不影响匹配，所以按点权从大到小排序，不难发现每个右部点对应的都是一段前缀。\n现在问题转化为：给一个序列，每个点都有一个可供安排的前缀区域，每次区间查询，把该区间的点拿出来，最多能安排几个点。\n首先想到莫队。\n然后这东西想了半天没想出来怎么维护，最后发现可以线段树维护。\n我们维护安排区域上的线段树。\n每个节点上维护三个信息：区间大小（siz），区间内尝试过安排的数的个数（sum），区间内成功安排的数的个数（ans）。\n指针移动时的修改就是单点修改。\n贪心地，我们在这个点可供安排区域的右端点修改。\n若该位置还未被匹配，则该点 sum 和 ans +1，否则只有 sum +1。\n删除是同理的。\n然后考虑怎么合并信息。\n关于合并，sum 直接相加即可。而 ans ，要先把左右相加，然后考虑能否多匹配几个。\n这东西就是 min(左区间空的位置数，右区间多的位置数)，也即是 min(max(0,siz_l-ans_l),sum_r-ans_r)。\n可能会有疑问：为什么不把左边多的给右边？\n因为我们每次都是贪心地把每个点插到自己的区域的右端点，所以肯定是右边会多。\n复杂度 O(m\\sqrt m \\log n)\n然而我用 upper_bound 传了个 greater 预处理每个点的安排区域写挂了，只有 95pts。\n然后把这东西改成线段树上二分就行了。\n呃呃，不知道哪里写错了，看来还是慎用 STL，尤其是不确定这么写会不会出问题的时候。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=6e4+10,maxv=2e5+10;int n,m,Q,z,siz,rt,segcnt;int a[maxv],b[maxn],c[maxv];int ans[maxn];struct query&#123;    int l,r,id;&#125;q[maxn];struct tree&#123;    int ls,rs,sum,ans,siz;&#125;tr[maxv&lt;&lt;1];inline bool cmp(query a,query b)&#123;return ((a.l/siz)^(b.l/siz))?(a.l/siz)&lt;(b.l/siz):((a.l/siz)&amp;1)?a.r&lt;b.r:a.r&gt;b.r;&#125;inline void up(int p)&#123;    tr[p].sum=tr[tr[p].ls].sum+tr[tr[p].rs].sum;    tr[p].ans=tr[tr[p].ls].ans+tr[tr[p].rs].ans;    tr[p].ans+=min(max(0ll,tr[tr[p].ls].siz-tr[tr[p].ls].ans),tr[tr[p].rs].sum-tr[tr[p].rs].ans);&#125;inline void build(int l,int r,int &amp;p)&#123;    if(!p) p=++segcnt;    tr[p].siz=r-l+1;    if(l==r) return;    int mid=(l+r)&gt;&gt;1;    build(l,mid,tr[p].ls),build(mid+1,r,tr[p].rs);&#125;inline void update(int l,int r,int pos,int val,int p)&#123;    if(l==r)&#123;        if(z-pos&lt;a[l]) return;        if(!tr[p].sum) tr[p].ans=1;        tr[p].sum+=val;        if(!tr[p].sum) tr[p].ans=0;        return;    &#125;    int mid=(l+r)&gt;&gt;1;    if(z-pos&lt;a[mid+1]) update(l,mid,pos,val,tr[p].ls);    else update(mid+1,r,pos,val,tr[p].rs);    up(p);&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;std.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;z;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];    for(re int i=1;i&lt;=m;++i) cin&gt;&gt;b[i];    sort(a+1,a+n+1);    cin&gt;&gt;Q;    for(re int i=1;i&lt;=Q;++i) cin&gt;&gt;q[i].l&gt;&gt;q[i].r,q[i].id=i;    siz=sqrt(m);    sort(q+1,q+Q+1,cmp);    build(1,n,rt);    int l=1,r=0;    for(re int i=1;i&lt;=Q;++i)&#123;        while(r&lt;q[i].r) update(1,n,b[++r],1,1);        while(l&gt;q[i].l) update(1,n,b[--l],1,1);        while(r&gt;q[i].r) update(1,n,b[r--],-1,1);        while(l&lt;q[i].l) update(1,n,b[l++],-1,1);        ans[q[i].id]=tr[1].ans;    &#125;    for(re int i=1;i&lt;=Q;++i) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n","categories":["每日记录"],"tags":["数据结构","莫队","分块"]},{"title":"2024.10.17","url":"/posts/2786eb66/","content":"没新东西学了这两天都不知道该干啥···\n只能写点简单杂题了。\n你说得对，但是距离 CSP 还剩 8 天。\nTop Secret Task *2300\n第一遍读题没看到交换的是两个相邻的数，然后疑惑半天为什么只敢开这点数据范围。\n首先 s 的范围是假的，因为冒泡排序上界次数为 \\frac {n(n-1)}{2}。\n然后猜一把复杂度 O(n^4)，正好 n 一维，k 一维，s 一维，够了。\n设 f_{i,j,k} 表示前 i 个数，把 j 个数加进贡献，操作了 k 次的最小值。\n转移考虑选不选第 i 个数：\n\nf_{i,j,k}=f_{i-1,j,k}\n\\\\\nf_{i,j,k}=f_{i-1,j-1,k-(i-j)}空间炸了，滚动数组一下。\n复杂度 O(n^4)\n然后我去学高维前缀和了，所以只有一道题。\n","categories":["每日记录"],"tags":["Codeforces","dp"]},{"title":"2024.10.2","url":"/posts/12c9edda/","content":"Team Building *2300\n首先可以想到暴力 dp。\n设 f_{i,j,S} 表示前 i 个人，选了 j 个观众，队伍的选择状态为 S。\n复杂度是炸的。\n但仔细想想，我们真的要记这么多状态吗？\n如果你把这道题想成一个普通的背包，那就错了，因为这题很特殊。\n每个物品的体积都是 1。\n这说明此时贪心是正确的。\n我们按观众值降序排序，那么对于观众值而言，一定是全选前面的更优。\n设 f_{i,S} 表示前 i 个人，队伍的选择状态为 S，num_S 为 S 里 1 的个数。\n转移时，如果当前观众人数小于 k，那么一定是让他当观众最优。\n因为观众是能选就选的，所以观众人数很容易得出，就是 i-num_S。\n复杂度 O(n2^p)\nMinimal Labels *2300\n第一眼看到以后以为是拓扑板子，直到看到第三个样例。\n经过手玩可以发现，我们应该每次都先填未填的点里编号最小的点，这样才能让字典序更小。\n但是编号最小的点可能被一些点指向，所以要先把前面的那些点给填上。\n前面那些点又构成一张新图，这就是一个子问题了，递归解决即可。\n找前面点可以建反图往回跑即可。\n复杂度？\n然而正解是建反图后拓扑，然后倒序编号。\n我们刚才的思路都是正着来的，那为什么倒着才是对的呢？\n正解是对的比较好理解，但感性理解一下，我们的做法似乎和倒着做是一样的？\nTrains and Statistic *2300\n类似 Floyd，对于两个点，我们要么一步到，要么找一个中转点。\n而这道题不需要 O(n^3) 的原因是：每个点能到的区间是一定的。\n所以我们可以贪心。\n既然一步走不到，那肯定走的越远越好。\n所以我们一定会从 i 走到 [i+1,a_i] 里 a 最大点 j。\n设 f_i=\\sum_{j=i+1}^n p_{i,j}。\n那么 f_i 只会从 f_j 转移来。\n转移为\n\nf_i=f_j+n+j-a_i-i首先让编号 >j 的点强制从 j 转移过去，那么这部分答案是 f_j+n-j。\n这会把 [j+1,a_i] 里的点多算一步，那么减去 a_i-(j+1)+1。\n最后加上 [i+1,j] 的点，他们只需要走一步，是 j-(i+1)+1。\n合起来就是 f_j+n+j-a_i-i。\n求 j 是一个 RMQ 问题，随便做。\n复杂度 O(n\\log n)\nMonster Invaders *2300\n又读错题。\n贪心肯定是很难贪的。考虑 dp。\n但是 dp 是不是有后效性？毕竟可以从前面过来，还可以从后面过来。\n难道要高斯消元解方程组？复杂度也接受不了啊。\n但你仔细想想，我们真的会从很后面的地方过来吗？\n显然不会。\n如果我们现在在 i，剩个 boss 差一血没打死，然后被强制移到了 i+1。\n假设我们一直往后打，直到  j 才往回走，把 i 剩下的 boss 打死。\n那么我们为什么不在被迫移动到 i+1 的时候就直接回去把 boss 打死？这肯定更优。\n想明白了这个，剩下就很简单了。\n然后考虑用什么方式把 i 清完。\n这里我读错题了，没看到 r_1 \\le r_2 \\le r_3。\n既然这样，那么每个房间只有这几种方法：\n\n手枪打小怪，AWP 打 boss。\n用激光枪（或手枪）对所有人各打一点伤害，被迫移动后，再移动回来，然后手枪解决 boss。\n\n转移很简单。\n注意最后终点可能是 n-1，也可能是 n。\nKeshi in Search of AmShZ *2300\n竟然是原理题。\n读完题后又瞬间想到一个假贪心：把最短路以外的边封掉，然后强制走最短路。\n显然不正确。我们可以少封一些边，然后走最长路，这样代价可以更小。\n考虑这张图确定了下来，那么对方一定会走最长路。\n设 f_u 表示 u 到 n 的最大代价。\n考虑一条边 (u,v)，如果我们经过了这条边，那么说明经过 u 必须是一条最长路。\n那么我们必须把比 u 还长的删掉。即转移为\n\nf_u=\\min_{v \\in to_u} (f_v+1+\\sum_{v'\\in to_u} [f_{v'}>f_v])直接转移复杂度是炸的。\n那么能不能在反图上跑时转移呢？\n但是如果倒着转移的话，无法确定 \\sum_{v'\\in to_u} [f_{v'}>f_v]) 的值。\n所以我们钦定转移顺序，让 f_v 从小到大转移，这样 \\sum_{v'\\in to_u} [f_{v'}>f_v]) 就满足了单调性。\n用优先队列维护最小即可。\n复杂度 O((n+m)\\log m)\n","categories":["每日记录"],"tags":["Codeforces","dp","贪心"]},{"title":"2024.10.29","url":"/posts/eb1395a2/","content":"[蓝桥杯 2021 国 AB] 翻转括号序列合法括号序列常见翻译：\n把左括号当成 1，右括号当成 -1.\n\n序列和为 0.\n所有前缀的和 \\ge 0（转化为最小前缀和等于 0）\n\n可以发现，最小前缀和这东西是有一点单调性的（在左端点固定时，最小前缀和关于右端点单调不增），所以可以考虑二分。\n线段树上维护：\n\n和\n最小前缀和\n所有最小前缀和对应端点中最靠右者\n\n因为还要区间取反，所以对应的维护最大前缀和以及所有最大前缀和对应端点中最靠右者。\n直接做是两个 \\log 的，把二分换成线段树上二分是 \\log n 的。\n[省选联考 2020 A/B 卷] 冰火战士新科技：树状数组上倍增。\n看完题后第一个想法是二分一个温度，然后数据结构维护一下求和。\n首先，在温度固定的情况下，双方消耗的总能量之和为总能量小的那一方的二倍。\n所以为了让和最大，我们希望双方的总能量更接近。\n我们可以把双方抽象成两个总能量关于温度变化的函数，那么我们想找的就是函数的交点。\n但这两个函数是离散的，所以我们二分找到最优点。\n设 ice_i 表示冰系的总能量，fire_i 表示火系的总能量。\n我们二分找到最大的 i，使得 ice_i \\le fire_i，再二分找到最小的 i，使得 ice_i \\ge fire_i。\n但是直接二分是两个 \\log，所以把二分换成树状数组上倍增。\n[USACO16FEB] Load Balancing P看到最大值最小想到二分答案。\n但这个二分事实上是没有意义的，因为可行性也不好做：我们依旧要找到最优情况。所以直接考虑最优性怎么做。\n我们枚举水平方向的线，用树状数组分别维护上下两部分的奶牛数。\n然后我们想找出来最优的竖直方向的线。\n设 suml_i 为左侧两部分的最大值，sumr_i 为右侧两部分的最大值。\n因为我们想让每个部分尽量平均，所以我们二分找到最大的i ，使得 suml_i \\le sumr_i ，再二分找到最小的 i，使得 suml_i \\ge sumr_i。\n只有这两条线会取到最优。\n但是直接二分是两个 \\log，所以把二分换成树状数组上倍增。\n感觉和上一道题很像。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define lb(x) (x&amp;(-x))using namespace std;const int maxn=1e5+10,inf=1e18;int n,cntx,cnty;int tmpx[maxn],tmpy[maxn];int buc1[maxn],buc2[maxn];struct point&#123;    int x,y;    inline bool operator &lt; (const point &amp;a)const&#123;        if(y==a.y) return x&lt;a.x;        return y&lt;a.y;    &#125;&#125;t[maxn];struct BIT&#123;    int tr[maxn];    inline void add(int x,int val)&#123;while(x&lt;=cntx) tr[x]+=val,x+=lb(x);&#125;    inline int query(int x)&#123;int res=0;while(x) res+=tr[x],x-=lb(x);return res;&#125;&#125;a,b;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif\t    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n;    for(re int i=1;i&lt;=n;++i)&#123;        cin&gt;&gt;t[i].x&gt;&gt;t[i].y;        tmpx[i]=t[i].x,tmpy[i]=t[i].y;    &#125;    sort(tmpx+1,tmpx+n+1);sort(tmpy+1,tmpy+n+1);    cntx=unique(tmpx+1,tmpx+n+1)-(tmpx+1);    cnty=unique(tmpy+1,tmpy+n+1)-(tmpy+1);    for(re int i=1;i&lt;=n;++i)&#123;        t[i].x=lower_bound(tmpx+1,tmpx+cntx+1,t[i].x)-tmpx;        t[i].y=lower_bound(tmpy+1,tmpy+cnty+1,t[i].y)-tmpy;    &#125;    sort(t+1,t+n+1);    for(re int i=1;i&lt;=n;++i)&#123;        a.add(t[i].x,1);        ++buc1[t[i].x];    &#125;    int sum1=n,sum2=0,ans=inf,now=1;    for(re int i=1;i&lt;=cnty;++i)&#123;        while(now&lt;=n&amp;&amp;t[now].y&lt;i)&#123;            a.add(t[now].x,-1),b.add(t[now].x,1);            --sum1,++sum2;            --buc1[t[now].x],++buc2[t[now].x];            ++now;        &#125;        int pos=0,s1=0,s2=0;        for(re int j=__lg(cntx);j&gt;=0;--j)&#123;            if(pos+(1&lt;&lt;j)&lt;=cntx&amp;&amp;max(s1+a.tr[pos+(1&lt;&lt;j)],s2+b.tr[pos+(1&lt;&lt;j)])&lt;=max(sum1-(s1+a.tr[pos+(1&lt;&lt;j)]),sum2-(s2+b.tr[pos+(1&lt;&lt;j)])))&#123;                s1+=a.tr[pos+(1&lt;&lt;j)];                s2+=b.tr[pos+(1&lt;&lt;j)];                pos+=(1&lt;&lt;j);            &#125;        &#125;        ans=min(ans,max(&#123;s1,s2,sum1-s1,sum2-s2&#125;));        if(pos&lt;cntx)&#123;            s1+=buc1[pos+1],s2+=buc2[pos+1];            ans=min(ans,max(&#123;s1,s2,sum1-s1,sum2-s2&#125;));        &#125;    &#125;    cout&lt;&lt;ans;    return 0;&#125;\nGreedy Shopping *2600对于操作一，可能第一眼感觉要上吉司机。\n但题目保证了序列单调不增，所以直接二分找到第一个小于 y 的位置即可。\n把二分换成线段树上二分可以做到一个 \\log。\n对于操作二，第一想法是每次都二分找到第一个小于等于 y 的位置，然后从这个位置向后二分一个长度，看最多能取多少。\n这是三个 \\log 的。\n但如果把第一个二分换成线段树上二分，那么这是两个 \\log 的。\n总复杂度 O(n\\log^2 n)\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define ls(p) tr[p].ls#define rs(p) tr[p].rsusing namespace std;const int maxn=2e5+10;int n,m,rt,segcnt;int a[maxn];struct tree&#123;    int ls,rs;    int sum,mn,tag;&#125;tr[maxn&lt;&lt;1];inline void up(int p)&#123;    tr[p].sum=tr[ls(p)].sum+tr[rs(p)].sum;    tr[p].mn=min(tr[ls(p)].mn,tr[rs(p)].mn);&#125;inline void cov(int l,int r,int val,int p)&#123;    tr[p].mn=tr[p].tag=val;    tr[p].sum=(r-l+1)*val;&#125;inline void down(int l,int r,int mid,int p)&#123;    if(tr[p].tag)&#123;        cov(l,mid,tr[p].tag,ls(p));        cov(mid+1,r,tr[p].tag,rs(p));        tr[p].tag=0;    &#125;&#125;inline void build(int l,int r,int &amp;p)&#123;    p=++segcnt;    if(l==r)&#123;tr[p].sum=tr[p].mn=a[l];return;&#125;    int mid=(l+r)&gt;&gt;1;    build(l,mid,ls(p)),build(mid+1,r,rs(p));    up(p);&#125;inline void update(int l,int r,int L,int R,int val,int p)&#123;    if(l&gt;=L&amp;&amp;r&lt;=R)&#123;cov(l,r,val,p);return;&#125;    int mid=(l+r)&gt;&gt;1;    down(l,r,mid,p);    if(L&lt;=mid) update(l,mid,L,R,val,ls(p));    if(R&gt;mid) update(mid+1,r,L,R,val,rs(p));    up(p);&#125;inline int query1(int l,int r,int val,int p)&#123;    if(l==r)&#123;        if(tr[p].sum&lt;val) return l;        return 1926081719491001071;    &#125;    int mid=(l+r)&gt;&gt;1;    down(l,r,mid,p);    if(tr[ls(p)].mn&lt;val) return query1(l,mid,val,ls(p));    else return query1(mid+1,r,val,rs(p));&#125;inline int query2(int l,int r,int L,int R,int &amp;w,int p)&#123;    if(l&gt;R||r&lt;L||w&lt;tr[p].mn) return 0;    if(l&gt;=L&amp;&amp;r&lt;=R&amp;&amp;w&gt;=tr[p].sum)&#123;        w-=tr[p].sum;        return r-l+1;    &#125;    int mid=(l+r)&gt;&gt;1,res=0;    down(l,r,mid,p);    if(L&lt;=mid) res+=query2(l,mid,L,R,w,ls(p));    if(R&gt;mid) res+=query2(mid+1,r,L,R,w,rs(p));    return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif\t    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];    build(1,n,rt);    int op,x,y;    while(m--)&#123;        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;        if(op==1)&#123;            int pos=query1(1,n,y,1);            if(pos&lt;=x) update(1,n,pos,x,y,1);        &#125;        else cout&lt;&lt;query2(1,n,x,n,y,1)&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\nFriends and Subsequences *2100简单题。\n对于一个固定的左端点 l，不难发现 \\max 和 \\min 都有单调性。\n所以想到二分，然后用 ST 表查最值即可。\nHdu 4391 Paint The Wall读完题后第一想法是对每个颜色开一颗线段树，然后分别维护。\n对于操作一，我们用 set 维护所有颜色段。\n每一次区间推平，我们都暴力的把区间里的所有颜色段修改掉，然后加进去一个新的颜色段。\n听起来很暴力，但均摊复杂度是对的。\n代码有一车细节，写吐了。\n这就是珂朵莉吧？\n好像也不太是。\n复杂度 O(n\\log n)\n#include&quot;bits/stdc++.h&quot;#define re register#define ls(p) tr[p].ls#define rs(p) tr[p].rsusing namespace std;const int maxn=1e5+10,maxm=1e7+10;int n,m,segcnt,cnt;int a[maxn],tmp[maxn&lt;&lt;1];int rt[maxn];struct tree&#123;    int ls,rs;    int sum,tag;&#125;tr[maxm];struct Query&#123;    int op,l,r,c;&#125;q[maxn];struct line&#123;    int l,r,c;    inline bool operator &lt; (const line &amp;a)const&#123;        if(r==a.r) return l&lt;a.l;        return r&lt;a.r;    &#125;&#125;;set&lt;line&gt; s;inline void up(int p)&#123;tr[p].sum=tr[ls(p)].sum+tr[rs(p)].sum;&#125;inline void add(int l,int r,int val,int p)&#123;    tr[p].tag+=val;    tr[p].sum+=(r-l+1)*val;&#125;inline void down(int l,int r,int mid,int p)&#123;    if(tr[p].tag)&#123;        if(!ls(p)) ls(p)=++segcnt;        if(!rs(p)) rs(p)=++segcnt;        add(l,mid,tr[p].tag,ls(p));        add(mid+1,r,tr[p].tag,rs(p));        tr[p].tag=0;    &#125;&#125;inline void update(int l,int r,int L,int R,int val,int &amp;p)&#123;    if(!p) p=++segcnt;    if(l&gt;=L&amp;&amp;r&lt;=R)&#123;add(l,r,val,p);return;&#125;    int mid=(l+r)&gt;&gt;1;    down(l,r,mid,p);    if(L&lt;=mid) update(l,mid,L,R,val,ls(p));    if(R&gt;mid) update(mid+1,r,L,R,val,rs(p));    up(p);&#125;inline int query(int l,int r,int L,int R,int p)&#123;    if(!p) return 0;    if(l&gt;=L&amp;&amp;r&lt;=R) return tr[p].sum;    int mid=(l+r)&gt;&gt;1,res=0;    down(l,r,mid,p);    if(L&lt;=mid) res+=query(l,mid,L,R,ls(p));    if(R&gt;mid) res+=query(mid+1,r,L,R,rs(p));    return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif\t    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],tmp[++cnt]=a[i];    for(re int i=1;i&lt;=m;++i)&#123;        cin&gt;&gt;q[i].op&gt;&gt;q[i].l&gt;&gt;q[i].r&gt;&gt;q[i].c;        ++q[i].l,++q[i].r;        tmp[++cnt]=q[i].c;    &#125;    sort(tmp+1,tmp+cnt+1);    cnt=unique(tmp+1,tmp+cnt+1)-(tmp+1);    for(re int i=1;i&lt;=n;++i) a[i]=lower_bound(tmp+1,tmp+cnt+1,a[i])-tmp;    for(re int i=1;i&lt;=m;++i) q[i].c=lower_bound(tmp+1,tmp+cnt+1,q[i].c)-tmp;    for(re int i=1;i&lt;=n;++i) update(1,n,i,i,1,rt[a[i]]),s.insert(&#123;i,i,a[i]&#125;);    for(re int i=1;i&lt;=m;++i)&#123;        if(q[i].op==1)&#123;            set&lt;line&gt;::iterator it1=s.lower_bound(&#123;-1,q[i].l,0&#125;),it2=s.lower_bound(&#123;-1,q[i].r,0&#125;);            if(it1==it2)&#123;                update(1,n,max(q[i].l,it1-&gt;l),min(q[i].r,it1-&gt;r),-1,rt[it1-&gt;c]);                update(1,n,max(q[i].l,it1-&gt;l),min(q[i].r,it1-&gt;r),1,rt[q[i].c]);                if(it1-&gt;l&lt;q[i].l)&#123;                    line p1=&#123;it1-&gt;l,q[i].l-1,it1-&gt;c&#125;;                    s.insert(p1);                &#125;                if(it1-&gt;r&gt;q[i].r)&#123;                    line p2=&#123;q[i].r+1,it1-&gt;r,it1-&gt;c&#125;;                    s.insert(p2);                &#125;                s.erase(it1),s.insert(&#123;q[i].l,q[i].r,q[i].c&#125;);                continue;            &#125;            ++it1;            for(auto it=it1;it!=it2;++it)&#123;                update(1,n,it-&gt;l,it-&gt;r,-1,rt[it-&gt;c]);                update(1,n,it-&gt;l,it-&gt;r,1,rt[q[i].c]);            &#125;            it1=s.erase(it1,it2);            --it1;            if(it1-&gt;l&lt;q[i].l)&#123;                line p1=&#123;it1-&gt;l,q[i].l-1,it1-&gt;c&#125;;                update(1,n,q[i].l,it1-&gt;r,-1,rt[it1-&gt;c]);                update(1,n,q[i].l,it1-&gt;r,1,rt[q[i].c]);                s.erase(it1),s.insert(p1);            &#125;            else&#123;                update(1,n,q[i].l,it1-&gt;r,-1,rt[it1-&gt;c]);                update(1,n,q[i].l,it1-&gt;r,1,rt[q[i].c]);                s.erase(it1);            &#125;            if(it2-&gt;r&gt;q[i].r)&#123;                line p2=&#123;q[i].r+1,it2-&gt;r,it2-&gt;c&#125;;                update(1,n,it2-&gt;l,q[i].r,-1,rt[it2-&gt;c]);                update(1,n,it2-&gt;l,q[i].r,1,rt[q[i].c]);                s.erase(it2),s.insert(p2);            &#125;            else&#123;                update(1,n,it2-&gt;l,q[i].r,-1,rt[it2-&gt;c]);                update(1,n,it2-&gt;l,q[i].r,1,rt[q[i].c]);                s.erase(it2);            &#125;            s.insert(&#123;q[i].l,q[i].r,q[i].c&#125;);        &#125;\t        else cout&lt;&lt;query(1,n,q[i].l,q[i].r,rt[q[i].c])&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\nHdu 5213 Lucky简单莫队。\n两个区间分别选数不好做，差分一下。\n如果只从一个区间选数，那么很好做。\n然后我们把两个区间分别拆成 [l_1,r_2]-[l_1,l_2-1]-[r_1+1,r_2]+[r_1+1,l_2-1] 即可。\n没看到多测和访问负下标为我贡献了两发罚时。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=3e4+10;int n,k,m,cnt,siz,now;int a[maxn],buc[maxn],ans[maxn];struct query&#123;    int l,r,op,id;&#125;q[maxn&lt;&lt;2];inline bool cmp(query a,query b)&#123;return ((a.l/siz)^(b.l/siz))?(a.l/siz)&lt;(b.l/siz):((a.l/siz)&amp;1)?a.r&lt;b.r:a.r&gt;b.r;&#125;inline void add(int x)&#123;    ++buc[x];    if(x&lt;=k) now+=buc[k-x];&#125;inline void del(int x)&#123;    --buc[x];    if(x&lt;=k) now-=buc[k-x];&#125;inline void clear()&#123;    cnt=now=0;    memset(buc,0,sizeof buc);    memset(ans,0,sizeof ans);&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif\t    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    while(cin&gt;&gt;n)&#123;        clear();        cin&gt;&gt;k;        for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];        cin&gt;&gt;m;        for(re int i=1,l1,r1,l2,r2;i&lt;=m;++i)&#123;            cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;            q[++cnt]=&#123;l1,r2,1,i&#125;;            q[++cnt]=&#123;l1,l2-1,-1,i&#125;;            q[++cnt]=&#123;r1+1,r2,-1,i&#125;;            q[++cnt]=&#123;r1+1,l2-1,1,i&#125;;        &#125;        siz=sqrt(n);        sort(q+1,q+cnt+1,cmp);        int l=1,r=0;        for(re int i=1;i&lt;=cnt;++i)&#123;            while(r&lt;q[i].r) add(a[++r]);            while(l&gt;q[i].l) add(a[--l]);            while(r&gt;q[i].r) del(a[r--]);            while(l&lt;q[i].l) del(a[l++]);            ans[q[i].id]+=now*q[i].op;        &#125;        for(re int i=1;i&lt;=m;++i) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n","categories":["每日记录"],"tags":["数据结构"]},{"title":"2024.10.23","url":"/posts/bc67cbc/","content":"Day -3\n最近都不知道写什么题···\n啥也不会啥也不想写···\n请注意，以下有大量口胡内容。\n总结一下最近写的杂题\n[湖南集训] Clever Rabbit首先手玩样例，可以发现答案非常少。\n然后打了一个小表，发现答案确实非常少。\n因为 n\\le 30，所以考虑打表。\n这里有一个性质：如果两个数字构成的可重集相同，则 f(x) 值一样。\n所以可以直接枚举集合，一共有 \\binom {n+10}{10} 个。\n然后高精算一下答案，把表打出来即可。\n分数统计无聊题。\n询问一前缀和，询问二离线下来回滚莫队，询问三 ST 表。\n没删 define int long long 被卡空间，导致没一遍过，气。\n[HEOI2014] 大工程看到保证关键点总数想到虚树。\n建完虚树以后就是个简单树形 dp。\n询问一就是经典的 \\sum_{i=1}^n\\sum_{j=i+1}^n dis(i,j)。\n做法是把贡献拆成每条边的贡献，统计每条边的经过次数。\n询问二三就是树上最短路径长和树的直径。\n注意虚树上边的边权是什么。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e6+10,inf=1e18;int n,m,cnt,tim,num,ans,mn,mx,len;int head[maxn];int key[maxn],a[maxn&lt;&lt;1];int f[maxn][3];bitset&lt;maxn&gt; vis;vector&lt;int&gt; g[maxn];struct edge&#123;    int to,nxt;&#125;e[maxn&lt;&lt;1];struct node&#123;    int fa,siz,dep,top,hson,dfn;&#125;t[maxn];inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void dfs1(int u,int fa)&#123;    t[u].fa=fa,t[u].dep=t[fa].dep+1,t[u].siz=1;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(v==fa) continue;        dfs1(v,u);        t[u].siz+=t[v].siz;        if(!t[u].hson||t[v].siz&gt;t[t[u].hson].siz) t[u].hson=v;    &#125;&#125;inline void dfs2(int u,int top)&#123;    t[u].top=top,t[u].dfn=++tim;    if(!t[u].hson) return;    dfs2(t[u].hson,top);    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(v==t[u].fa||v==t[u].hson) continue;        dfs2(v,v);    &#125;&#125;inline int lca(int u,int v)&#123;    while(t[u].top!=t[v].top)&#123;        if(t[t[u].top].dep&lt;t[t[v].top].dep) swap(u,v);        u=t[t[u].top].fa;    &#125;    return t[u].dep&lt;t[v].dep?u:v;&#125;inline bool cmp(int x,int y)&#123;return t[x].dfn&lt;t[y].dfn;&#125;inline void build()&#123;    sort(key+1,key+num+1,cmp);    len=0;    for(re int i=1;i&lt;num;++i)&#123;        a[++len]=key[i];        a[++len]=lca(key[i],key[i+1]);    &#125;    a[++len]=key[num];    a[++len]=1;    sort(a+1,a+len+1,cmp);    len=unique(a+1,a+len+1)-(a+1);    for(re int i=1;i&lt;len;++i)&#123;        int lc=lca(a[i],a[i+1]);        g[lc].push_back(a[i+1]),g[a[i+1]].push_back(lc);    &#125;&#125;inline void dfs(int u,int fa)&#123;    t[u].siz=vis[u];    if(vis[u]) f[u][1]=f[u][2]=0;    else f[u][1]=inf,f[u][2]=-inf;    for(auto v:g[u])&#123;        if(v==fa) continue;        dfs(v,u);        int w=t[v].dep-t[u].dep;        t[u].siz+=t[v].siz;        ans+=w*t[v].siz*(num-t[v].siz);        mn=min(mn,f[u][1]+f[v][1]+w),mx=max(mx,f[u][2]+f[v][2]+w);        f[u][1]=min(f[u][1],f[v][1]+w),f[u][2]=max(f[u][2],f[v][2]+w);    &#125;    g[u].clear();&#125;inline void solve()&#123;    build();    ans=0,mn=inf,mx=-inf;    dfs(1,0);    cout&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;mn&lt;&lt;&quot; &quot;&lt;&lt;mx&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n;    for(re int i=1,u,v;i&lt;n;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    dfs1(1,0),dfs2(1,1);    cin&gt;&gt;m;    while(m--)&#123;        cin&gt;&gt;num;        for(re int i=1;i&lt;=num;++i) cin&gt;&gt;key[i],vis[key[i]]=1;        solve();        for(re int i=1;i&lt;=num;++i) vis[key[i]]=0;    &#125;    return 0;&#125;\n[SCOI2016] 美味异或问题基本就三个方向：按位考虑，01trie，线性基。\n如果没有这个加 x_i，那这是可持久化trie模板。\nupd：可持久化trie好像也能做？不太会，还是按位考虑好想。\n但现在有 x_i，所以只能按位考虑。\n我们从高位到低位贪心。\n设前面位累计的答案为 ans，然后考虑当前位情况。\n设当前考虑到第 k 位。\n若当前位 b_i 位为 1，则我们希望 a_j+x_i 当前位为 0。\n那么 a_j+x_i\\in [ans,ans+2^k-1]。\n若当前位 b_i 位为 0，则我们希望 a_j+x_i 当前位为 1。\n那么 a_j+x_i\\in [ans+2^k,ans+2^{k+1}-1]。\n如果这一位能找到合法的 a_j，那么 ans 就加上 2^k。\n但这为什么是对的？为什么不会在低位的区间里找一个合法的 a_j，但它从未出现在高位的区间里过？\n如果你仔细想，你会发现如果高位有一位选到了合法值，那么低位的区间会变小。\n也就是说，区间大小是单调不增的。\n那么如果你在低位的区间里找到了一个合法值，那么它一定也出现在高位的区间里过。\n那么现在问题变为了序列上在 [l,r] 内，值域在 [L,R] 内的信息。\n因为要求在线，所以需要主席树上区间二分。\n当然树套树也行，但复杂度两个 \\log，太劣了。\n如果题目能离线，那么莫队+值域分块一般也能做。\n复杂度 O(n\\log^2 V)\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e5+10,lgn=30,V=1e5;int n,m,segcnt;int rt[maxn];struct tree&#123;    int ls,rs,sum;&#125;tr[maxn*lgn];inline void up(int p)&#123;tr[p].sum=tr[tr[p].ls].sum+tr[tr[p].rs].sum;&#125;inline void update(int l,int r,int pos,int &amp;p1,int p2)&#123;    p1=++segcnt;    tr[p1]=tr[p2];    if(l==r)&#123;++tr[p1].sum;return;&#125;    int mid=(l+r)&gt;&gt;1;    if(pos&lt;=mid) update(l,mid,pos,tr[p1].ls,tr[p2].ls);    else update(mid+1,r,pos,tr[p1].rs,tr[p2].rs);    up(p1);&#125;inline bool query(int l,int r,int L,int R,int p1,int p2)&#123;    if(tr[p1].sum==tr[p2].sum) return 0;    int mid=(l+r)&gt;&gt;1;    if(l&gt;=L&amp;&amp;r&lt;=R)&#123;        if(l==r) return 1;        bool res=query(l,mid,L,R,tr[p1].ls,tr[p2].ls);        if(res) return 1;        else return query(mid+1,r,L,R,tr[p1].rs,tr[p2].rs);    &#125;    else&#123;        if(L&lt;=mid)&#123;            bool res=query(l,mid,L,R,tr[p1].ls,tr[p2].ls);            if(res) return 1;\t        &#125;        if(R&gt;mid)&#123;            bool res=query(mid+1,r,L,R,tr[p1].rs,tr[p2].rs);            if(res) return 1;        &#125;        return 0;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif\t    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1,x;i&lt;=n;++i)&#123;        cin&gt;&gt;x;        update(0,V,x,rt[i],rt[i-1]);    &#125;    for(re int i=1,ans,b,x,l,r;i&lt;=m;++i)&#123;        cin&gt;&gt;b&gt;&gt;x&gt;&gt;l&gt;&gt;r;        ans=0;        for(re int j=17,L,R,op;j&gt;=0;--j)&#123;            if((b&gt;&gt;j)&amp;1) L=ans-x,R=ans+(1&lt;&lt;j)-1-x,op=0;            else L=ans+(1&lt;&lt;j)-x,R=ans+(1&lt;&lt;(j+1))-1-x,op=1;            if(!query(0,V,max(0ll,L),min(R,V),rt[l-1],rt[r])) op^=1;            ans+=(op&lt;&lt;j);        &#125;        cout&lt;&lt;(ans^b)&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n[SDOI2013] 森林看到链上 kth 想到主席树，看到动态加边想到 LCT。\n但这俩没法同时维护。\n所以考虑每个点维护一颗主席树，然后合并时启发式合并。\n然后把链上 kth 做一下树上差分，同时查四颗主席树然后合并答案即可。\n但有个问题，怎么动态求 lca？\n维护 LCT 即可。\n当然也可以倍增，在启发式合并时重构倍增数组即可。\n动态 lca 模板：DYNALCA - Dynamic LCA\n不会写 LCT 了，悲。\n[HNOI2015] 接水果 树套树和整体二分我都不会啊？只能写无脑莫队了。\n查 kth 直接值域分块。\n注意：在一条链的两个点都被加进来时，这条链的权值才能算进来。\n没了。\nupd1：补题的时候 20 分钟写完，真的很好写啊，吊打同学写的整体二分了，还得调半天。\nupd2：唐，这个莫队的复杂度错完了，竟然能让我草过去，大家还是写正解整体二分吧。\nupd3：莫队真了。\n刚才那个莫队假的原因是一个点上会挂一堆路径，你这一个点遍历多次就死掉了，复杂度变成 O(n^2)。\n所以我们把一个点展开成多个点（每挂一条路径就多一个点），这样新序列长度是 O(n+p) 的。\n然后把询问的区间对应到这个新序列上，再进行莫队，复杂度就真了。\n代码以后补。\nupd4：莫队又死了。\n因为树上莫队需要考虑 lca，所以可以构造 lca 被拆成一堆点，那么你每次还是得跑这一堆点，就死了。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define pii pair&lt;int,int&gt;#define fi first#define se secondusing namespace std;const int maxn=4e4+10,maxm=210;int n,p,m,cnt,tim,siz,tot;int a[maxn];int head[maxn],seq[maxn&lt;&lt;1],ans[maxn];int st[maxm],ed[maxm],bel[maxn];int cnt1[maxn],cnt2[maxm];vector&lt;pii&gt; g[maxn];bool vis[maxn];struct edge&#123;    int to,nxt;&#125;e[maxn&lt;&lt;1];struct node&#123;    int l,r;    int fa,siz,top,hson,dep;&#125;t[maxn];struct Query&#123;    int l,r,k,id,lca;&#125;q[maxn];inline bool cmp(Query a,Query b)&#123;return ((a.l/siz)^(b.l/siz))?(a.l/siz)&lt;(b.l/siz):((a.l/siz)&amp;1)?a.r&lt;b.r:a.r&gt;b.r;&#125;inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void dfs1(int u,int fa)&#123;    t[u].l=++tim;seq[tim]=u;    t[u].fa=fa,t[u].siz=1,t[u].dep=t[fa].dep+1;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(v==fa) continue;        dfs1(v,u);        t[u].siz+=t[v].siz;        if(!t[u].hson||t[v].siz&gt;t[t[u].hson].siz) t[u].hson=v;    &#125;    t[u].r=++tim;seq[tim]=u;&#125;inline void dfs2(int u,int top)&#123;    t[u].top=top;    if(!t[u].hson) return;    dfs2(t[u].hson,top);    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(v==t[u].fa||v==t[u].hson) continue;        dfs2(v,v);    &#125;&#125;inline int lca(int u,int v)&#123;    while(t[u].top!=t[v].top)&#123;        if(t[t[u].top].dep&lt;t[t[v].top].dep) swap(u,v);        u=t[t[u].top].fa;    &#125;    return t[u].dep&lt;t[v].dep?u:v;&#125;inline void init()&#123;    siz=sqrt(p);    tot=p/siz;    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;n) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=p;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i;&#125;inline void add(int x)&#123;++cnt1[x],++cnt2[bel[x]];&#125;inline void del(int x)&#123;--cnt1[x],--cnt2[bel[x]];&#125;inline int query(int k)&#123;    for(re int i=1;i&lt;=tot;++i)&#123;        if(k-cnt2[i]&lt;=0)&#123;            for(re int j=st[i];j&lt;=ed[i];++j)&#123;                if(k-cnt1[j]&lt;=0) return a[j];                k-=cnt1[j];            &#125;        &#125;        k-=cnt2[i];    &#125;    return -1;&#125;inline void work(int u)&#123;    if(vis[u])&#123;for(auto x:g[u]) if(vis[x.fi]) del(x.se);&#125;    else&#123;for(auto x:g[u]) if(vis[x.fi]) add(x.se);&#125;    vis[u]^=1;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;p&gt;&gt;m;    for(re int i=1,u,v;i&lt;n;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    dfs1(1,0),dfs2(1,1);    for(re int i=1,u,v,w;i&lt;=p;++i) cin&gt;&gt;u&gt;&gt;v&gt;&gt;w,g[u].push_back(&#123;v,w&#125;),g[v].push_back(&#123;u,w&#125;),a[i]=w;    sort(a+1,a+p+1);    p=unique(a+1,a+p+1)-(a+1);    for(re int u=1;u&lt;=n;++u) for(auto &amp;x:g[u]) x.se=lower_bound(a+1,a+p+1,x.se)-a;    for(re int i=1,u,v,k,lc;i&lt;=m;++i)&#123;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;k;        if(t[u].l&gt;t[v].l) swap(u,v);        lc=lca(u,v);        if(lc==u) q[i]=&#123;t[u].l,t[v].l,k,i,0&#125;;        else q[i]=&#123;t[u].r,t[v].l,k,i,lc&#125;;    &#125;    siz=sqrt(n&lt;&lt;1);    sort(q+1,q+m+1,cmp);    init();    int l=1,r=0;    for(re int i=1;i&lt;=m;++i)&#123;        while(r&lt;q[i].r) work(seq[++r]);        while(l&gt;q[i].l) work(seq[--l]);        while(r&gt;q[i].r) work(seq[r--]);        while(l&lt;q[i].l) work(seq[l++]);        if(q[i].lca) work(q[i].lca);        ans[q[i].id]=query(q[i].k);        if(q[i].lca) work(q[i].lca);    &#125;    for(re int i=1;i&lt;=m;++i) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n[SHUPC 2024] 原神，启动！设 x_i 表示第 i 个被攻击的次数，那么列出方程应该长这样\n\n\\begin{cases}\na_{1,1}x_1+a_{2,1}x_2+\\cdots+a_{n,1}x_n+s_1\\ \\equiv t_1 & (mod\\ m)\n\\\\\na_{1,2}x_1+a_{2,2}x_2+\\cdots+a_{n,2}x_n+s_2\\ \\equiv t_2 & (mod\\ m)\n\\\\\n\\cdots\n\\\\\na_{1,n}x_1+a_{2,n}x_2+\\cdots+a_{n,n}x_n+s_n\\ \\equiv t_n & (mod\\ m)\n\\end{cases}然后高斯消元解就完事了。\n注意是在模意义下解高斯消元，所以除法要注意。\n","categories":["每日记录"],"tags":["数据结构"]},{"title":"2024.10.30","url":"/posts/8bd41c47/","content":"[HAOI2007] 修筑绿化带\n弱化版：[HAOI2007] 理想的正方形\n求完前缀和后转化为求矩形最值。\n本来以为是经典问题，二维 ST 表或者树套树做一下就行了，结果发现复杂度不能带两个  \\log。\n但这道题的矩形大小是固定的，所以可以用单调队列求。\n设大矩形的大小为 n\\times m，待求矩形的大小为 l \\times r，且假设要求的是最小值。\n\n如图所示，我们把一个小矩形的每一列都缩成一个点（缩成这一列的最小值）。\n这样我们会得到一个序列，只需要求这个序列的最小值即可。\n因为我们矩形的大小是固定的，所以第一步就是对大矩形的每一列做一次窗口长度为 r 的滑动窗口。\n做完这个东西以后我们会得到一个新的矩形，然后对这个新的矩形的每一行做一次窗口长度为 l 的滑动窗口，此时每个窗口得到的最小值对应的就是原来大矩形中那个小矩形的最小值。\n复杂度 O(nm)\n","categories":["每日记录"],"tags":["数据结构"]},{"title":"2024.10.3","url":"/posts/65cedd4c/","content":"模拟赛\n\n数据范围：n \\le 100,1\\le a_i,b_i,c_i \\le 10^9\n值域很大，无法加到状态里。那么考虑每个操作对答案产生的贡献。\n我们把攻击力拆开来算。\n直接攻击，那么贡献就是 a_i。\n设这回合后一共攻击 j 次。\n加攻击力，那么在这以后每次攻击伤害都会加 c_i，贡献就是 j\\times c_i\n加增量，那么设后续攻击的回合是 p_1,p_2,\\cdots,p_j，那么贡献为 \\sum_{k=1}^j (p_k-i)\\times b_i。\n把这个东西稍微拆一下，得到 b_i(\\sum_{k=1}^j p_k-j\\times i)。\n那么我们只需要记录攻击次数和攻击回合的编号和即可。\n但有个问题，我们现在的贡献和未来回合的行动有关。\n所以要倒过来做。那么转移也要相应的变一下。\n设 f_{i,j,k} 表示第 i 个回合到最后一个回合，一共攻击了 j 次，攻击回合的编号和为 k 的最大值。\n转移为\n\nf_{i,j+1,k+i}=f_{i+1,j,k}+a_i\n\\\\\nf_{i,j,k}=f_{i+1,j,k}+(i\\times j-k)\\times b_i\n\\\\\nf_{i,j,k}=f_{i+1,j,k}+j\\times c_i转移时可以把第一维压掉，但第二维要倒序枚举。\n复杂度 O(n^4)。\nCode：\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=110,inf=1e18;int n;int a[maxn],b[maxn],c[maxn],f[maxn][maxn*maxn];inline void solve()&#123;    cin&gt;&gt;n;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];    reverse(a+1,a+n+1);reverse(b+1,b+n+1);reverse(c+1,c+n+1);    memset(f,-0x3f,sizeof f);    f[0][0]=0;    for(re int i=1;i&lt;=n;++i)&#123;        for(re int j=i-1;j&gt;=0;--j)&#123;            for(re int k=0;k&lt;=(i-1)*i/2;++k)&#123;                f[j+1][k+i]=max(f[j+1][k+i],f[j][k]+a[i]);                f[j][k]=max(f[j][k],f[j][k]+max((i*j-k)*b[i],j*c[i]));            &#125;        &#125;    &#125;    int ans=-inf;    for(re int i=0;i&lt;=n;++i) for(re int j=0;j&lt;=n*(n+1)/2;++j) ans=max(ans,f[i][j]);    cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    int T;cin&gt;&gt;T;while(T--) solve();    return 0;&#125;\nRemoving Leaves *2300\n又读错题被硬控了。\n一开始没看见 k，以为随便删。\n考虑贪心。\n我们用 set 存每个节点，然后每次找到叶子最多的那个点，然后删 k 个。找不到就结束。\n这为什么是对的？\n感性理解一下，我们这么做只会让能删的点越来越多，而且不会有本来能删的点因为操作而不能删除，所以这么做操作数就是最大的。\n复杂度 O(n\\log n)\nVoting (Hard Version) *2400\n看完题就想到了一个假贪心：先按 m 降序再按 p 升序，每次买 m 最大 p 最小的。\n显然不对。我们不一定只从 m 最大的里面买。\n那改成每次买 p 最小的呢？\n还是不对。因为不一定买最小的就优。例如这组样例\n21 12 2\n显然只需要 2 即可。\n那应该怎么做？\n我们依旧按 m 降序排序。\n对于当前的 m_i，设 m 值小于 m_i 的人数为 pre，大于 m_i 且被买的人数为 cnt。\n假设我们已经把 < m_i 的人全搞定了，那么只需要让 pre+cnt\\ge m_i，就能搞定 m_i了。\n但如果不满足，我们就要从 \\ge m_i 的人里买人（因为 pre 是固定的），直到 pre+cnt\\ge m_i。\n满足该条件后，m_i 就被我们搞定了。\n那么我们只需要保证 < m_i 的人都被搞定就行了。\n然后再处理 < m_i 的那些人。这是一个子问题，和上述步骤完全一致。\n买人贪心买最便宜的，用个堆维护一下即可。\n复杂度 O(n\\log n)\nHappy Life in University *2300\n怎么现在啥数据结构都不会了/kk。\n对于这种 lca 的问题，常见套路是枚举 lca，把贡献都在 lca 处统计（枚举 lca 的意思是考虑每个点作为 lca 时的情况）。\n而这种 lca 的路径问题又能跟子树弄上关系。\n设当前考虑到以 u 为根的子树。\n那么我们只需要维护 u 到子树内节点的路径即可，答案就是拿两条路径拼起来。\n假设已经搜完了子树，回溯到了 u。\n那么 u 会对所有路径产生自己颜色的贡献。\n但显然会算重，那么考虑去重。\n因为每个点只需要在离他最近的且颜色和他相同的祖先处减去重复，所以只会操作 O(n) 次。\n那么直接去重就是对的。\n所以我们的操作就只有子树加和子树查，线段树维护。\n答案用最大值和次大值拼一下即可。\n复杂度 O(n\\log n)\nWine Factory (Easy Version) *2300\n讲一个很有意思的做法。\n我们考虑有多少水被浪费了。\n设 f_i  表示从 i 流向 i+1 的水的量。\n转移为 \n\nf_i=\\max(f_{i-1}+a_i-b_i,0)这东西可以用 (max,+) 矩乘表示。\n\n\\begin{bmatrix}\nf_i \n\\\\\n0 \n\\end{bmatrix}\n=\n\\begin{bmatrix}\na_i-b_i & 0 \n\\\\\n-inf & 0\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\nf_{i-1} \n\\\\\n0 \n\\end{bmatrix}然后线段树维护矩阵即可。单点修改也是简单的。\n复杂度 O(k^3n\\log n)\nMark and Professor Koro *2300\n感觉和 [HBCPC2024] Enchanted 非常的像啊，套路也是一样。\n对于这种两个相同的数合并成+1的数的操作，我们可以把它看成二进制意义下的加法，然后进行维护。\n但这个题不能直接把数的二进制用整数表示，值域太大了。\n我们用线段树维护值域上每个数出现次数，不难发现每个数出现次数只会为 0/1。\n那么修改可以看成删一个数再加上一个数。\n删和加是类似的，先考虑加。设加的那个数是 x。\n如果 x 那一位是 0，那么不用进位，直接给这一位 +1 即可。\n否则会进位。但不难发现，这东西是一次区间覆盖和一次单点修改。\n删数同理。\n如果 x 那一位是 1，那么不用退位，直接给这一位 -1 即可。\n否则会退位。依旧是一次区间覆盖和一次单点修改。\n那么答案就是最右边的 1 的位置，这个可以线段树上二分找到。\n具体的，线段树上维护区间里 1 的个数。\n加法进位：找到 x 后第一个为 0 的位置 pos，然后把 [x,pos-1] 区间赋值为 0，把 pos 赋值为 1.\n减法进位：找到 x 后第一个为 1 的位置 pos，然后把 [x,pos-1] 区间赋值为 1，把 pos 赋值为 0.\n找位置都可以线段树上二分。\n复杂度 O(n\\log n)\n","categories":["每日记录"],"tags":["数据结构","Codeforces","dp","贪心","模拟赛","矩阵乘法"]},{"title":"2024.10.8","url":"/posts/f21c04c4/","content":"这几天一直在写各种分块，要写吐了。\n今天不剩啥时间了，写道板子题吧。\n[LnOI2019] 来者不拒，去者不追\n首先看到这个复杂度区间询问且能离线，肯定想到莫队。\n但第一感觉是不是以为这东西特别难维护？每次插入删除一个数，那排名不都变了吗？\n但你仔细想想，就会发现很好维护。\n假设现在插入一个 x，那么新增贡献就是 ((\\sum_{i=l}^r [a_i","categories":["每日记录"],"tags":["数据结构","莫队"]},{"title":"2024.10.4","url":"/posts/fbaa48ef/","content":"模拟赛\n\n数据范围：1\\le n \\le 3\\times 10^5\n感觉自己的思路非常自然，所以写一下。\n一开始读错题了，没弄懂它的 s_1=s_2 是啥意思，以为只要元素一样就行了不用管顺序。\n如果不管顺序，那答案就是 \\sum_{i=1}^n \\binom{n}{i} \\times 2^i。\n但是我们是需要考虑顺序的。\n那么我们考虑什么时候是不合法的。\n例如 3773，这种情况下是不能把这两个数都选进去的，因为一定无法满足顺序一样。\n如果我们把每个数看成一条线段，那么可以发现，这种不合法的情况就是两条线段是包含关系。\n然后考虑合法情况。\n例如样例里的 1122，可以发现怎么选都是合法的。\n不难发现，这种情况是两条线段无交。\n再例如 1212，可以发现只有两种情况是合法的，要么都选左端点要么都选右端点。\n不难发现，这种情况是两条线段有交且不包含。\n但如果是一堆线段怎么办？\n如果连续若干条线段有交，可以发现总贡献依旧为 2。\n如果连续若干条线段无交，可以发现总贡献为 2^{num}。\n那么考虑 dp。\n设 f_i 表示第 i 条线段的贡献，转移为\n\nf_i=\\sum_{l_i>r_j}2\\times f_j+\\sum_{l_ir_j} f_j初始值为 f_i=2，因为每条线段都有两种选择。\n复杂度是 O(n^2) 的。考虑优化。\n不难发现，我们可以用前缀和来转移。\n但这样会少算一部分和多算一部分。\n我们把 dp 值放到每条线段的右端点上，然后用树状数组直接查询就可以了。\n复杂度 O(n\\log n)\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define lb(x) (x&amp;(-x))using namespace std;const int maxn=3e5+10,mod=998244353,inf=6e5;int n,ans;int f[maxn],s[maxn],tr[maxn&lt;&lt;1];struct line&#123;    int l,r;    inline bool operator &lt; (const line &amp;a)const&#123;        return l&lt;a.l;    &#125;&#125;t[maxn];inline void add(int x,int val)&#123;while(x&lt;=inf) tr[x]=(tr[x]+val)%mod,x+=lb(x);&#125;inline int query(int x)&#123;int res=0;while(x) res=(res+tr[x])%mod,x-=lb(x);return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;std.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n;    for(re int i=1,x;i&lt;=2*n;++i)&#123;        cin&gt;&gt;x;        if(!t[x].l) t[x].l=i;        else t[x].r=i;    &#125;    sort(t+1,t+n+1);    for(re int i=1;i&lt;=n;++i)&#123;        f[i]=2;        f[i]=(f[i]+s[i-1])%mod;        f[i]=(f[i]+query(t[i].l))%mod;        f[i]=((f[i]-(query(inf)-query(t[i].r))%mod)%mod+mod)%mod;        add(t[i].r,f[i]);        s[i]=(s[i-1]+f[i])%mod;    &#125;    for(re int i=1;i&lt;=n;++i) ans=(ans+f[i])%mod;    cout&lt;&lt;ans;    return 0;&#125;\n","categories":["每日记录"],"tags":["数据结构","dp","模拟赛"]},{"title":"2024.11.11","url":"/posts/76592936/","content":"总结近日杂题。\n没有代码的就是懒得写了。\n模拟赛一\n数据范围：1\\le n,H,w_i,h_i \\le 10^6。\n原问题是经典单调栈，以每个位置作为最小值时算贡献，所以只需要找到左侧第一个小于自己和右侧第一个小于自己即可。\n考虑修改对上述贡献带来的影响。\n首先可以发现，一个位置要修改的话，改成 H 一定不劣。\n如果这个位置是某个中心位置的左侧第一个小于中心或右侧第一个小于中心的位置，那么该中心的答案显然会变优。\n所以需要对每个位置找到左侧第二个小于自己和右侧第二个小于自己的位置。\n可以维护两个以高度为下标，位置为权值的树状数组，那么只需要查前缀 \\max 和后缀 \\min 即可。\n所以可以枚举中间位置，然后看是左侧第一个小于自己的改更优还是右侧第一个小于自己的改更优。\n还有一种情况：修改中间位置更优。\n所以还需要求出左侧第一个小于 H 和右侧第一个小于 H 的位置。\n复杂度 O(n\\log n)。\n场上写了 O(n^2) 暴力找的做法，直接冲到最优解了，不知道数据为什么不卡。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define max(a,b) (a&lt;b?b:a)using namespace std;const int maxn=1e6+10;int n,H,ans;int h[maxn],sw[maxn];int lid[maxn],rid[maxn];int l[maxn],r[maxn];int top,stk[maxn];signed main()&#123;    freopen(&quot;poster.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;poster.out&quot;,&quot;w&quot;,stdout);    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;H;    for(re int i=1,w;i&lt;=n;++i)&#123;        cin&gt;&gt;h[i]&gt;&gt;w;        sw[i]=sw[i-1]+w;    &#125;    for(re int i=1;i&lt;=n;++i)&#123;        while(top&amp;&amp;h[stk[top]]&gt;h[i]) rid[stk[top--]]=i;        stk[++top]=i;    &#125;    while(top) rid[stk[top--]]=n+1;    for(re int i=n;i&gt;=1;--i)&#123;        while(top&amp;&amp;h[stk[top]]&gt;h[i]) lid[stk[top--]]=i;        stk[++top]=i;    &#125;    while(top) lid[stk[top--]]=0;    int id=0;    for(re int i=1;i&lt;=n;++i)&#123;        if(h[i]&lt;H) l[i]=id,id=i;        else l[i]=id;    &#125;    id=0;    for(re int i=n;i&gt;=1;--i)&#123;        if(h[i]&lt;H) r[i]=id,id=i;        else r[i]=id;    &#125;    for(re int i=1,lid2,rid2;i&lt;=n;++i)&#123;        if(h[i]&gt;H) ans=max(ans,(sw[rid[i]-1]-sw[lid[i]])*h[i]);        else&#123;            ans=max(ans,(sw[r[i]-1]-sw[l[i]])*H);            lid2=0,rid2=n+1;            for(re int j=lid[i]-1;j&gt;=1;--j) if(h[j]&lt;h[i])&#123;lid2=j;break;&#125;            for(re int j=rid[i]+1;j&lt;=n;++j) if(h[j]&lt;h[i])&#123;rid2=j;break;&#125;            ans=max(ans,max((sw[rid2-1]-sw[lid[i]])*h[i],(sw[rid[i]-1]-sw[lid2])*h[i]));        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n模拟赛二\n数据范围：1\\le n \\le 2\\times 10^4,1\\le k \\le 60。\n一道部分分对正解没有任何启发意义的题。\n先说我在场上打的部分分。\n枚举 x 是没前途的，所以考虑对于一对 (i,j) 求有多少 x 合法。\n然后发现这东西可以拆位然后 DP。\n设 f_{p,0/1,0/1} 表示从低位到高位考虑到第 p 位，a_i 是否向 p+1 进位，a_j 是否向 p+1 进位。\n转移就是考虑 x 这一位填什么。\n答案为 f_{k,0,0}+f_{k,0,1}+f_{k,1,1}。\n非常麻烦，要大力分讨。\n复杂度 O(n^2k)。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e4+10,maxk=65,mod=998244353;int n,k,cnt,S,ans;int a[maxn],num[maxn],f[maxk][2][2];inline string to_String(int x)&#123;    string s=&quot; &quot;;    for(re int i=1;i&lt;=k;++i)&#123;        if(((x&gt;&gt;(i-1))&amp;1)==1) s+=&#x27;1&#x27;;        else s+=&#x27;0&#x27;;    &#125;    return s;&#125;inline int solve(int x,int y)&#123;    string a1=to_String(x),a2=to_String(y);    for(re int i=1;i&lt;=k;++i) for(re int j=0;j&lt;=1;++j) for(re int p=0;p&lt;=1;++p) f[i][j][p]=0;    for(re int i=1;i&lt;=k;++i)&#123;        if(a1[i]==&#x27;0&#x27;&amp;&amp;a2[i]==&#x27;0&#x27;)&#123;            f[i][0][0]=(f[i][0][0]+(f[i-1][0][0]+f[i-1][0][1]+f[i-1][1][1]+f[i-1][0][0]))%mod;            f[i][1][0]=(f[i][1][0]+f[i-1][1][0])%mod;            f[i][1][1]=(f[i][1][1]+f[i-1][1][1])%mod;        &#125;        if(a1[i]==&#x27;0&#x27;&amp;&amp;a2[i]==&#x27;1&#x27;)&#123;            f[i][0][0]=(f[i][0][0]+(f[i-1][1][0]+f[i-1][0][0]))%mod;            f[i][0][1]=(f[i][0][1]+(f[i-1][0][1]+f[i-1][0][1]))%mod;            f[i][1][1]=(f[i][1][1]+(f[i-1][1][0]+f[i-1][1][1]))%mod;        &#125;        if(a1[i]==&#x27;1&#x27;&amp;&amp;a2[i]==&#x27;0&#x27;)&#123;            f[i][0][0]=(f[i][0][0]+f[i-1][0][1])%mod;            f[i][1][0]=(f[i][1][0]+(f[i-1][1][0]+f[i-1][0][0]+f[i-1][1][0]+f[i-1][1][1]))%mod;            f[i][1][1]=(f[i][1][1]+f[i-1][0][1])%mod;        &#125;        if(a1[i]==&#x27;1&#x27;&amp;&amp;a2[i]==&#x27;1&#x27;)&#123;            f[i][0][0]=(f[i][0][0]+f[i-1][0][0])%mod;            f[i][1][0]=(f[i][1][0]+f[i-1][1][0])%mod;            f[i][1][1]=(f[i][1][1]+(f[i-1][0][0]+f[i-1][0][1]+f[i-1][1][1]+f[i-1][1][1]))%mod;        &#125;    &#125;    return (f[k][0][0]+f[k][0][1]+f[k][1][1])%mod;&#125;signed main()&#123;    freopen(&quot;subset.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;subset.out&quot;,&quot;w&quot;,stdout);    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;k;S=(1ll&lt;&lt;k)%mod;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];    sort(a+1,a+n+1);a[0]=-1;    for(re int i=1;i&lt;=n;++i)&#123;        if(a[i]!=a[i-1]) a[++cnt]=a[i],num[cnt]=1;        else ++num[cnt];    &#125;    f[0][0][0]=1;    for(re int i=1;i&lt;=cnt;++i)&#123;        ans=(ans+S*num[i]*num[i])%mod;        for(re int j=i+1;j&lt;=cnt;++j)&#123;            ans=(ans+num[i]*num[j]*solve(a[i],a[j]))%mod;        &#125;    &#125;    cout&lt;&lt;ans;    return 0;&#125;\n然后是正解。\n上面这个 DP 没有任何前途，考虑换一个算贡献的方式。\n首先有结论：\n\na 是 b 的子集等价于 b-a 是 b 的子集。\n\n所以对于一对 (i,j)，a_i+x 是 a_j+x 的子集等价于 a_j-a_i 是 a_j+x 的子集。\n我们不需要关心 a_j+x 的进位，因为 a_j-a_i < 2^k，且 a_j,x < 2^k，所以不存在进位以后多贡献一次的情况。\n那么只需要求在 [0,2^k-1] 中 a_j-a_i 的超集个数即可。\n答案为 2^{k-d}，其中 d 为 a_j-a_i 的 1 的个数。\n复杂度 O(n^2)\n模拟赛三\n数据范围：1\\le n \\le 10^5,1\\le a_i \\le 10^{12}。\n以下假设原序列单调不降。\n可以发现，只有在 d \\le \\sqrt V 时，才有可能把数变为 d^k，否则只能变成 1 或 d。\n那么对于 d > \\sqrt V 的部分是比较好做的。\n我们枚举一个分界线，在分界线左侧的都变为 1，右侧的都变为 d。\n可以发现，这个 d 不用枚举，因为取右侧的中位数一定是最优的。\n然后考虑 d\\le \\sqrt V 的部分。\n可以发现，变为 d^k  最优的值的范围为 [\\frac {d^{k-1}+d^k}{2},\\frac {d^k+d^{k+1}}{2}]。\n所以序列会分成 \\log 段，那么对这 \\log 段分别求即可。\n怎么维护这些连续段呢？\n可以发现，当 d \\leftarrow d+1 时，每一段都会向右移动，且长度单调不降。\n所以可以维护 \\log 个指针，在 d 增大时维护指针的移动即可。\n当然也有一种好写做法：每次找区间时都二分，这样会多带一个 \\log n，不过小常数可以通过。\n复杂度 O(\\sqrt V \\log {\\sqrt V}+n)。\n「EZEC-5」人赢 加强版我会弱化版。\n为什么思考的角度总是不对呢···\n看到这个 \\min 不好搞，所以考虑每个值在自己成为 \\min 时算答案。\n那么我们需要对每个位置，找到它右侧最后一个大于它的数。\n我们可以以 k 为下标，位置作为权值，然后做一个后缀 \\max。\n但是需要离散化，所以复杂度 O(n\\log n)。\n瓶颈竟然在于离散化，绷不住了。\n但我们从 k 入手的那一刻就注定了我们不会有更优的复杂度。\n所以我们换个角度：从位置入手。\n下文的 a_i 对应原题的 k_i。\n首先有性质：\n\n\\forall i","categories":["每日记录"],"tags":["模拟赛"]},{"title":"2024.11.6","url":"/posts/146643f4/","content":"模拟赛\n\n首先考虑暴力 DP。\n设 f_{i} 表示 i 的期望步数，则有转移\n\nf_{i}=1+\\sum_{j=1}^i \\frac{f_{i\\mod j}}{i}考虑怎么快速计算后面的东西。\n结论：a \\mod b=a-\\lfloor \\frac {a}{b} \\rfloor\\times b。\n考虑根号分治。\n对于 j < \\sqrt i，我们直接暴力计算，这部分是 O(\\sqrt n) 的。\n对于 j \\ge \\sqrt i，可以发现 \\lfloor \\frac {i}{j} \\rfloor \\le \\sqrt i。\n设 d=\\lfloor \\frac {i}{j} \\rfloor，其对应区间为 [l,r]。\n设 i=p+k\\times d，则\n\n\\begin{align*}\n\\sum_{j=1}^i f_{i \\mod j} &= \\sum_{n=l}^r f_{i-n\\times d}\n\\\\\n&=\\sum_{q=k-l}^{k-r} f_{p+q\\times d}\n\\\\\n&=\\sum_{v=p+(k-l)\\times d}^{p+(k-r)\\times d} f_{v}\n\\end{align*}这是一个区间求和的形式，可以前缀和优化。\n所以对每一个 d 都维护一个前缀和即可。\n复杂度 O(n\\sqrt n)\n实现时，可以对每个 i 做一次整除分块，然后做上面说的东西。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e5+10,V=2e5,M=450,mod=998244353;int f[maxn],inv[maxn];int s[M][maxn];inline void pre()&#123;    inv[0]=inv[1]=1;    for(re int i=2;i&lt;=V;++i) inv[i]=inv[mod%i]*(mod-mod/i)%mod;&#125;inline void init()&#123;    pre();    for(re int i=1;i&lt;=V;++i)&#123;        for(re int l=1,r,d;l&lt;=i;l=r+1)&#123;            r=i/(i/l);            d=i/l;            if(d&gt;=M) for(re int j=l;j&lt;=r;++j) f[i]=(f[i]+f[i%j])%mod;            else&#123;                int mo=i%d,k=i/d;                int L=(k-r)*d+mo,R=(k-l)*d+mo;                if(L-d&lt;0) f[i]=(f[i]+s[d][R]%mod)%mod;                else f[i]=(f[i]+(s[d][R]-s[d][L-d])%mod+mod)%mod;            &#125;\t        &#125;        f[i]=(f[i]*inv[i]+1)%mod;        for(re int d=1;d&lt;M;++d)&#123;            if(i&lt;=d) s[d][i]=f[i];            else s[d][i]=(s[d][i-d]+f[i])%mod;        &#125;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    init();    int n,T;cin&gt;&gt;T;while(T--) cin&gt;&gt;n,cout&lt;&lt;f[n]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n","categories":["每日记录"],"tags":["模拟赛"]},{"title":"2024.9.27","url":"/posts/57d8e29d/","content":"一直在搭博客没怎么做题啊···\nTourism *2200\n首先手玩样例可以发现：环上的点可以都拿，连接环的点也可以都拿。\n然后考虑剩下的点。\n因为剩下的点只能选一条点权和最大的路径，所以考虑拓扑 dp。\n那么答案就是起点到环经过的点 + 环上的点的点权和 + \\max f_i\n学到的东西：看到这种类似不能重复走一条边的东西可以考虑缩点双（因为割边走过去不能回来）\nHappy Line *2200\n感觉很困难。我是性质低手/kk。\n假设当前 a_i,a_{i+1}  需要操作，那么操作完后会变成 a_{i+1}+1,a_i-1。\n对于 a_i，可以发现 a_i+i=(a_i-1)+(i+1)。\n即 val_i+pos_i=val_i'+pos_i'。\n不难推出，对于所有 i，都有 a_i+i 为定值。\n那么将 a_i+i 排序得到序列 b，答案就是 b_i-i。\n无解就是存在 b_i=b_{i+1}。\n学到的东西：对于这种交换位置的题，要往排序想，分析两个元素交换带来的影响（类似微扰法）。\nShort Code *2200\n读完题瞬间想到一个假做法：按长度从小到大排序，然后模拟。\n但这很容易 hack。对于一个很长的串，我们完全可以让它取很短的一部分，让一些短串取稍微长一些。这样比长串取很长短串取很短要优。\n那从大到小呢？也不行。\n因为很有可能长串取完以后，一些短串作为长串的前缀，就算全取也无法避免重复，这就不合法了。\n然后不会了。\n正解：\n建立 trie 树。此时问题变为：\n给一棵树，有一些黑点。可以把黑点移到祖先处，但两个黑点不能在同一个位置。求最小的黑点深度和。\n用堆维护每颗子树中黑点的深度，如果根上没有黑点就把最深的移到根。\n学到的东西：看到字符串前缀想到 trie（还是字符串做少了）。\n","categories":["每日记录"],"tags":["Codeforces","贪心"]},{"title":"2024.9.28","url":"/posts/c767ff0c/","content":"LaIS *2200\n没太想出来。\n设 f_i 表示以 i 为结尾的最长子序列长度。\n考虑如何从 j 转移到 i。\n若 a_j\\le a_i，那么直接转移即可。\n若 a_j > a_i，则需要考虑 j 的前驱 k。\n因为需要满足 \\min(a_k,a_j)\\le \\min(a_j,a_i)，即 a_k \\le a_i。\n那么我们贪心的想，让 j 越靠右越好，因为这样前驱 k 的范围就更大。\n那么我们维护一个单调栈，求出每个 i 左侧的第一个 j，使得 a_j > a_i。\n转移用树状数组即可。\n复杂度 O(n\\log n)\nHelping Hiasat *2200\n开到抽象题了。\n第一遍读错题了，没看到每一次都得一样。\n如果没有这个限制的话就很简单了，把相邻两个 1 之间划分成一个区间，找每个区间的众数即可。\n但现在有这个限制，怎么办？\n依旧考虑划分成若干区间，那么两个人可以共存当且仅当两个人从未同时出现过。\n如果两个人不能共存，那么就连一条边。最后求出这个图的最大独立集即可。\n这是一个 NPC 问题。\n不过有结论：原图的最大独立集=补图的最大团。\n最大团可以用 Bron–Kerbosch 算法在 O(2^{\\frac{n}{2}}) 的复杂度内求出。\n复杂度 O(nm^2+2^{\\frac{m}{2}})\nDemiurges Play Again *2200\n首先考虑权值给定怎么做。\n设 f_{u,0/1} 表示 u 点先/后手能取到的值。转移为\n\nf_{u,0}=\\max_{v \\in sub_u} f_{v,1}\n\\\\\nf_{u,1}=\\min_{v \\in sub_u} f_{v,0}然后考虑放权值。\n依旧设 f_{u,0/1}，表示 u 点先/后手能取到的值是该子树内第 f_{u,0/1} 大的数。\n那么转移是类似的，不过变成了第几大。\n对于 f_{u,0}，取 \\min 即可。\n对于 f_{u,1}，下一步由对方取最大值，而无论怎么放权值，对方都有可能不选择某子树。所以问题可以看作我们需要放多少个数进入叶子结点才可以让此时的玩家保证能够取到数。而能取到的最小值就是这些数的最后一个。因为是子树内的第几大，所以可以直接求和。\n综上，转移为\n\nf_{u,0}=\\min_{v \\in sub_u} f_{v,1}\n\\\\\nf_{u,1}=\\sum_{v \\in sub_u} f_{v,0}那么答案分别为 m-f_{1,0}+1,f_{1,1}。\n复杂度 O(n)\n因为有单调性，所以也可以二分变成判定性问题，不过似乎有点多此一举？\nYet Another Array Counting Problem *2300\n开到了笛卡尔树上 dp 板子。\n以下标为键，a_i 为值建立大根笛卡尔树，那么 [l,r] 的最左端最大值位置就是 l,r 在笛卡尔树上的 \\operatorname{lca}。\n那么所有最左端最大值位置都相等，就意味着笛卡尔树的形态相同。\n此时转化为树计数问题。\n设 f_{u,i} 表示 u 取值 1 \\sim i 的方案数。\n左儿子可以填 [1,i-1]，右儿子可以填 [1,i]\n转移就是 f_{u,i}=f_{u,i-1}+f_{ls_u,i-1}\\times f_{rs_u,i}\n复杂度 O(nm)\n","categories":["每日记录"],"tags":["Codeforces","dp"]},{"title":"2024.9.29","url":"/posts/b060cf9a/","content":"Funny Game *2200\n看了半个小时不会后看题解被嘲讽简单题后破防。\nKirill and Company *2200\n终于做到会的题了。\n看到 k 这么小，直接考虑状压。\n在处理最短路时，我们还要处理出每个点的搭载朋友情况。\n最后就是一个背包。\n复杂度 O((n+m)2^k+f(2^k)^2)\nRailguns *2200\n你指尖跃动的电光，是我此生不变的信仰。\n似乎不太难想？\n首先可以发现，答案上界为 n+m+r，因此可以枚举答案。\n设 f_{i,j,k} 表示第 k 秒时能否到达 (i,j)。转移为\n\nf_{i,j,k}|=(f_{i-1,j,k-1}|f_{i,j-1,k-1}|f_{i,j,k-1})我们在最外层枚举时间，然后 dp 即可。\n至于超电磁炮，我们都已经枚举时间了，那 dp 之前把对应状态直接限制一下就行了。\n复杂度 O(nmr)\n","categories":["每日记录"],"tags":["Codeforces","dp"]},{"title":"2024.9.30","url":"/posts/d0a7467f/","content":"Darth Vader and Tree *2200\n首先考虑暴力。\n设 f_i 表示距离根距离恰好为 i 的数量。转移为\n\nf_i=\\sum_{j=1}^n f_{i-d_j}但观察数据范围，发现 d_i\\le 100，说明不同的 d_i 很少。\n那么只需要对这些不同的 d_i 转移就行了。\n设 num_i=\\sum_{j=1}^n [d_j=i]，那么转移为\n\nf_i=\\sum_{j=1}^V num_j\\times f_{i-j} 这是一个常系数齐次线性递推方程，BM算法矩阵快速幂即可。\n最终答案为 \\sum_{i=1}^x f_i，可以在矩阵里顺便维护一下。\n复杂度 O(V^3\\log x)\nVladik and cards *2200\n容易想到状压。\n但第一个条件感觉很难搞，没法记录每个元素出现次数，怎么办？\n我们可以二分出所有的数字的最小出现次数 mid，那么每个元素出现次数只能为 mid 和 mid+1（经常在错解里想到这种思路，终于在这道题成为正解了）。\n设 f_{i,S} 表示到第 i 个位置，数字出现状态为 S 时，出现次数为 mid+1 的数的最大个数。\n这么设状态是因为，一个数的出现次数只能为 mid 和 mid+1，那肯定让 mid+1 的个数越多越好。\n转移比较简单，看每个数字出现 mid 次还是 mid+1 次即可。\n我们可以把每个数字出现的位置记录下来，方便转移。\n注意每种数字必须连续，也就是出现过后就不能再转移了。\n复杂度 O(2^Vn\\log n)\nTreeland Tour *2200\n树上路径问题直接考虑点分治。\n设当前分治重心为 rt，我们求出从叶子往 rt 走且以 i 结尾的 LIS 和 LDS。\n这个东西怎么求呢？\n每个点都只能从子树转移来，所以问题就是单点加子树查，弄个 dfn 序后线段树维护即可。\n统计答案时，考虑包不包含 rt。\n设 up_i 表示以 i 结尾的 LIS 长度， down_i 表示以 i 结尾的 LDS 长度。\n对 up_i 和 down_i 分别做前缀 max 和后缀 max。\n包含 rt：ans=\\max up_{a_{rt}-1}+down_{a_{rt}+1}+1\n不包含 rt：ans=\\max up_i+down_{i+1}\n然后完了？\n显然没有，因为如果两条路径来自同一颗子树内就寄了。\n那么线段树在维护时，记录最大值和次大值，以及来自哪棵子树即可。\n统计答案时特判一下。\n复杂度 O(n\\log^2 n)\nFelicity’s Big Secret Revealed *2200\n简单性质题。\n不难发现答案 x 不会很大。因为 n\\le 75，所以 x\\le 20。 \n那就考虑状压，设 f_{i,S} 表示这一刀切在 i 前，状态为 S 时的方案数。\n转移就枚举上一刀切在哪。\n转移为 \n\nf_{i,S}=\\sum f_{j,S/T}把 [j,i-1] 组成的数去掉即可。\n答案为 \\sum f_{i,2^j-1}\n复杂度 O(n2^V)\nAbbreviation *2200\n唐唐唐，下次读题能不能读仔细点。\n做了半个小时+看了半天题解才发现翻译里最后一句写着“至多进行一次操作”\n绷不住了。\n那就好做了。枚举缩哪一段区间即可。\n具体的，我们可以先处理出 f_{i,j} 表示 i 和 j 向后匹配的最长长度。\n然后枚举缩哪段区间，然后向后暴力缩就行了。\n复杂度 O(n^3+n|\\sum s_i|)\n代码可参考官方题解。\nThree Pieces *2200\n很厉害的一道题，完全没想出来。\n考虑 dp。\n设 f_{i,j,k,0/1/2} 表示当前在 (i,j)，已经填了 1\\sim k，且当前是 0/1/2 棋子的最小花费。\n但这个 dp 有一个问题：不知道转移顺序。\n所以考虑用最短路转移。\n转移分三种：\n\n换棋子，代价为 inf+1\n移动棋子，代价为 inf\n填数（即 (i,j) 所在的数是下一个数），代价为 0\n\n这里有一个 trick：因为还要求换的次数最小，所以可以设一个极大值，将移动棋子设为 inf，换棋子设为 inf+1，这样就可以做到双关键字了。\n输出答案时，时间就是 ans/inf，换的次数就是 ans\\%inf。\n一共 O(n^4) 个点，O(n^5) 条边。\n","categories":["每日记录"],"tags":["数据结构","Codeforces","dp","贪心","矩阵乘法"]},{"title":"CSP2024 游寄","url":"/posts/d6282838/","content":"\n      \n        c569f468f3619bcd6d3137dfe338fae70917366dbb94fe49c5bca74e1ce66666a6dcc0e00f3988010ad12827299097ce91bda7ee680d47edacda8994d60969e8cf56d7fee83142c0ed7e7b73fa3b03578e56d8f32dd7950e8afb7504910d69e8058d7e8679afa20d1677d6f9ed5430cd09b603925a30b86fea442efbafcc79db082c22d1f436a94bd7e9bde286649e2c91064651118cc45e8c39e2540eabd87a2cdce71a3581bc3ab3f1c785abdafd3fb1d9da436e68cd3ae062fd56a4215178042ea2f72a8baecb688eef9615ae7cc86b3b70bbce8bfc0a9cce27cd4fe31b40f6abb718730905a3354d4b587c84a33e3bb37a71e6df4f84a7b337692e85036e0fad2c41c3ad93a56acb0c04739786604b0583e8f848cc57878bf1ac21e0999d4b45c64784dea06ea6707cfb95c1e83d17820272d634fa8ecfaf786897a4f83e5fa47f8460ac8bc5837c25cba16b4617c12495d376cb058fcb77557a39e5a3a50ead1e44671fa4dbf699435b21cd48b09bb6fa8f9f13c1e63e4c964a5dc7e21c97e2aca80c6430c24fb733ac5f80efe5741ecba00d907275a25db05b27bf2a932b5f3e80842758acd9127b57cdb91f1fc43fa77f544868190793094a7402f91a46f675fe73ef7c75fba8cd9e3a5a1928553e5be96dfdc0a02f18a6817e61507a6778de652ba9dba44f89024e68c48c3e11570708bb568eb0494b60c25dbc005bc724e3e2ef4611e5a1920dd0fe9153884f85d04392046fead9a3e53dea2d8e549278d680c6a037d7770b2790e29ae707705c6105f10248b95d3eb7761047d4a4650976f180b34ed2b3f48006cdae9b895d3b530444189fe2c338a5c3823d4353e5961c4cb1cc193706d9e6eeaa2a157addaabfbe371a91b31adda66b39fff4a04e7a21548537fb42d04b593e69fb6ce01f43e8a68795f9bc222645577849e7bdaf46c4ff56fe00df5b807d70f77518bb597e7cb5fee8122fcd67402c9c55444766c4434b38758b197052e25cd91134455c20e0a18b651ec259573f98bdf864e7d8b675502c8e36b8b5355d5fa7b2ab4af421f57ab5bd3b8442ed4cd4c3cbff69020300628c68604add083c0512b5d9ac0a930c44ef6a5634e98eeb5c277bfaf3115ef369e06434520a5619db52367794a5e103b5c58737d2c1f95a4b0c62aa6108fd1ec92178eb0cb8e196bb535a4ccd40e78a871ceba9f25cdb00538b3c7fc347e6b31c511502c6cc1d78f84b72bc6dc91b431978e11186a712fbd0fbb8deefabecaae8a123b1b1643cff044d5a3a457daff0a20d1ed6092a97df559c7c07f98d00e36bd22d4bb4c92300d5284fb0a020f176c1924f36c2fd3f01cdf0eeed36551debf443bf49c6e10c3d7d59c269ae9f9238096b24bba217b249d433a080f75bb34ca0a3c90046ecae949837bd6ff85cd451e3337f24f130ffb48147c674a578d0fc3b73c280e6199514af862f1cec2adace856eb1bbac728d0bdd6f590a9b863f4ffabc28466b6d4181190907c7ee9d718b49ba4ba6a9bf0e728687795847e86dea777770ea4b1a6835c17537b6f9be234a49943cca9fc210e236d58a9b36471712e9c4cc8a9116953c3c4adf9f7bf1ce39bbf9d7097bea2eebb0e305218f0641bd7d1b1db9f64d586b63388bbee751bd813ab208ebf7f9836fefdebd8b0554132f16a357b6ea564b8413a5b8ca009db17cf508780f3495dce74e84dda0bf2e6bdfad64961ad2b8d521d93b665a38abc54189d74340949ccc8aba2fdda5463afeb533d62bad1e60fd0b63fb4d3796bbcaac2a99763d81e5c46044c30fdffea6c741c59bb4d8cee8547923074a6aec768ae3f1e87a2a4cd6d9681da5de415cd490ed6203b55c4282556f90278aa499b26f9cccc23039427d845a03454f00eb7a4848ecdc12a88b78cb8ad1f51fe9e2fe95ad8592d129d89a16d2d71e9bbc8044e70bcefcba180c181e1bf91603927b5bfd9866169ff982ef1c3b29805bf71429d701d853c6388f6c8c87f3613357a5f39f0f23fec65fae839a70c76946704a07fd7a8c7fef00ad6c1e35308b4d99bd696f525497a7e3c9d53044b7f4d4f837823f8c5441715f87169ebf2d6c651e133299c20ff3a1c42e76ab296960501c8c9666a0e14458cd197b7b87fb0dfeaa31b34242653e3471da06afc8d16ffb452528e41f8745412bd179a8e2b90deb49e09ef8f1cbe621d44fef5f0fe44f1ff5b021745ed6b25715f196c77a00e3b87872b61d6eaf4ea5f42b38d3d71efd8c0d23e772003eff5bda31f3cccf4844e0dcdeedc3120b043ab3968d261f126a66c83ace8728772ce426b85a4445f23486a83a4a03f5ee73da3258aeb61e32731e92745fd8a3c573c37c2d1a58910bb342b539e971c57a47201dbb1a48f2375ebec35f50f5c00f49bd8072fbfcb42f5d378de83bd4e8fbd46c2349e760691d052a02659f4aba8109d44b04c7d81ac4f60b0eb769ac36e2f68dcc342249e8bc428d70c1bd06a34891b6e44e007322a8808b20d23b212456623bfba32aeec7e9edc954f6ead458f4838976adfb5cc7d4c8a83e36bef29fb961237d3b48590c76fe3677b3996aa5f2b821e46f0d8c5c97a977c727783d950283b289b773584259016ff4e09f0df04f25ca159b7e23727dd5991d8c28744ec1c00b7b48793db72c69d8a2e7fbc04ad9fb5ff49def0f67886ea9c6bcb782c93f31f453c8c4ec2ad71b4517f4efb258dfb42499e3fea9fbecd081bdae76b645f50847b6eccb76a2521f7a29a4a1ab25509fcbeedd8a09889c601e6ff319339192545896188aee4545ee15d1baaa83203b4814e092ddae1911176f19010f21e9ded8026c4698c4a189f6f9ab6ae02cdaefd0025991fe6b1fca5b2cec1269fd714f172d0ff019c9e234d3192069fec554a16c639ba573d76c9aa66b96b6bcc348ad90ecb374133f145773910d739141d716c28191e5117551f22a6f3d2a379bdea893efb50c48f47cd5d8fbe18728060c71fffa06a50b94574b771f3abedac9d8c42fb0b5e0ee63ec8329806b3141572552571c3258a5f34afd3a36e7d4ae9a50f5dcba4d55515ba1c5d8a55b288f833c4e66aa2d4a9b257e00e7a7b3081b4adfb7e454a760a9060f4f1394544df9808f62ff9873ac5b8065d915edb2263c02d42d17c10fbda6a9e95f3882d53f80901826a54ef80256c52bd2bf97beaf53431a742eaaa0aec714f0891abd80025905114aa3bb9648fe6f72a1f08d2d6efbdbd54b3f75c80f03b4dd5aca56017e582370a2ddcdbcfad0f0b51f8dcc276a4441db187c494310e921dd14faeca5927ad40fd5b6ed70af0edd4e67ed61d8da2b463f71894219b598206fc230b54d62142373113f9976449d4c2f0b850db865775dc88e9880136350989bb42eed3b79265dd793e2f8f7d69d821655b5881aa1e040b307242e7aa74c47a21c43771af94de6ed909339e7846edc9766eadad43b2f1e2a0f45d4d628216829e53a8c68c9e4fb128a6895ddf6db6d469db7938d82e05d2c5a095fa4a20b2ed42a513321a646aa36d5ed5b894f39d7a6ea33e393f1ba981d547715abeb4d8810bab9e3fddadb0810952da941354da3208c609ea9b5cc7177fcda6886ca650f5e2c8a8e8bbf23cf933c598943ff5319963d0d493cc2674af808308a1c416041846e4c9f6eb79f3514cb6a24eb32cec7f10009aea4f6f3d8d9b2e548e86e0b7d12873d8050f36b4647c670d243a4d34872466cb77b7925e11d4fbee4adad7fdffddc3f56e77fd7d421160c6c3d479760557a003e994e153339b76387ba4ab714c0e83561bdcff4bc077c39e6b996979bc5026d3933a4f06cd2543a7a6fc80e31d6f91265f1d02b59c79f7f9cb2428752ccb34f1b66318dfdfce817dafda94f53befe5eaf1d9737d4120143f6dde1ba98361a06773f2bd4f1ad34265fa195622557844b92e35e0174f6fdc5090766144f55426e794641586172b9200c12f61036f5e1f851799bc189febb532e194187f2473473f64676d16e7b72660d2311d059d9cb786531a958f85fe29002b511ecb6249b44f37bec5373b01dfcb5fd120753322b4b05b9ec74701eff3d0eed2aadaf2d77456c2dc3c3f3e90349dd9100a541b2a9cc1f2cd2378d388847d40dff19c4fd278470e6a3b8b0079e35a218e62861fe19b2b6b13da5bfb558e858f1432d834c82f6c10a6676adf9eed1a6678a4bea3cd8f4202c1796cafcf23a641e5f4215e2e1775b9d8303f8621095a4a3adbc8197a49fc22c76b5f08281a2b4ba651a9ac86ae7eaf67f7151c4b0dbcb64548771a2a3f30e5264706cd22f4e04254bdb6888d2f4f8706d421974448956c11079769ee53c4fc23b3082535392b7ef7233ae471a100defd89991a57a7f8360aeb2cd4728f7b6619dd7eabfbf77de387528357345435d29f9eed9a50ba904a3b0f64329d2b31b53eb3c4b6de0e1fa95b5b983c9e0422e89027a52600a210c9920112732336a641d68c223da5c890641eaa6f71b3ad4606abe183764a8a92ba3ba6b4dfd9a937a3a2ac585e8c714164bb30bc1527d75fcba4492fd0698637ed66f0d8e6ef7bc3ddd2f298a3f5995a616748e8e310d41d7a1890504a2b10d9d07311e793af7618fa6a70b14dec391ff74b233c58f28a395a1ab00782bf31b199a875127de3ca8db4273bde0853232f6a3341e01e3dbb20f5572523bcd91dfc6ba805e543e8422ac74d46a9faf4a5daf420ddcc9a1eec70b7d96b50af96df119148839f9d63faf7c2d33fd3aa46a39ed359a0e31238317367e04f3c8c0c6c92d56504dbedd6daccf41051435afffb5d22c105ecf5746008fd6a28bc3cb900c12cb0f48b7683c2f364137184f02347b68ee383cf60e3161acc56b6f954fdc84148127794eab9af299a29e9c1e14f8c6f7e35b39f318add5a7dd568e3096f8f9f72a2ea62a40bd9acb5bbf53e10253f41abc210a6f5d8df505d5d1567fc4e2c29fb05539e8ede1a1584e0d38b6480c97c955400dfc5e3ba89fc010caeccea5131826332d5c45bf84654f56559c6f10921c933cc123aa2dce496d31dc657860d2333ee48fa2b08748cad960f4c79e47ec7be6ad9a4b89ec27a4900e83f526e0c6f952947233a25300c97fee35b7ccc345891bd72d84817580d1199132750162b9df1938e1cd60a2e72d7732de89e15da71d020f5102cca512fcfb74151d8cd17abad772651d399132338705a611d9988206c82a7e71ee13e7ef51374dfc3ae2c92e4295603fec2fb8467fcbf0c28e28f6944057a4c3a125a97214c20ff8b0258a0aad7ec77023e2a57897a326e84d55b70fa55e61137e284da9179d47ab0d8c10dcbcf58fc56f5038a251ab242b6e950396b216732d57398e7e9fe63ce97d6d84cd72cb6fb2046648a7f5dee72101df686618c02172152209923e774e6b0ee9c387ba9ca7262850855d14d578c4af65729a3c92646c1444f503dfc5e74e21a54a22d6398f3872041ca196f1f17fee866f0fe019ef69803e2a6cf09ec97c7a128d9a60277ae05aa293efa427df090a672ec6cb8a60992a2df3d5c3f729c25c033cfd99ae3841d2cb093eedc2ecd964cfaec2e0ade262bf7b453e9573bc88174263423eb6b7880f640a92d82aed1c398eb8545eb2b20d47f34b28fd9e2b9244c9252256820550093e804a4b67038dacc72d7d0ef3074027f141fb37557b03e62d06a601da9128af67a8fd7e798bd255b15b98ae19362a3800fb422befbb2f40eb8383304d8ab55d69dd72a7697f3e58b0e5a4c587b4dc7dba46c3f160ab1d5d0cde217ea3d06d77696eddc1aa6cf8f692ff2a2c9453eb22e616a9144405c6fc1bb0903e770a0191ccdc909260e442c67c429659ae61caa0a86e84d1388ae6e1417d569d0f4a6d10d359bf998d32454fa4fdc394dfeabf5a7a2d2da6683865b2ea92e3ea41de2c6b76ae207395d47aeffac6481464e682efee6d09d06605728d97cf7d4ed57e12e893d3028b095e32a21605fd9a6309fcc7f0680635fc9b154d35123c189682cdf1206076b5da3bec8ba8b07610f8a66c55522d75e3e58501a7c0a846d26e0e05a80fb111be1dd0bde546e0f6c7206e02bc56813cf09c6940721a31a8b6c6206831e0c81a8bd378845644c77bbdf21bd2adf58154390d8f2e2b8b320b614f7fdcfc7c07398ab69c97cf9b903e14c644dfb4cca632744d9b6f904bff5ed0b2967aafbe136b5d12403eed92021bdac585e4fe26e6a1ad2add3f0ec85e0a2d03c8efcb5ae3407cbe120905744e47f1d854d7c53cbd840f917f8f632d616873a566a3145628a897f59f5d3a53f6a9be13c2e0fa6c8024cf88cc96c7070b19a57b7c68588819528fe8c0822c89c500109660a712cec15eaaa72f9f7fe5e9979336ffd44280775055c3eb08dbfec38020199ad2801b3a7ad51b28118a3a7de00e484243d43162a3daf10ce19761e138d61e672d40d22919998f9c1f199698b0c34811f438f57d881685860f985eaca6758aa50c017ef9a8deb9beebf3419399e207248cc9a434572f5be4687a3013b8076905cb3b8cfaad2988aecb9783a78f583e0f0bf513a778c2c9ba4108d9491c07b42226207cbcb6df0b9967269b0872bd70a250703ab3f86e3e3298daafc9ab7b56d9bd6c029755a145b225bfdb5ca55092563f56d4e8e89eec93939ced38c3a07e8ea28606f472ec1bba23301d1ea8f7784dbf1d964a665324d99e56d928bbabd072887af1658fc5de8eb08a667e6623e4f7cdf63e713a84527d9c951075dfda8fe79174136e5b29a9dc71b988e78845535ce3ba662ab820fce104f255d15f339854929033e6324bdf0610bbb6a0964d3ac77cdcc16b1460d2bc5823f9de67fd2875135faaf7339aac44244d4d8770efcc43976191365cfb724154868db53c41d6376f74327db5c1f6c3a0e744f0842438c6ae605117a5901fd4bb8308b985e5670f8ed748de89c4eb58057c5b9c5b893d0bc3c87f04264553fbdfadf1238a1cafba33cd547fd52e8f568fa8405fb1a2cb837c9decd6007fa4739d879bdeb9f3a8660e742f8155c6a8a41212bd8661d74b83dc554e205838339e0d07a7b63839a4bfc846ebb5485aaa75ca1913906dce6f769269a80883aa3ec5bbc05fa3563194a7326d6aa8d350528e51380a9a3d250c93711a8b19f9da9ee39511ef42b6fb39603ee5819faa3ade670f00077027592d6ce2b97a05d6a59bf10b1e3fd2aa156428d412df862fe72b691f82cda5b3eaaf9d45677a84d1b0bf835b0d832c77eec0a8e69cbb564dec7f186336af63c599ae3c11f675dc275ac810797eb75303d1556b632df0145aa3f1269fe89bf19fb0a81b7d04f0f1fd4917d8bc26474869316ed543913d4a54dc82bd7fe85c37b680d0b3d46d1ec8bf4db3366d62599178e78b682b9050a1776dc294d1031a1de404b7516b254557bd4392f6de7d792cee48b496c13924629b09833d7c01525c6932cabe3d0fe32df975f0e1bbb39318f2f41aa7708be0799be7d20d2078cf16843b0a17eeb955dea52442f685eadf1d61ba577d461fbc2efb437946f91e33f2d8041dfaa6fbf98573978f36182c1a95c0f35783bf83119456734a91583238aaafe2c8bac4550065bbbf9c1c5336d1484fc5e34000d8591beb068c043643916b359675eed6a4d22012e8184d8f8093b176644fd3fed0d1b3e9b3b227b6e6e4cac2598c33870efe16769ba185b86d45de4a1c6231072fcaeb3faf78819c1ccb6890d00bd5cc370a30bc0f33da0e5fddc74fec97f334893a737916df8c6775480149acd368fc1bfa08a21d95bdefe90f49e3051f23a519f34ec53e864deab071a02c060e432c8a05b81bfcae39b55a9d9b03c13b7014d9e5f1e94b2b22a03f54bf3d19492663743a455c45a48133594e4025654e134d9dff8f46c20969c0856848f3884d928d677cebdea729280b1954cee93b020e966e6660b5bd60aa88d62188131977e85d553b75ae3c019c751ae03944b5cd2ca10c25876c03eefe472a6941b614a381db0a5e2c54175163c811d362acd22b34ad02630d4e7814d615a3225d6e96a1cf1af852acee4256170ebdc146ca59df08904d7f231b1c4f58f930290c84066ae058ed58cc99cb1d082d256dae1724def8ef5c16daf7029f54dc36025e3f173d640e9b26e62adf9d\n      \n      \n        \n          \n          \n            请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n          \n        \n        \n      \n    \n    ","categories":["游记"]},{"title":"bitset学习笔记","url":"/posts/8ee3bcd9/","content":"参考文章\n一直不会用 bitset，今天终于下定决心学一下。\nbitset 是一个很好用的 STL，且时间复杂度和空间复杂度都很优秀。\nbitset 是一个 01 串，每一位占一个 bit。\nbitset 的下标是从右往左的。例如 f_1=1，那么得到的 bitset 应该是 00010 之类的东西。\n所以后面的左移右移才是那样。\n如何声明首先，我们需要引用 &lt;bitset&gt; 头文件。\n声明方式为\nbitset&lt;maxn&gt; s;\nmaxn 为长度。\n修改与运算bitset 中每一个元素可以通过下标的方式访问。\n进行单点修改时，直接访问位置然后赋值即可。\ns[pos]=1;\nbitset 还支持位运算，返回值为一个 bitset。\ns&lt;&lt;=x;s&gt;&gt;=x;s&amp;=s1;s|=s1;s^=s1;\n复杂度设计算机字长为 \\omega，则一次操作的复杂度为 O(\\frac{n}{\\omega})。\n因为 \\omega 位才占一个整形长度，所以空间复杂度为 O(\\frac{n}{\\omega})。\n成员函数1.reset\n将 bitset 每一位都置为 0。\ns.reset();\n2.set\n如果不传参数，会将每一位都置为 1。复杂度 O(\\frac{n}{\\omega})。\n如果传参数，那么第一个参数为 pos，第二个参数为 val，意为把第 pos 位置为 val。\n如果不传 val，那么默认为 1。\ns.set();s.set(1);s.set(1,0);\n3.test\n有一个参数 pos，返回第 pos 位的值。\ns.test(1);\n4.any\n若 bitset 内存在 1，则返回 1，否则返回 0。\ncout&lt;&lt;s.any();\n5.none\n若 bitset 内所有位都是 0，则返回 1，否则返回 0。\ncout&lt;&lt;s.none();\n6.all\n若 bitset 内所有位都是 1，则返回 1，否则返回 0。\ncout&lt;&lt;s.all();\n7.count\n返回 bitset 内 1 的个数。\ncout&lt;&lt;s.count();\n8.flip\n把每一位取反。\n如果传参数 pos，那么就把第 pos 位取反。\ns.flip();s.flip(1);\n9._Find_first\n返回 bitset 第一个 1 的位置，不存在则返回 bitset 大小。\ncout&lt;&lt;s._Find_first();\n10._Find_next\n需要传参数 pos，返回下标严格大于 pos 的位置中第一个 1 的位置。\ncout&lt;&lt;s._Find_next(1);\n应用bitset 优化 dp对于一些可行性 dp，可以 bitset 优化。\nP1537 弹珠这是一道多重背包，不过可以当 01 背包做。\n但这是可行性背包，所以用 bitset 优化一下就可以了。\n复杂度为 O(\\frac{n\\sum w_i}{\\omega})\n这里给出优化 01 背包的代码。\nf.set(0);for(re int i=1;i&lt;=n;++i) f|=(f&lt;&lt;w[i]);\nEarn or Unlock *2200首先可以发现，如果最后一共解锁了 x 张牌，那么分数为 (\\sum_{i=1}^x a_i)-(x-1)。\n因为我们一开始只有一张牌，想解锁剩下的 x-1 张就必须花 x-1 的代价。\n然后显然解锁的牌可以都拿，那么就是一个前缀和再减去代价。\n所以我们只需要判断是否存在一种方案使得恰好解锁 x 张牌即可。\n复杂度 O(n^2) 的 dp 显然，考虑优化。\n但这是可行性 dp，可以用 bitset 优化。\n事实上也是个 01 背包。\n复杂度 O(\\frac {n^2}{\\omega})\n一些细节：\n\nx 可以达到 2n。\n\n这里的背包比较特殊，因为如果我们用第 i 张牌解锁后面的牌，那么恰好解锁 i 张牌这个状态也就不能为后续提供转移了。所以我们还需要再开个数组，记录每种值能否被恰好取到。\n\n\nbitset 结合莫队[Ynoi2017] 由乃的玉米田区间询问可离线，考虑莫队。\n我们维护两个 bitset，分别为 v1 和 v2。\n设值域为 V。\n如果 x 在当前区间出现，那么 v1[x]=v2[V-x]=1。\n对于减法操作，答案为 (v1&amp;(v1&lt;&lt;x)).any()。\n这很好理解。\n假设 a-b=x，那么当前区间一定存在 a 和 a-x。\n所以我们把 v1 和 (v1&lt;&lt;x) 与一下，看看能否满足即可。\n对于加法操作，答案为 (v1&amp;(v2&gt;&gt;(V-x))).any()。\n设 b'=V-b，那么 b 在 v1 和 b' 在 v2 中是对应的。\n假设 a+b=x，那么 a+V-b'=x。\n再移项一下，那么 a-b'=x-V。\n这里已经转化成减法了。\n因为 x-V 是负数，所以把左移变成右移。\n所以我们把 v1 和 (v2&gt;&gt;(V-x)) 与一下，看看能否满足即可。\n对于乘法操作，我们可以考虑枚举约数，然后看 i 和 \\frac {x}{i} 是否都存在。\n这个复杂度是 O(\\sqrt n) 的。\n对于除法操作，考虑根号分治。\n对于 x \\ge \\sqrt V，直接暴力枚举，然后看 i 和 i\\times x 是否都存在即可。\n这个复杂度是 O(\\sqrt n) 的。\n对于 x < \\sqrt V，我们不使用莫队，而是单独处理。\n首先将询问离线，然后枚举 x。\n对于每个 x，我们扫一遍序列。\n记 last_i 表示 i 当前最后一次出现的位置。\n记 ans_i 表示满足在 [l,i] 中，同时存在 a_i 和 a_i \\times x 或同时存在 a_i 和 \\frac {a_i}{x} 的最靠右的 l 的位置。 \n设当前扫到 i，那么先更新 last_{a_i}，再用 last_{a_i\\times x} 和 last_{\\frac {a_i}{x}} 更新 res_i 即可。\n扫完以后，我们回答以当前枚举到的 x 作为 x 的询问。\n设询问区间为 [l,r]，那么只要 l \\le res_r，该询问就合法。\n因为 x 只有 \\sqrt V 个，所以复杂度为 O(n\\sqrt n)\n综上，总复杂度为 O(n\\sqrt n)。\ncode：\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e5+10,V=1e5,lim=300;int n,m,Q,siz;int a[maxn],buc[maxn],lst[maxn],res[maxn];struct query&#123;    int op,l,r,x,id;&#125;q[maxn];bitset&lt;maxn&gt; v1,v2,ans;vector&lt;query&gt; q1[maxn];inline bool cmp(query a,query b)&#123;return ((a.l/siz)^(b.l/siz))?(a.l/siz)&lt;(b.l/siz):((a.l/siz)&amp;1)?a.r&lt;b.r:a.r&gt;b.r;&#125;inline void add(int x)&#123;    ++buc[x];    v1[x]=v2[V-x]=(buc[x]);&#125;inline void del(int x)&#123;    --buc[x];    v1[x]=v2[V-x]=(buc[x]);&#125;inline void solve()&#123;    for(re int x=1,l;x&lt;=lim;++x)&#123;        memset(lst,0,sizeof lst);        memset(res,0,sizeof res);        l=0;        for(re int i=1;i&lt;=n;++i)&#123;            lst[a[i]]=i;            if(x*a[i]&lt;=V) l=max(l,lst[x*a[i]]);            if(a[i]%x==0) l=max(l,lst[a[i]/x]);            res[i]=l;        &#125;        for(auto v:q1[x]) ans[v.id]=(v.l&lt;=res[v.r]);    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;Q;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];    for(re int i=1,op,l,r,x;i&lt;=Q;++i)&#123;        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r&gt;&gt;x;        if(op==4&amp;&amp;x&lt;=lim) q1[x].push_back(&#123;op,l,r,x,i&#125;);        else q[++m]=&#123;op,l,r,x,i&#125;;    &#125;    solve();    siz=sqrt(n)+1;    sort(q+1,q+m+1,cmp);    int l=1,r=0;    for(re int i=1;i&lt;=m;++i)&#123;        while(r&lt;q[i].r) add(a[++r]);        while(l&gt;q[i].l) add(a[--l]);        while(r&gt;q[i].r) del(a[r--]);        while(l&lt;q[i].l) del(a[l++]);        if(q[i].op==1) ans[q[i].id]=(v1&amp;(v1&lt;&lt;q[i].x)).any();        if(q[i].op==2) ans[q[i].id]=(v1&amp;(v2&gt;&gt;(V-q[i].x))).any();        if(q[i].op==3) for(re int j=1;j*j&lt;=q[i].x;++j) if(!(q[i].x%j)) if(v1[j]&amp;&amp;v1[q[i].x/j]) ans[q[i].id]=1;        if(q[i].op==4) for(re int j=1;j*q[i].x&lt;=V;++j) if(v1[j]&amp;&amp;v1[j*q[i].x]) ans[q[i].id]=1;    &#125;    for(re int i=1;i&lt;=Q;++i) cout&lt;&lt;(ans[i]?&quot;yuno&quot;:&quot;yumi&quot;)&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n","categories":["学习笔记"],"tags":["数据结构","莫队","dp"]},{"title":"Slope Trick学习笔记","url":"/posts/58d4c0dc/","content":"参考文章\n引入太困难了···\nSlope Trick 是一种维护凸包的方法，通常用来优化 dp。\n一般可以使用 Slope Trick 优化的 dp 方程需要满足：\n\n是连续的\n是分段一次函数\n有凸性\n\n一些性质：\n\n两个凸函数相加还是凸函数\n凸函数加一次函数还是凸函数\n\n一些名词：\n\n拐点：函数斜率改变的点\n决策点：纵坐标为答案的点\n\n\n具体内容通过例题讲解，不然还是太难懂了。\n例题Sequence *2200首先考虑暴力 dp。\n因为要将序列变为非降数列，所以有一个性质：最终序列的数集不会变大。\n证明很好证：\n因为只有序列某一位置严格递减时，我们才会进行修改。\n而修改要么将前面的数减到和后面的数一样大，要么将后面的数加到和前面的数一样大。\n这两个操作都不会让数集变大。\n所以设 f_{i,j} 表示将第 i 个数变为 j 的最小代价，转移为\n\nf_{i,j}=\\min_{k \\le j} f_{i-1,k}+|a_i-j|这是 O(n^2) 的，虽然能通过本题，但我们考虑优化。\n我们把这个 dp 变一下，方便理解。\n设 f_{i,j} 表示将第 i 个数变为 j 的最小代价，g_{i,j} 表示将第 i 个数变为 \\le j 的最小代价。\n则转移为\n\nf_{i,j}=g_{i-1,j}+|a_i-j|\n\\\\\ng_{i,j}=\\min_{k\\le j} f_{i,k}我们固定 i ，以 j 为横坐标，dp 值为纵坐标建系。\n这里偷同学几张图。\n可以得到，f_1 为：\n\n因为 g 是 f 的前缀 \\min，所以 g_1 为：\n\n根据 dp 式可以发现，g_2 是由 f_1 这个函数加一个绝对值函数得到的。\n这里需要分类讨论：绝对值函数的拐点在 f_1 的决策点的左/右侧。\n如果在右侧，那么是这样的\n\n相加后可以得到 g_2 为\n\n从而可以得到 f_2 为\n\n如果在左侧，那么是这样的\n\n相加后可以得到 g_2 为\n\n从而可以得到 f_2 为\n\n答案为 f_n 的最小值。\n可以发现，只有绝对值函数的拐点在决策点左侧时，答案才会更新。\n那么答案变化了多少呢？\n\n图中 BAGH 为原来的 f_i，JCK 为加的绝对值函数，BMNO 为加完以后的 f_i'。\n那么答案的变化量为 N 和 G 的纵坐标之差。\n通过观察几何性质，可以发现这东西就等于原绝对值函数拐点的横坐标。\n然后考虑怎么维护函数 f_i。（接下来我可能会说的比较抽象且啰嗦，因为我实在不知道怎么才能说明白）\n我们可以维护一个堆，堆里存函数的所有拐点。这道题中我们需要维护大根堆，这样堆顶就是我们需要的决策点。\n然后我们把斜率挂到点上维护，当然我们需要钦定每个点维护的是左侧的线段还是右侧的线段。\n这里我们钦定每个点维护左侧的线段的斜率。\n\n那这个斜率到底怎么表示呢？别急，看下面。\n然后考虑加绝对值函数的操作。可以发现，这个操作事实上就是在让绝对值函数拐点左侧的函数斜率 -1，拐点右侧的函数斜率 +1。\n当拐点在决策点右侧或决策点上时，我们会让拐点左侧的函数斜率 -1，右侧的函数斜率 +1。但因为取 \\min 了，所以右侧函数斜率还是 0。\n对应到操作上，就是把绝对值函数拐点加进堆里。\n可以发现，此时堆中每个点维护的对应线段的斜率就是其在堆中排名 -1 的相反数（因为这个函数的斜率都是负数）。\n如果如果相邻两个点间的斜率差  > 1 怎么办？\n那就把一个点插入多次。\n但这样会存在一些假点，这些点并没有意义。\n所以我们的斜率要变一下：堆中每个点维护的对应线段的斜率就是与其值相同的最左侧的点在堆中排名 -1 的相反数。\n当拐点在决策点左侧时，因为要让拐点左侧的函数斜率 -1，右侧的函数斜率 +1，所以对应到操作上应该插入两个拐点，因为斜率变化为 2。\n插入完后，我们还要把原来的决策点扔掉，因为它已经不是当前的决策点了。\n然后我们维护完了这个函数，且求出了答案。\n复杂度 O(n\\log n)\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;int n,ans;priority_queue&lt;int&gt; q;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    int x;    cin&gt;&gt;n&gt;&gt;x;    q.push(x);//第一个点先直接插进去    for(re int i=2;i&lt;=n;++i)&#123;        cin&gt;&gt;x;        if(x&gt;=q.top()) q.push(x);//拐点在决策点的右侧或决策点原位        else&#123;            //拐点在决策点左侧            ans+=q.top()-x;//加上答案变化量            q.push(x);//插两个是因为斜率变化量为2            q.push(x);            q.pop();//把原来的决策点扔掉，因为它已经不是当前的决策点了        &#125;    &#125;    cout&lt;&lt;ans;    return 0;&#125;\nBuy Low Sell High *2400首先考虑暴力 dp。\n设 f_{i,j} 表示第 i 天有 j 股的最大值，转移为\n\nf_{i,j}=\\max (f_{i-1,j},f_{i-1,j+1}+a_i,f_{i-1,j-1}-a_i)答案为 f_{n,0}。\n感性理解一下，可以发现这个函数是凸的。\n但这个函数的变化就不是每次加一个凸函数了，而是函数平移然后取 \\max。\n第一个转移可以直接转移过来，这样后面的取 \\max 都是和原函数取 \\max 了。\n后面的两个转移可以看成把函数加一个平移向量 (-1,a_i) 和 (1,-a_i)。\n先考虑左上平移：\n图中 A1B1C1D1 为平移后的函数。\n\n取完 \\max 后长这样\n\n对于左上平移，可以发现，原函数中斜率 \\ge 移动斜率的的部分都会被平移后的函数在取 \\max 时覆盖掉，而 ","categories":["学习笔记"],"tags":["dp"]},{"title":"test","url":"/posts/d87f7e0c/","content":"\n      \n        80435f95779c19f510f0615646a4fd27b95a3fdc6113f4b8cc804bf6e3859511de6f8566e8eacb9a1780c252ae9761965e6ad2982b0fdfaea4a739606af834029c3d519f7533cdc89b3709da07ce53d30f1e416d09111f120f82ba8d897e0454fac5effc1a530ae55a9941982aae2fd91776ce5ed693e01c2fbe840c5a2322e1b146655f4159cb1cd000b384e67fa222\n      \n      \n        \n          \n          \n            请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n          \n        \n        \n      \n    \n    "},{"title":"值域分块学习笔记","url":"/posts/323f9b89/","content":"参考文章\n又是一个很有用但一直不会的东西，今天学习一下。\n不过写的还是比较浅显，可以看参考文章，讲的很好。\n什么是值域分块普通的分块都学过，它是对序列分块的。\n而值域分块，顾名思义，是对值域分块。\n序列分块和值域分块的关系就像线段树和权值线段树的关系一样，一个维护序列，一个维护值域。\n两种常用的值域分块第一种：修改 O(1)，查询 O(\\sqrt n)\n维护每个值域上每个值的值和每个值域块内的值的总和。\ninline void add(int x)&#123;++cnt1[x],++cnt2[bel[x]];&#125;inline int query1(int l,int r)&#123;    int L=bel[l],R=bel[r],res=0;    if(L==R) for(re int i=l;i&lt;=r;++i) res+=cnt1[i];    else&#123;        for(re int i=l;i&lt;=ed[L];++i) res+=cnt1[i];        for(re int i=st[R];i&lt;=r;++i) res+=cnt1[i];        for(re int i=L+1;i&lt;=R-1;++i) res+=cnt2[i];    &#125;    return res;&#125;\n第二种：修改 O(\\sqrt n)，查询 O(1)\n维护每个值域上每个值的值的前缀和，修改时整块打标记，散块暴力加。\n区间查询可以差分成两个前缀和。\ninline void add(int x)&#123;    if(tag1[bel[x]])&#123;        for(re int i=st[bel[x]];i&lt;=ed[bel[x]];++i) cnt[i]+=tag1[bel[x]];        tag1[bel[x]]=0;    &#125;    if(tag2[bel[x]])&#123;        for(re int i=st[bel[x]];i&lt;=ed[bel[x]];++i) sum[i]+=tag2[bel[x]];        tag2[bel[x]]=0;    &#125;    for(re int i=x;i&lt;=ed[bel[x]];++i) ++cnt[i],sum[i]+=x;    for(re int i=bel[x]+1;i&lt;=tot;++i) ++tag1[i],tag2[i]+=x;&#125;inline int query1(int x)&#123;return tag1[bel[x]]+cnt[x];&#125;inline int query2(int x)&#123;return tag2[bel[x]]+sum[x];&#125;\n应用值域分块一般用来平衡复杂度。\n例如莫队，我们有 O(n\\sqrt n) 次修改和  O(n) 次查询，这时可以用 O(1) 修改，O(\\sqrt n) 查询的值域分块平衡复杂度。\n而如果用 O(\\log n) 修改，O(\\log n) 查询的其他数据结构，复杂度就来到了混乱邪恶的 O(n\\sqrt n \\log n)，不可接受。\n值域分块配合莫队[AHOI2013] 作业可以说是板子题了。\n使用 O(1) 修改，O(\\sqrt n) 查询的值域分块。\n复杂度 O(n\\sqrt n)。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e5+10,maxm=500;int n,m,siz,tot;int a[maxn];int ans1[maxn],ans2[maxn];int st[maxm],ed[maxm],bel[maxn];int cnt1[maxm],cnt2[maxn],cnt3[maxm];struct query&#123;    int l,r,a,b,id;&#125;q[maxn];inline bool cmp(query a,query b)&#123;return ((a.l/siz)^(b.l/siz))?(a.l/siz)&lt;(b.l/siz):((a.l/siz)&amp;1)?a.r&lt;b.r:a.r&gt;b.r;&#125;inline void init()&#123;    siz=sqrt(n);    tot=n/siz;    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;n) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=n;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i;&#125;inline void add(int x)&#123;    if(!cnt2[x]) ++cnt3[bel[x]];    ++cnt1[bel[x]];    ++cnt2[x];&#125;inline void del(int x)&#123;    --cnt1[bel[x]];    --cnt2[x];    if(!cnt2[x]) --cnt3[bel[x]];&#125;inline int get_ans1(int l,int r)&#123;    int L=bel[l],R=bel[r];    int res=0;    if(L==R) for(re int i=l;i&lt;=r;++i) res+=cnt2[i];    else&#123;        for(re int i=l;i&lt;=ed[L];++i) res+=cnt2[i];        for(re int i=st[R];i&lt;=r;++i) res+=cnt2[i];        for(re int i=L+1;i&lt;=R-1;++i) res+=cnt1[i];    &#125;    return res;&#125;inline int get_ans2(int l,int r)&#123;    int L=bel[l],R=bel[r];    int res=0;    if(L==R) for(re int i=l;i&lt;=r;++i) res+=(bool)cnt2[i];    else&#123;        for(re int i=l;i&lt;=ed[L];++i) res+=(bool)cnt2[i];        for(re int i=st[R];i&lt;=r;++i) res+=(bool)cnt2[i];        for(re int i=L+1;i&lt;=R-1;++i) res+=cnt3[i];    &#125;    return res;&#125;signed main()&#123;    #ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);    #endif\t    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];    for(re int i=1;i&lt;=m;++i) cin&gt;&gt;q[i].l&gt;&gt;q[i].r&gt;&gt;q[i].a&gt;&gt;q[i].b,q[i].id=i;    init();    sort(q+1,q+m+1,cmp);    int l=1,r=0;    for(re int i=1;i&lt;=m;++i)&#123;        while(r&lt;q[i].r) add(a[++r]);        while(l&gt;q[i].l) add(a[--l]);        while(r&gt;q[i].r) del(a[r--]);        while(l&lt;q[i].l) del(a[l++]);        ans1[q[i].id]=get_ans1(q[i].a,q[i].b);        ans2[q[i].id]=get_ans2(q[i].a,q[i].b);    &#125;    for(re int i=1;i&lt;=m;++i) cout&lt;&lt;ans1[i]&lt;&lt;&quot; &quot;&lt;&lt;ans2[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n[Ynoi2019 模拟赛] Yuno loves sqrt technology II区间逆序对，不难想到用树状数组维护修改。\n但这样复杂度是 O(n\\sqrt n \\log n) 的，不能接受。\n但可以发现，这个贡献是可以差分的，所以考虑莫队二次离线。\n这里还是把二离详细说一下吧（毕竟我也不太懂）。\n假设当前在区间 [l,r]。\n我们分四种情况讨论指针的移动。\n1.右指针右移\n考虑当前到的位置 r+1，此时会产生的新贡献是 [l,r] 里大于 a_{r+1} 的个数。\n可以差分成 [1,r] 中大于 a_{r+1} 的个数减去 [1,l-1] 大于 a_{r+1} 的个数。\n2.右指针左移\n考虑当前到的位置 r-1，此时会减少的贡献是 [l,r-1] 里大于 a_r 的个数。\n可以差分成 [1,r-1] 中大于 a_r 的个数减去 [1,l-1] 大于 a_r 的个数。\n3.左指针左移\n考虑当前到的位置 l-1，此时会产生的新贡献是 [l,r] 里小于 a_{l-1} 的个数。\n可以差分成 [1,r] 中小于 a_{l-1} 的个数减去 [1,l-1] 小于 a_{l-1} 的个数。\n4.左指针右移\n考虑当前到的位置 l+1，此时会减少的贡献是 [l+1,r] 里小于 a_l 的个数。\n可以差分成 [1,r] 中小于 a_l 的个数减去 [1,l] 小于 a_l 的个数。\n请注意上文的减少，因为是减少下面的那个东西，所以要记得变号。\n然后可以发现有一些可以预处理出来。\n例如 [1,i-1] 中 > a_i 的个数，[1,i] 中 < a_i 的个数。\n然后剩下的部分离线下来，一共 O(n) 次修改和 O(n\\sqrt n) 次询问。\n然后扫描线，用数据结构维护剩下形如：每次求一个前缀中 > x 或 < x 的数的个数。\n这让你想到了什么？值域分块！\n我们用 O(\\sqrt n) 修改，O(1) 查询的值域分块维护这个东西。\n最后，别忘了我们上面讨论的都是变化量，相当于答案的差分，所以最后还要求个前缀和得到答案。\n我们如果直接存 O(n\\sqrt n) 次询问，空间复杂度是 O(n\\sqrt n) 的。\n但是不难发现，莫队每次的指针移动是一段区间，所以直接把这一段区间一块存下来就行了。\n空间复杂度变为 O(n)。\n这是莫队二离的一个经典优化。\n#include&quot;bits/stdc++.h&quot;#define re register// #define int long long#define lb(x) (x&amp;(-x))using namespace std;const int maxn=1e5+10,maxm=500;int n,m,siz,tot,len;int a[maxn],b[maxn],tr[maxn];int st[maxm],ed[maxm],bel[maxn],idx[maxn];int fl[maxn],fr[maxn];int cnt[maxn],tag[maxm];long long ans[maxn];struct query&#123;    int l,r,id;    long long ans;&#125;q[maxn];struct node&#123;    int l,r,id,op;&#125;;vector&lt;node&gt; g1[maxn],g2[maxn];inline bool cmp(query a,query b)&#123;return ((a.l/siz)^(b.l/siz))?(a.l/siz)&lt;(b.l/siz):((a.l/siz)&amp;1)?a.r&lt;b.r:a.r&gt;b.r;&#125;inline void add(int x,int val)&#123;while(x&lt;=maxn) tr[x]+=val,x+=lb(x);&#125;inline int query(int x)&#123;int res=0;while(x&gt;0) res+=tr[x],x-=lb(x);return res;&#125;inline void pre()&#123;    for(re int i=1;i&lt;=n;++i)&#123;        fr[i]=i-1-query(a[i]);        add(a[i],1);    &#125;    for(re int i=1;i&lt;=n;++i) add(a[i],-1);    for(re int i=1;i&lt;=n;++i)&#123;        add(a[i],1);        fl[i]=query(a[i]-1);    &#125;&#125;inline void init()&#123;    siz=sqrt(len);    tot=ceil(len/siz);    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;len) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=len;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i,idx[j]=j-st[i]+1;&#125;inline void update(int x,int val)&#123;    if(tag[bel[x]])&#123;        for(re int i=st[bel[x]];i&lt;=ed[bel[x]];++i) cnt[i]+=tag[bel[x]];        tag[bel[x]]=0;    &#125;    for(re int i=x;i&lt;=ed[bel[x]];++i) cnt[i]+=val;    for(re int i=bel[x]+1;i&lt;=tot;++i) tag[i]+=val;&#125;inline int query1(int x)&#123;return tag[bel[x]]+cnt[x];&#125;inline void solve_l()&#123;    for(re int i=1;i&lt;=n;++i)&#123;        update(a[i],1);        for(auto t:g1[i])&#123;            for(re int j=t.l;j&lt;=t.r;++j)&#123;                q[t.id].ans+=t.op*(i-query1(a[j]));            &#125;        &#125;    &#125;    for(re int i=1;i&lt;=n;++i) update(a[i],-1);&#125;inline void solve_r()&#123;    for(re int i=1;i&lt;=n;++i)&#123;        update(a[i],1);        for(auto t:g2[i])&#123;            for(re int j=t.l;j&lt;=t.r;++j)&#123;                q[t.id].ans+=t.op*query1(a[j]-1);            &#125;        &#125;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],b[i]=a[i];    sort(b+1,b+n+1);    len=unique(b+1,b+n+1)-(b+1);    for(re int i=1;i&lt;=n;++i) a[i]=lower_bound(b+1,b+len+1,a[i])-b;    pre();    for(re int i=1;i&lt;=m;++i) cin&gt;&gt;q[i].l&gt;&gt;q[i].r,q[i].id=i;    siz=sqrt(n);    sort(q+1,q+m+1,cmp);    int l=1,r=0;    for(re int i=1;i&lt;=m;++i)&#123;        if(r&lt;q[i].r)&#123;            g1[l-1].push_back(&#123;r+1,q[i].r,i,-1&#125;);            while(r&lt;q[i].r) q[i].ans+=fr[++r];        &#125;        if(l&gt;q[i].l)&#123;            g2[r].push_back(&#123;q[i].l,l-1,i,1&#125;);            while(l&gt;q[i].l) q[i].ans-=fl[--l];        &#125;        if(r&gt;q[i].r)&#123;            g1[l-1].push_back(&#123;q[i].r+1,r,i,1&#125;);            while(r&gt;q[i].r) q[i].ans-=fr[r--];        &#125;        if(l&lt;q[i].l)&#123;            g2[r].push_back(&#123;l,q[i].l-1,i,-1&#125;);            while(l&lt;q[i].l) q[i].ans+=fl[l++];        &#125;    &#125;    init();    solve_l();    solve_r();    for(re int i=1;i&lt;=m;++i) q[i].ans+=q[i-1].ans;    for(re int i=1;i&lt;=m;++i) ans[q[i].id]=q[i].ans;    for(re int i=1;i&lt;=m;++i) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n值域分块配合根号分治[JRKSJ R4] risrqnis很好的一道题，加深了我对根号分治和平衡复杂度的理解。\n首先考虑 m=1 怎么做。\n这个对值域上的操作很讨厌，因为值域很大。\n但不难发现，把所有操作离线后离散化，可以做到值域 O(n)，且每个数至多被加入一次。\n所以我们把每个数挂到对应的值上，然后用 set 维护还没有被加入的数，每次加入时查值域上的前驱后继即可。至于求和，树状数组维护即可。\n这样做的话，均摊复杂度是 O(n\\log n) 的。\n那 m \\le 10^9 怎么办？\n首先可以把 m 离散化到 O(n)。\n然后关键来了：考虑对每个集合的操作次数根号分治。\n对于操作次数 > \\sqrt n 的集合，个数是 O(\\sqrt n) 的，那么我们直接按上面那个做法做，总复杂度是 O(n\\sqrt n \\log n) 的。\n但这个复杂度是不能接受的。\n但可以发现，我们一共有 O(n\\sqrt n) 次修改和 O(n) 次查询（这里可能会有疑惑：每个集合的修改和询问不都是 O(n) 的吗？那总的操作为什么不都是 O(n\\sqrt n)？因为总的操作次数一共是 O(n) 的，而修改是值域上的修改，所以可以保证每个集合都做到 O(n) 次修改，但查询是有总和保证的，总询问一定也是 O(n) 的）。\n所以可以用序列分块来平衡复杂度，这样可以做到 O(1) 修改，O(\\sqrt n) 查询。\n然后瓶颈就是 set 每次查找的 O(\\log n) 了，我们考虑去掉这个 \\log 。\n一开始想到的是链表，但链表删除虽然是 O(1)，但每次还得找第一个没被删的，这是 O(n) 的。\n然后想到并查集，发现可以做。\n思路还是和链表一样，每删一个就更新父亲，相当于把那个数删除了。\n每次找的时候也是找父亲。\n总复杂度为 O(n\\sqrt n \\alpha(n))\n然后考虑操作次数 < \\sqrt n 的集合。\n这种集合的个数是 O(n) 的，但操作次数是 O(\\sqrt n) 的。\n这可以得到一个很关键的性质：操作后的值域上的连续段个数不超过 O(\\sqrt n)。\n然后我们再想想询问在干什么：求值域上在已经出现过的连续段内且序列上下标在 [l,r] 之间的点的个数。\n这是个标准的二维数点。\n因为连续段个数不超过 O(\\sqrt n)，所以询问可以看成对 O(\\sqrt n) 个连续段分别查询。\n那么一共有 O(n) 次修改和 O(n\\sqrt n) 次询问（这里可能又有疑惑：一共 O(n) 个集合，每个集合修改次数都是 O(n) 的，那为什么总修改次数还是 O(n) 的？因为可以发现，具体是哪个集合对答案没有影响，所以我们可以先把所有询问离线下来，这样一共有 O(n\\sqrt n) 次询问，但我们只需要修改 O(n) 次即可）。\n考虑扫描序列维，然后用值域分块维护另一维。\n总复杂度 O(n\\sqrt n)\n综上，总复杂度为 O(n\\sqrt n \\alpha(n))。\n但你先别急，因为这东西空间复杂度是 O(n\\sqrt n)，直接炸了。\n然后有一些神奇技巧来优化空间，例如离线逐块处理，分散层叠等。\n但我摆了。\n还有个坑点，在处理小块的时候，我们要离线询问，但是不能直接离线。\n例如第一次修改，把值域 [l_1,r_1] 加进去，第二次修改，把值域 [l_2,r_2] 加进去。\n如果这两段有交，那么交集部分不能算两次，只能算一次。\n所以离线询问时要处理这个东西。\n注意特殊处理 m=1 ，因为空间开不下。\n还有注意离散化后值域是 3\\times 10^6\n代码是空间 O(n\\sqrt n) 的，只能得 45 pts。\n#include&quot;bits/stdc++.h&quot;#define re register// #define int long long#define pii pair&lt;int,int&gt; #define fi first#define se second#define lb(x) (x&amp;(-x))using namespace std;const int maxn=1e6+10,maxm=1750;int n,m,Q,siz,tot,cnt;int a[maxn],b[3*maxn],ans[maxn],fa[maxn*3];int st[maxm],ed[maxm],bel[maxn],idx[maxn];int sum1[maxn],sum2[maxm];pii stk[maxn];int cnt1[maxn*3],cnt2[maxm][maxm];struct query&#123;    int op,l,r,k,id;&#125;q[maxn];vector&lt;int&gt; g[maxn],s[maxn];vector&lt;query&gt; q1[maxn];inline void init()&#123;    int tmp=max(n,cnt);    siz=sqrt(tmp);    tot=ceil(tmp/siz);    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;tmp) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=tmp;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i,idx[j]=j-st[i]+1;&#125;inline void clear()&#123;    for(re int i=1;i&lt;=cnt+1;++i) fa[i]=i;    memset(sum1,0,sizeof sum1),memset(sum2,0,sizeof sum2);&#125;inline void add(int x)&#123;++sum1[x],++sum2[bel[x]];&#125;inline int query(int l,int r)&#123;    int L=bel[l],R=bel[r],res=0;    if(L==R) for(re int i=l;i&lt;=r;++i) res+=sum1[i];    else&#123;        for(re int i=l;i&lt;=ed[L];++i) res+=sum1[i];        for(re int i=st[R];i&lt;=r;++i) res+=sum1[i];        for(re int i=L+1;i&lt;=R-1;++i) res+=sum2[i];    &#125;    return res;&#125;inline int find(int x)&#123;if(x!=fa[x]) fa[x]=find(fa[x]);return fa[x];&#125;inline void solve1(int id)&#123;    clear();    for(auto x:g[id])&#123;        if(q[x].op==1)&#123;            int pos=find(q[x].l);            while(pos&lt;=q[x].r)&#123;                for(auto v:s[pos]) add(v);                fa[pos]=fa[pos+1];                pos=find(pos+1);            &#125;        &#125;        else ans[q[x].id]=query(q[x].l,q[x].r);    &#125;&#125;inline void solve2(int id)&#123;    int top=0;    for(auto x:g[id])&#123;        if(q[x].op==1) stk[++top]=&#123;q[x].l,q[x].r&#125;;        else&#123;            if(!top) continue;            sort(stk+1,stk+top+1);            int nowl=stk[1].fi,nowr=stk[1].se;            for(re int i=2;i&lt;=top;++i)&#123;                if(stk[i].fi&lt;=nowr) nowr=max(nowr,stk[i].se);                else&#123;                    q1[q[x].l-1].push_back(&#123;-1,nowl,nowr,998244353,q[x].id&#125;);                    q1[q[x].r].push_back(&#123;1,nowl,nowr,998244353,q[x].id&#125;);\t                    nowl=stk[i].fi,nowr=stk[i].se;                &#125;            &#125;            q1[q[x].l-1].push_back(&#123;-1,nowl,nowr,998244353,q[x].id&#125;);            q1[q[x].r].push_back(&#123;1,nowl,nowr,998244353,q[x].id&#125;);\t        &#125;    &#125;&#125;inline void update(int x)&#123;    int id=bel[x];    for(re int i=id;i&lt;=tot;++i) ++cnt1[i];    for(re int i=idx[x];i&lt;=idx[ed[id]];++i) ++cnt2[id][i];&#125;inline int query1(int l,int r)&#123;    int L=bel[l],R=bel[r];    long long res=0;    if(L==R) res+=(cnt2[L][idx[r]]-cnt2[L][idx[l]-1]);    else&#123;        res+=(cnt2[L][idx[ed[L]]]-cnt2[L][idx[l]-1]);        res+=(cnt2[R][idx[r]]);        res+=(cnt1[R-1]-cnt1[L]);    &#125;    return res;&#125;inline void solve()&#123;    for(re int i=1;i&lt;=n;++i)&#123;        update(a[i]);        for(auto x:q1[i])&#123;            ans[x.id]+=x.op*query1(x.l,x.r);        &#125;    &#125;&#125;int tr[maxn];inline void add(int x,int val)&#123;while(x&lt;=n) tr[x]+=val,x+=lb(x);&#125;inline int query(int x)&#123;int res=0;while(x) res+=tr[x],x-=lb(x);return res;&#125;inline void solve0()&#123;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],b[i]=a[i],stk[i]=&#123;a[i],i&#125;;    sort(b+1,b+n+1);sort(stk+1,stk+n+1);    for(re int i=1;i&lt;=n+1;++i) fa[i]=i;    int op,l,r,k;    while(Q--)&#123;        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r&gt;&gt;k;        if(op==1)&#123;            l=lower_bound(b+1,b+n+1,l)-b,r=upper_bound(b+1,b+n+1,r)-b-1;            int pos=find(l);            while(pos&lt;=r)&#123;                add(stk[pos].se,1);                fa[pos]=fa[pos+1];                pos=find(pos+1);            &#125;        &#125;        else cout&lt;&lt;query(r)-query(l-1)&lt;&lt;&#x27;\\n&#x27;;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;Q&gt;&gt;m;    if(m==1)&#123;solve0();return 0;&#125;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];    for(re int i=1;i&lt;=Q;++i) cin&gt;&gt;q[i].op&gt;&gt;q[i].l&gt;&gt;q[i].r&gt;&gt;q[i].k,q[i].id=i,b[i]=q[i].k;    sort(b+1,b+Q+1);    m=unique(b+1,b+Q+1)-(b+1);    for(re int i=1;i&lt;=Q;++i) q[i].k=lower_bound(b+1,b+m+1,q[i].k)-b,g[q[i].k].push_back(i);    cnt=0;    for(re int i=1;i&lt;=n;++i) b[++cnt]=a[i];    for(re int i=1;i&lt;=Q;++i) if(q[i].op==1) b[++cnt]=q[i].l,b[++cnt]=q[i].r;    sort(b+1,b+cnt+1);    cnt=unique(b+1,b+cnt+1)-(b+1);    for(re int i=1;i&lt;=n;++i) a[i]=lower_bound(b+1,b+cnt+1,a[i])-b,s[a[i]].push_back(i);    for(re int i=1;i&lt;=Q;++i) if(q[i].op==1) q[i].l=lower_bound(b+1,b+cnt+1,q[i].l)-b,q[i].r=lower_bound(b+1,b+cnt+1,q[i].r)-b;    init();    for(re int i=1;i&lt;=m;++i)&#123;        if(g[i].size()&gt;=sqrt(Q)) solve1(i);        else solve2(i);    &#125;    solve();    for(re int i=1;i&lt;=Q;++i) if(q[i].op==2) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n序列分块套值域分块先来个简单问题：全局 kth。\n权值线段树很好维护对吧，线段树上二分即可。\n考虑值域分块怎么做。\n事实上是类似的。枚举整块，如果超了就枚举块内。\n复杂度 O(n\\sqrt n)\n那现在加强一下：区间 kth。\n【模板】可持久化线段树 2主席树可以做，那分块呢？\n在学值域分块前，我的第一想法是序列分块+二分。\n然而复杂度是 O(n\\sqrt n \\log n)\n能不能把 \\log 去掉呢？\n我们考虑序列分块套值域分块。\n这种值域类数据结构都有非常好的性质：单调性。\n我们先对序列分块，维护块内每个数的出现次数。\n然后对值域分块，维护每个序列块内每个值域块中数的出现次数。\n然后对序列块做上面两个信息的前缀和，这样就可以 O(1) 查询一段块内每个数的出现次数以及每个值域块中数的出现次数。\n这个预处理的复杂度是 O(n\\sqrt n) 的。\n查询时，我们先把散块里的元素放到一个桶里，再把值域块中的数放到一个桶里。\n然后跳值域块，超过 k 时就跳块内的数。\n复杂度 O(n\\sqrt n)\n代码实现里序列块和值域块共用了块长和所有编号，请分清哪个是序列块，哪个是值域块。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e5+10,maxm=500;int n,m,siz,tot;int a[maxn],b[maxn];int st[maxm],ed[maxm],bel[maxn];int cnt1[maxm][maxn],cnt2[maxm][maxm];int buc1[maxn],buc2[maxm];inline void init()&#123;    siz=sqrt(n);    tot=n/siz;    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;n) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=n;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i;&#125;inline void pre()&#123;    for(re int i=1;i&lt;=tot;++i)&#123;        for(re int j=1;j&lt;=n;++j) cnt1[i][j]=cnt1[i-1][j];        for(re int j=1;j&lt;=tot;++j) cnt2[i][j]=cnt2[i-1][j];        for(re int j=st[i];j&lt;=ed[i];++j) ++cnt1[i][a[j]],++cnt2[i][bel[a[j]]];    &#125;&#125;inline int query(int l,int r,int k)&#123;    int L=bel[l],R=bel[r],res=-1,tmp=0,id=0;    if(L==R)&#123;        for(re int i=l;i&lt;=r;++i) ++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=1;i&lt;=tot;++i)&#123;            tmp+=buc2[i];            if(tmp&gt;=k)&#123;                tmp-=buc2[i];                id=i;                break;            &#125;        &#125;        for(re int i=st[id];i&lt;=ed[id];++i)&#123;            tmp+=buc1[i];            if(tmp&gt;=k)&#123;                res=b[i];                break;            &#125;        &#125;        for(re int i=l;i&lt;=r;++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;    &#125;    else&#123;        for(re int i=l;i&lt;=ed[L];++i) ++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=st[R];i&lt;=r;++i) ++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=1;i&lt;=tot;++i)&#123;            tmp+=buc2[i]+cnt2[R-1][i]-cnt2[L][i];            if(tmp&gt;=k)&#123;                tmp-=buc2[i]+cnt2[R-1][i]-cnt2[L][i];                id=i;                break;            &#125;        &#125;        for(re int i=st[id];i&lt;=ed[id];++i)&#123;            tmp+=buc1[i]+cnt1[R-1][i]-cnt1[L][i];            if(tmp&gt;=k)&#123;                res=b[i];                break;            &#125;        &#125;        for(re int i=l;i&lt;=ed[L];++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;        for(re int i=st[R];i&lt;=r;++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;    &#125;    return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif\t    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],b[i]=a[i];    sort(b+1,b+n+1);    int len=unique(b+1,b+n+1)-(b+1);    for(re int i=1;i&lt;=n;++i) a[i]=lower_bound(b+1,b+len+1,a[i])-b;    init();    pre();    for(re int i=1,l,r,k;i&lt;=m;++i)&#123;        cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;        cout&lt;&lt;query(l,r,k)&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n那再加强一下：单点修。\nDynamic Rankings因为我们预处理的是前缀和，所以要更改 O(\\sqrt n) 的块。\n代码基本相同。\n但如果你还把两种块的编号并用，请注意元素个数可能会 > n。\n代码里的 n=cnt 就是解决这一情况的。\n#include&quot;bits/stdc++.h&quot;#define re register// #define int long longusing namespace std;const int maxn=2e5+10,maxm=500;int n,m,siz,tot,cnt;int a[maxn],b[maxn];int st[maxm],ed[maxm],bel[maxn];int cnt1[maxm][maxn],cnt2[maxm][maxm];int buc1[maxn],buc2[maxm];struct query&#123;    int op;    int l,r,k;    int x,y;&#125;q[maxn];inline void init()&#123;    n=cnt;    siz=sqrt(n);    tot=n/siz;    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;n) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=n;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i;&#125;inline void pre()&#123;    for(re int i=1;i&lt;=tot;++i)&#123;        for(re int j=1;j&lt;=n;++j) cnt1[i][j]=cnt1[i-1][j];        for(re int j=1;j&lt;=tot;++j) cnt2[i][j]=cnt2[i-1][j];        for(re int j=st[i];j&lt;=ed[i];++j) ++cnt1[i][a[j]],++cnt2[i][bel[a[j]]];    &#125;&#125;inline void modify(int x,int y)&#123;    int pos=bel[x];    for(re int i=pos;i&lt;=tot;++i)&#123;        --cnt1[i][a[x]];        --cnt2[i][bel[a[x]]];        ++cnt1[i][y];        ++cnt2[i][bel[y]];    &#125;    a[x]=y;&#125;inline int query(int l,int r,int k)&#123;    int L=bel[l],R=bel[r],res=-1,tmp=0,id=0;    if(L==R)&#123;        for(re int i=l;i&lt;=r;++i) ++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=1;i&lt;=tot;++i)&#123;            tmp+=buc2[i];            if(tmp&gt;=k)&#123;                tmp-=buc2[i];                id=i;                break;            &#125;        &#125;        for(re int i=st[id];i&lt;=ed[id];++i)&#123;            tmp+=buc1[i];            if(tmp&gt;=k)&#123;                res=b[i];                break;            &#125;        &#125;        for(re int i=l;i&lt;=r;++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;    &#125;    else&#123;        for(re int i=l;i&lt;=ed[L];++i) ++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=st[R];i&lt;=r;++i) ++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=1;i&lt;=tot;++i)&#123;            tmp+=buc2[i]+cnt2[R-1][i]-cnt2[L][i];            if(tmp&gt;=k)&#123;                tmp-=buc2[i]+cnt2[R-1][i]-cnt2[L][i];                id=i;                break;            &#125;        &#125;        for(re int i=st[id];i&lt;=ed[id];++i)&#123;            tmp+=buc1[i]+cnt1[R-1][i]-cnt1[L][i];            if(tmp&gt;=k)&#123;                res=b[i];                break;            &#125;        &#125;        for(re int i=l;i&lt;=ed[L];++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;        for(re int i=st[R];i&lt;=r;++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;    &#125;    return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif\t    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],b[++cnt]=a[i];    char op;    for(re int i=1;i&lt;=m;++i)&#123;        cin&gt;&gt;op;        if(op==&#x27;Q&#x27;) cin&gt;&gt;q[i].l&gt;&gt;q[i].r&gt;&gt;q[i].k,q[i].op=1;        else cin&gt;&gt;q[i].x&gt;&gt;q[i].y,q[i].op=2,b[++cnt]=q[i].y;    &#125;    sort(b+1,b+cnt+1);    cnt=unique(b+1,b+cnt+1)-(b+1);    for(re int i=1;i&lt;=n;++i) a[i]=lower_bound(b+1,b+cnt+1,a[i])-b;    init();    pre();    for(re int i=1;i&lt;=m;++i)&#123;        if(q[i].op==1) cout&lt;&lt;query(q[i].l,q[i].r,q[i].k)&lt;&lt;&#x27;\\n&#x27;;        else modify(q[i].x,lower_bound(b+1,b+cnt+1,q[i].y)-b);    &#125;    return 0;&#125;\n那再加强一下：区间修。\n[Ynoi2018] 未来日记望月悲叹的最初分块。\n每个序列块用并查集把所有值相同的缩在一起。然后维护 rt[i][x]，表示第 i 个块中某个值为 x 的数的位置。\n对于整块修改，如果 x 不存在，直接无视。\n否则，如果 y 不存在，那么就把 x 映射成 y。\n否则暴力重构。\n然后还要把我们维护的前缀和修改掉。\n因为是区间修，所以我们还得再记录一下每个序列块内每个数的出现次数，用于修改后面的前缀和。\n对于散块修改，直接暴力重构即可。\n具体的，我们把并查集的信息全部重新维护一遍，然后再把后面块的前缀和修改一下。\n感觉说的也不是很清楚？那放一下lxl的题解吧。\n实现参考了题解（我太菜了写不出来QWQ）。\n#include&quot;bits/stdc++.h&quot;#define re register// #define int long longusing namespace std;const int maxn=1e5+10,maxm=170;int n,m,siz,tot;int a[maxn];int st[maxm],ed[maxm],bel[maxn];int cnt1[maxm][maxn],cnt2[maxm][maxm],cnt3[maxm][maxn];int buc1[maxn],buc2[maxm];int fa[maxn],rt[maxm][maxn];int stk[maxn];inline int find(int x)&#123;if(x!=fa[x]) fa[x]=find(fa[x]);return fa[x];&#125;inline void init()&#123;    siz=600;    tot=n/siz;    for(re int i=1;i&lt;=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;    if(ed[tot]&lt;n) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=n;    for(re int i=1;i&lt;=tot;++i) for(re int j=st[i];j&lt;=ed[i];++j) bel[j]=i;&#125;inline void pre()&#123;    for(re int i=1;i&lt;=tot;++i)&#123;        for(re int j=st[i];j&lt;=ed[i];++j)&#123;            if(!rt[i][a[j]]) rt[i][a[j]]=j;             else fa[j]=rt[i][a[j]];        &#125;        for(re int j=1;j&lt;=n;++j) cnt1[i][j]=cnt1[i-1][j];        for(re int j=1;j&lt;=tot;++j) cnt2[i][j]=cnt2[i-1][j];        for(re int j=st[i];j&lt;=ed[i];++j) ++cnt1[i][a[j]],++cnt2[i][bel[a[j]]],++cnt3[i][a[j]];    &#125;&#125;inline void update(int p,int l,int r,int x,int y)&#123;    int tmp=0,top=0,L=st[p],R=ed[p];    rt[p][x]=rt[p][y]=0;    for(re int i=L;i&lt;=R;++i)&#123;        a[i]=a[find(i)];        if(a[i]==x||a[i]==y) stk[++top]=i;    &#125;    for(re int i=l;i&lt;=r;++i) if(a[i]==x) a[i]=y,++tmp;    for(re int i=1;i&lt;=top;++i) fa[stk[i]]=stk[i];    for(re int i=1;i&lt;=top;++i)&#123;        if(!rt[p][a[stk[i]]]) rt[p][a[stk[i]]]=stk[i];        else fa[stk[i]]=rt[p][a[stk[i]]];    &#125;    cnt3[p][x]-=tmp,cnt3[p][y]+=tmp;    for(re int i=p;i&lt;=tot;++i)&#123;        cnt1[i][x]-=tmp,cnt1[i][y]+=tmp;        if(bel[x]!=bel[y]) cnt2[i][bel[x]]-=tmp,cnt2[i][bel[y]]+=tmp;    &#125;&#125;inline void modify(int l,int r,int x,int y)&#123;    if(x==y) return;    int L=bel[l],R=bel[r];    if(L==R) update(L,l,r,x,y);    else&#123;        update(L,l,ed[L],x,y),update(R,st[R],r,x,y);        int tmp1=0,tmp2=0;        for(re int i=L+1;i&lt;=R-1;++i)&#123;            if(rt[i][x])&#123;                if(!rt[i][y]) rt[i][y]=rt[i][x],a[rt[i][x]]=y;                else fa[rt[i][x]]=rt[i][y];                rt[i][x]=0;                tmp1=cnt3[i][x],tmp2+=tmp1;                cnt3[i][y]+=tmp1,cnt3[i][x]=0;            &#125;            cnt1[i][x]-=tmp2,cnt1[i][y]+=tmp2;            if(bel[x]!=bel[y]) cnt2[i][bel[x]]-=tmp2,cnt2[i][bel[y]]+=tmp2;        &#125;        for(re int i=R;i&lt;=tot;++i)&#123;            cnt1[i][x]-=tmp2,cnt1[i][y]+=tmp2;            if(bel[x]!=bel[y]) cnt2[i][bel[x]]-=tmp2,cnt2[i][bel[y]]+=tmp2;        &#125;    &#125;&#125;inline int query(int l,int r,int k)&#123;    int L=bel[l],R=bel[r],res=-1,tmp=0,id=0;    if(L==R)&#123;        for(re int i=l;i&lt;=r;++i) a[i]=a[find(i)],++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=1;i&lt;=tot;++i)&#123;            tmp+=buc2[i];            if(tmp&gt;=k)&#123;                tmp-=buc2[i];                id=i;                break;            &#125;        &#125;        for(re int i=st[id];i&lt;=ed[id];++i)&#123;            tmp+=buc1[i];            if(tmp&gt;=k)&#123;                res=i;                break;            &#125;        &#125;        for(re int i=l;i&lt;=r;++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;    &#125;    else&#123;        for(re int i=l;i&lt;=ed[L];++i) a[i]=a[find(i)],++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=st[R];i&lt;=r;++i) a[i]=a[find(i)],++buc1[a[i]],++buc2[bel[a[i]]];        for(re int i=1;i&lt;=tot;++i)&#123;            tmp+=buc2[i]+cnt2[R-1][i]-cnt2[L][i];            if(tmp&gt;=k)&#123;                tmp-=buc2[i]+cnt2[R-1][i]-cnt2[L][i];                id=i;                break;            &#125;        &#125;        for(re int i=st[id];i&lt;=ed[id];++i)&#123;            tmp+=buc1[i]+cnt1[R-1][i]-cnt1[L][i];            if(tmp&gt;=k)&#123;                res=i;                break;            &#125;        &#125;        for(re int i=l;i&lt;=ed[L];++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;        for(re int i=st[R];i&lt;=r;++i) buc1[a[i]]=0,buc2[bel[a[i]]]=0;    &#125;    return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif\t    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],fa[i]=i;    init();    pre();    for(re int i=1,op,l,r,x,y,k;i&lt;=m;++i)&#123;        cin&gt;&gt;op;        if(op==1) cin&gt;&gt;l&gt;&gt;r&gt;&gt;x&gt;&gt;y,modify(l,r,x,y);        else cin&gt;&gt;l&gt;&gt;r&gt;&gt;k,cout&lt;&lt;query(l,r,k)&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n事实上这东西和主席树很像，都是维护前缀信息，然后通过差分求区间信息。\n一般来说，我们都会维护前缀序列块的某个值域块的前缀和，这样可以方便修改。\n有时候，我们还会维护前缀序列块的前缀值域块的前缀和。\n例如[ABC339G] Smaller Sum，我们维护前缀序列块的前缀值域块的前缀和。\n在序列上，我们把询问差分成 [1,r]-[1,l-1]，然后因为我们还维护了前缀值域块的前缀和，所以 \\le x 的和也直接求出来了。\n倍增值域分块倍增值域分块，就是把值域分成 [b^k,b^{k+1}) 的形式，一般取 b=2。\n通常用来解决 a_i\\ge x,a_i\\leftarrow a_i-x 的操作。\n常见做法是每块建一颗线段树维护。\nPhoenix and Diamonds *3400考虑倍增值域分块。\n我们把值域按 [2^k,2^{k+1}) 分块。\n设 c 当前在的块是 [2^k,2^{k+1})，那么 w_i 有三种情况：w_i < 2^k，w_i \\in [2^k,2^{k+1})，w_i \\ge 2^{k+1}。\n最后一种情况显然不需要考虑。\n如果选了第二种情况，那么 c 就会向下掉一层。\n如果选了第一种情况，那么也有两种情况：一直选，然后掉到下一层；或者直接选完。\n考虑对每一块开一颗线段树维护。\n线段树上维护 w_i < 2^k 的 \\sum w_i 和 \\sum v_i，以及选一个 w_i \\in [2^k,2^{k+1}) 所需的 c 的最小值（别忘了拿 [2^k,2^{k+1}) 的条件是先把前面拿完）。\n查询就是线段树上二分。\n还有另一种写法，不过差不多。\n线段树上每个节点维护所有块信息，维护的东西不变。\n设 sw_k=\\sum_{w_i < 2^k} w_i,sv_k=\\sum_{w_i < 2^k} v_i，mn 为上文提到的 c 的最小值。\n那么查询时，如果 c\\ge sw_k，那么说明小物品都能拿，那么直接返回 sw_k。\n如果 sw_{k-1}\\le c < mn_{k-1}，说明比 c 所在层的下一层还要小的物品可以全拿（拿完以后可能掉下去也可能不掉下去），但是下一层的物品一个也拿不了，那么直接返回 sw_{k-1}。\n否则向两边递归。可以证明复杂度为 O(\\log V)。\n感性理解就是每次递归都至少往下走一层，最多走 O(\\log V) 层。\n复杂度 O(n\\log n \\log V)\n实现时，查询里要实时维护当前在哪一层。\n代码实现了第二种（感觉线段树上二分不太好写）\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e5+10,maxv=20,inf=2e18;int n,m,c,rt,segcnt,now;int seq[maxn],id[maxn];struct node&#123;    int num,w,v,id;&#125;a[maxn];struct node1&#123;    int sw,sv,tot;&#125;;struct tree&#123;    int ls,rs;    node1 s[maxv];&#125;tr[maxn&lt;&lt;1];inline bool cmp(int x,int y)&#123;    if(a[x].v==a[y].v) return a[x].w&lt;a[y].w;    return a[x].v&gt;a[y].v;&#125;inline void up(int p)&#123;    for(re int i=1;i&lt;=18;++i)&#123;        tr[p].s[i].sw=tr[tr[p].ls].s[i].sw+tr[tr[p].rs].s[i].sw;        tr[p].s[i].sv=tr[tr[p].ls].s[i].sv+tr[tr[p].rs].s[i].sv;        tr[p].s[i].tot=min(tr[tr[p].ls].s[i].tot,tr[tr[p].ls].s[i].sw+tr[tr[p].rs].s[i].tot);    &#125;&#125;inline void init(int p,int pos)&#123;    for(re int i=1;i&lt;=18;++i)&#123;        tr[p].s[i].sw=tr[p].s[i].sv=0,tr[p].s[i].tot=inf;        if(a[pos].w&lt;(1&lt;&lt;(i-1))) tr[p].s[i].sw=a[pos].w*a[pos].num,tr[p].s[i].sv=a[pos].v*a[pos].num;        else if(a[pos].w&lt;(1&lt;&lt;i)&amp;&amp;a[pos].num) tr[p].s[i].tot=a[pos].w;     &#125;&#125;inline void build(int l,int r,int &amp;p)&#123;    if(!p) p=++segcnt;    if(l==r)&#123;init(p,id[l]);return;&#125;    int mid=(l+r)&gt;&gt;1;    build(l,mid,tr[p].ls),build(mid+1,r,tr[p].rs);    up(p);&#125;inline void update(int l,int r,int pos,int p)&#123;    if(l==r)&#123;init(p,id[pos]);return;&#125;    int mid=(l+r)&gt;&gt;1;    if(pos&lt;=mid) update(l,mid,pos,tr[p].ls);    else update(mid+1,r,pos,tr[p].rs);    up(p);&#125;inline void calc()&#123;while(now&gt;1&amp;&amp;(1&lt;&lt;((now-1)-1))&gt;c) --now;&#125;inline int query(int l,int r,int p)&#123;    if(l==r)&#123;        int num=min(a[id[l]].num,c/a[id[l]].w);        c-=num*a[id[l]].w;calc();        return num*a[id[l]].v;    &#125;    if(c&gt;=tr[p].s[now].sw)&#123;int tmp=tr[p].s[now].sv;c-=tr[p].s[now].sw,calc();return tmp;&#125;    else if(c&gt;=tr[p].s[now-1].sw&amp;&amp;c&lt;tr[p].s[now-1].tot)&#123;int tmp=tr[p].s[now-1].sv;c-=tr[p].s[now-1].sw,calc();return tmp;&#125;    else&#123;        int mid=(l+r)&gt;&gt;1;        return query(l,mid,tr[p].ls)+query(mid+1,r,tr[p].rs);    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i].num&gt;&gt;a[i].w&gt;&gt;a[i].v,id[i]=i;    sort(id+1,id+n+1,cmp);    for(re int i=1;i&lt;=n;++i) seq[id[i]]=i;    build(1,n,rt);    while(m--)&#123;        int op,num,pos;        cin&gt;&gt;op;        if(op==3)&#123;            cin&gt;&gt;c;now=18;calc();            cout&lt;&lt;query(1,n,1)&lt;&lt;&#x27;\\n&#x27;;        &#125;        else&#123;            cin&gt;&gt;num&gt;&gt;pos;            if(op==1) a[pos].num+=num;            else a[pos].num-=num;            update(1,n,seq[pos],1);        &#125;    &#125;    return 0;&#125;\n[Ynoi2007] rgxsxrs摆\n[Ynoi Easy Round 2022] 堕天作战 TEST_98摆\n","categories":["学习笔记"],"tags":["数据结构","莫队","分块"]},{"title":"字符串哈希学习笔记","url":"/posts/72aa3132/","content":"字符串学到现在只会 SA，绷不住了。\n还是得学学哈希，不然真考字符串就寄了。\n什么是字符串哈希通过一个函数把一个字符串映射为一个整数，这个函数就是哈希函数。\n如何计算我们通常采用多项式哈希。\n设 base 为底数，p 为模数，则\n\nf(s)=\\sum_{i=1}^n s_i\\times base^{n-i} \\quad (mod\\ p)底数通常选择一个质数，模数通常选择一个大质数。\n推荐：底数 131，模数 1926081719491001071\nupd：131也被卡了，可以换成19260817。\n如果要用的话记得开 int128，不然你一乘就炸了。\n比较好记，就是江泽民主席的诞辰和建国时间拼起来再拼上071。\n如果没想起来用 1e9+7 也行，不过容易被卡。\n自然溢出还是算了吧，真怕被卡。\n如何计算子串哈希值首先处理出来前缀哈希值。\n设第 i 位哈希值为 h_i，则\n\nh_i=h_{i-1}\\times base+s_i\\quad (mod\\ p)则 s[l,r] 的哈希值，为 h_r-h_{l-1}\\times base^{r-l+1}\n如何判断是否是回文串正着算一遍哈希值，反着算一遍哈希值，如果一样说明是回文串。\n如何得到两个串接起来得到的新串的哈希值设两个字符串分别为 s,t，若把 t 接到 s 后面，则新串哈希值为 f(s)\\times base^{len_t}+f(t)\n如果题目涉及到以上问题（即需要相乘）且你使用了大模数，请先想想会不会炸，需不需要 int128。\n应用大概就字符串匹配吧？还有别的用途吗？\n字符串哈希厉害之处就在于可以在预处理后 O(1) 匹配。\n哈希还有一个常用搭配：二分。\n因为字符串的匹配是有单调性的，长的匹配说明短的也匹配，所以可以二分长度然后用哈希判断。\n例题【模板】字符串哈希第一道题肯定要放模板啦。\n求出每个字符串的哈希值，那么问题就变成了序列中有几个不同的数。\n非常简单吧。\n[CTSC2014] 企鹅 QQ因为要求恰好一位不同，所以考虑枚举哪一位不同。\n因为要把枚举到的那一位删掉，所以得处理所有串的前缀哈希，然后删这一位就是把前后的拼起来。\n求子串哈希和怎么拼起来都在上文提到过。\n然后就变成模板了。\n复杂度 O(nL\\log n)\n[POI2010] KOR-Beads首先枚举 k，然后枚举每一段。\n听上去很暴力对不对？但复杂度其实是有保证的。\n总时间复杂度应该是 \\sum_{k=1}^n \\lfloor \\frac{n}{k} \\rfloor。\n把 n 提出来，剩下的是个调和级数。\n所以时间复杂度 O(n\\log n)。\n用哈希匹配是 O(1) 的，所以总复杂度 O(n\\log n)。\n但有个需要注意的：这道题的串正着和反着视为相同，所以既要处理前缀哈希还要处理后缀哈希，只有都不相同时才能记录到答案。\n[POI2012] OKR-A Horrible Poem首先，设 len 为答案，则 len 为答案的充要条件为 s[l,r-len]=s[l+len,r]。\n其次，答案一定是区间长度的约数。\n所以我们从小到大枚举约数，然后哈希 O(1) 判断。\n复杂度 O(q\\omega(n))\n虽然约数个数是一个比 \\sqrt n 小一点的数，但依旧会 T。\n考虑优化一下这个东西。\n如果一个循环节出现了 2 次，另一个出现了 3 次，那么一定有一个会出现 6 次。\n所以我们对每个质因数分别做，最后把它们合起来。\n质因数个数是 \\log 级别的，可以通过。\n[CQOI2014] 通配符匹配因为通配符不超过 10，所以考虑把原串分成若干段，然后分段匹配，每段第一位为通配符。\n设 f_{i,j} 表示分出来的第 i 个串能否匹配上查询串的 第 j 位。\n转移为\n\nf_{i,j}=f_{i-1,j-len_i} \\quad 该段无通配符\n\\\\\nf_{i,j}=f_{i-1,j-len_i-1} \\quad 通配符为 ？\n\\\\\nf_{i,j}=\\oplus_{k=0}^{j-len_i} f_{i-1,k} \\quad 通配符为 *这里的 \\oplus 代表按位或。\n能否转移用哈希判断一下即可。\n设通配符个数为 m，复杂度为 O(nm|S|)\n[POI2006] PAL-Palindromes这不就是把上面那两个东西拼一块了吗。\n设两个字符串分别为 s,t，那么这对字符串合法的条件为 f(s)\\times base^{len_t}+f(t)=f(t)\\times base^{len_s}+f(s)。\n移项，得到 \\frac {f(s)}{base^{len_s}-1}=\\frac {f(t)}{base^{len_t}-1}\n对每个字符串求出这个东西，然后随便统计一下即可。\n[TJOI2017] DNA允许 k 次失配的字符串匹配。\n考虑二分+哈希。\n首先枚举所有可能匹配的子串，然后二分找到第一个失配的位置，把这个位置及之前的东西删掉，然后再进行这个过程。\n如果失配次数 \\le k，说明合法。\n设原串长度为 n，模式串长度为 m，复杂度 O(m+kn\\log m)\n「TAOI-2」Ciallo～(∠・ω&lt; )⌒★Ciallo～(∠・ω&lt; )⌒★\n洛谷题解传送门\n一道很好玩的题。\n直接做可能没什么想法，那我们先对 [l,r] 和 [l',r'] 讨论一下。\n这里的 l,r,l',r' 都是以原串为下标的。\n1.[l,r] 和 [l',r'] 无交\n那说明删除没任何影响。我们先找出所有匹配位置，然后随便算一下方案数就行了。\n2.[l,r] 和 [l',r'] 有交。\n不难发现，合法的 [l,r] 和 [l',r'] 一定形如下图\n\n图中的 x_i,y_i 分别代表 \\operatorname{LCP}(S(i,n),T),\\operatorname{LCS}(S(1,i),T)。\n设 S 长为 n，T 长为 m。\n红色部分为重复部分，长为 x_{l'}+y_{r'}-m。\n不难发现，对于这种情况，合法的方案数为 x_{l'}+y_{r'}-m+1。\n然后观察这种情况需要满足什么条件，不难发现，需要满足\n\nr'-l'\\ge m\n\\\\\nx_{l'}+y_{r'} \\ge m\n\\\\\nx_{l'} \\neq m\n\\\\\ny_{r'} \\neq m不能等于 m 是因为这部分贡献已经在前面算过了，不能重复计算。\n然后这东西就是个二维数点，数就完了。\n数点时记得减去贡献。\n树状数组 add 时可能会用到 0，整体加偏移量即可。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define lb(x) (x&amp;(-x))using namespace std;const int maxn=4e5+10,base=131,mod=1e9+7;int n,m,ans;char s1[maxn],s2[maxn];int pw[maxn];int h1[maxn],h2[maxn];int x[maxn],y[maxn];struct BIT&#123;    int tr[maxn];    inline void add(int x,int val)&#123;++x;while(x&lt;maxn) tr[x]+=val,x+=lb(x);&#125;    inline int query(int x)&#123;++x;int res=0;while(x&gt;0) res+=tr[x],x-=lb(x);return res;&#125;&#125;a,b;inline int calc1(int l,int r)&#123;return ((h1[r]-h1[l-1]*pw[r-l+1]%mod)%mod+mod)%mod;&#125;inline int calc2(int l,int r)&#123;return ((h2[r]-h2[l-1]*pw[r-l+1]%mod)%mod+mod)%mod;&#125;inline bool check1(int pos,int len)&#123;    if(pos+len-1&gt;n) return 0;    return calc1(pos,pos+len-1)==calc2(1,len);&#125;inline bool check2(int pos,int len)&#123;    if(pos-len+1&lt;1) return 0;    return calc1(pos-len+1,pos)==calc2(m-len+1,m);&#125;inline void init()&#123;    pw[0]=1;    for(re int i=1;i&lt;maxn;++i) pw[i]=pw[i-1]*base%mod;    for(re int i=1;i&lt;=n;++i) h1[i]=(h1[i-1]*base+s1[i])%mod;    for(re int i=1;i&lt;=m;++i) h2[i]=(h2[i-1]*base+s2[i])%mod;    for(re int i=1,l,r,mid,res;i&lt;=n;++i)&#123;        l=0,r=m,res=0;        while(l&lt;=r)&#123;            mid=(l+r)&gt;&gt;1;            if(check1(i,mid)) res=mid,l=mid+1;            else r=mid-1;        &#125;        x[i]=res;        l=0,r=m,res=0;        while(l&lt;=r)&#123;            mid=(l+r)&gt;&gt;1;            if(check2(i,mid)) res=mid,l=mid+1;            else r=mid-1;        &#125;        y[i]=res;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;(s1+1)&gt;&gt;(s2+1);n=strlen(s1+1),m=strlen(s2+1);    init();    for(re int i=1;i&lt;=n;++i) if(y[i]==m) ans+=((i-m)*(i-m+1)/2+(n-i)*(n-i+1)/2);    for(re int i=m+1;i&lt;=n;++i)&#123;        a.add(m-x[i-m],1),b.add(m-x[i-m],x[i-m]);        ans+=b.query(y[i])+(y[i]-m+1)*a.query(y[i]);        if(y[i]==m) ans-=a.query(y[i]);         ans-=a.query(0);    &#125;    cout&lt;&lt;ans;    return 0;&#125;\n[蓝桥杯 2016 国 AC] 碱基数据范围开这么小随便做吧。\n直接爆搜选哪些串，然后把长度为 k 的子串的哈希值存起来。\n这样对于每一个哈希值可以求出它在每个串中各出现了多少次，乘起来即可。\n复杂度 O(n2^nL)\n【模板】manacher马拉车过于困难，考虑用哈希搞搞部分分。\n部分分还是很好做的，我们处理出正着的哈希值和倒着的哈希值，然后枚举对称轴并二分长度，就做完了。\n复杂度 O(n\\log n)\n事实上哈希也是能做到线性的，且思路和马拉车差不多。\n[POI2010] ANT-Antisymmetry二分+哈希。\n基本和上题一样。\n处理出原串的哈希值和取反后的哈希值，然后枚举对称轴并二分长度。\n对于统计答案，可以发现只有总长为偶数才可能合法。\n然后没了。\n[USACO17OPEN] Bovine Genomics G简单题。\n枚举左端点，然后二分长度，然后哈希判断有没有重复。\n二分正确性也比较显然：如果当前长度不合法，那就必须变长，否则可以变短。\n复杂度 O(nm\\log m \\log n)\n感觉做不到 O(nm\\log m)，因为不管用 set，map 还是离散化都得带 \\log，所以题解复杂度是不是都写错了？\n[BalticOI 2014 Day1] Three Friends枚举哪个是插入的，然后把它删掉。\n然后看剩下的东西能不能组成两个相同串即可。\n这里还是稍微有点细节的，因为涉及到子串哈希值和把两个串拼接起来。\n观察样例一，你会发现把枚举的那个删掉以后，因为要组成两个相同串，所以要保证两段长度相等。\n所以要给短的那一段拼上一部分。\n大概就是这样吧，其他应该没什么细节。\n复杂度 O(n)\n[NOIP2020] 字符串匹配如果 AB 确定了，那么 C 也是确定的。\n所以考虑枚举 AB 和 i，这样做的好处是 i 是 \\log 级别的，所以总复杂度是 O(n\\log n)。\n然后要解决的问题就是出现次数了。\n我们可以维护出现次数为奇数次的个数的前缀和以及后缀和，那么查询用树状数组搞一下即可。\n设 V 为字符集大小，复杂度 O(n\\log n\\log V)。\n似乎需要卡常。\n","categories":["学习笔记"],"tags":["字符串"]},{"title":"快速沃尔什变换(FWT)学习笔记","url":"/posts/dccb649f/","content":"在 OI 中，FWT 是用于解决对下标进行位运算卷积问题的一种方法。\n引入给出序列 a,b，我们想要求出 c，满足\n\nc_i=\\sum_{j \\oplus k=i}a_j\\times b_k其中 \\oplus 代表按位与，按位或，按位异或中的一种。\n直接求是 O(n^2) 的，而 FWT 通过构造出一种可逆的变换 F，使得 F(c)=F(a) \\cdot F(b)，从而快速解决下标位运算卷积。\nFWT 的运算以下设 \\cup 为按位或，\\cap 为按位与，\\oplus 为按位异或。\n按位或考虑构造 F_i(a)=\\sum_{j \\cup i=i} a_j，则\n\n\\begin{align*}\nF_i(a)\\times F_i(b)&=(\\sum_{j\\cup i=i}a_j)(\\sum_{k\\cup i=i}b_k)\n\\\\\n&=\\sum_{j\\cup i=i}\\sum_{k \\cup i=i} a_j\\times b_k\n\\\\\n&=\\sum_{(j\\cup k)\\cup i=i} a_j\\times b_k\n\\\\\n&=F_i(c)\n\\end{align*}如果没看明白就把 F_i(c) 展开推一遍，然后就能发现这是一样的。\n那么我们现在只需要能做到快速求出 F_i(a) 且能快速进行逆运算就做完了。\n可以发现，这个 F_i(a)，不就是求子集和吗？\n对每个子集求子集和，这不是高维前缀和吗？\n考虑逆运算，显然只需要做一遍高维差分即可。\n复杂度 O(n2^n)，这里的 n 指的是维数。如果把 n 变成序列长度，则复杂度为 O(n\\log n)。\n按位与考虑构造 F_i(a)=\\sum_{j \\cap i=i} a_j，可以发现形式和按位或的情况一模一样。\n证明也类似按位或，这里不再赘述。\n可以发现，和按位或的唯一区别在于之前是求子集和，现在是求超集和。\n依旧可以高维前缀和。\n复杂度 O(n\\log n)\n按位异或因为还没学明白，所以基本都是抄的 OI Wiki。\n设 x \\otimes y=\\operatorname{popcount}(x \\cap y) \\ mod \\ 2 。\n那么可以得到 \\otimes 对 \\oplus 有分配律：\n\nx\\otimes (y\\oplus z)=(x\\otimes y)\\oplus (x\\otimes z)考虑构造 F_i(a)=\\sum_{i \\otimes j=0}a_j-\\sum_{i \\otimes j=1}a_j，则\n\n\\begin{align*}\nF_i(a)\\times F_i(b)&=(\\sum_{i \\otimes j=0}a_j-\\sum_{i \\otimes j=1}a_j)\\times (\\sum_{i \\otimes k=0}b_k-\\sum_{i \\otimes k=1}b_k)\n\\\\\n&=(\\sum_{i \\otimes j=0}a_j\\sum_{i \\otimes k=0}b_k+\\sum_{i \\otimes j=1}a_j\\sum_{i \\otimes k=1}b_k)-(\\sum_{i \\otimes j=0}a_j\\sum_{i \\otimes k=1}b_k+\\sum_{i \\otimes j=1}a_j\\sum_{i \\otimes k=0}b_k)\n\\\\\n&=\\sum_{i\\otimes(j\\oplus k)=0}a_jb_k-\\sum_{i\\otimes(j\\oplus k)=1}a_jb_k\n\\\\\n&=F_i(c)\n\\end{align*}如何快速计算 F(a)？考虑分治。\n设 i 在当前位为 0 的子数列为 F(a_0)，在当前位为 1 的子数列为 F(a_1)，则\n\nF(a)=merge(F(a_0)+F(a_1),F(a_0)-F(a_1))其中 merge 表示拼接，+,- 表示对应位置加/减。\n逆变换为\n\nF'(a)=merge(\\frac{F'(a_0)+F'(a_1)}{2},\\frac{F'(a_0)-F'(a_1)}{2})复杂度 O(n\\log n)\n例题：【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=(1&lt;&lt;17)+10,mod=998244353,inv2=499122177;int n,S;int A[maxn],B[maxn];int a[maxn],b[maxn],c[maxn];inline void in()&#123;for(re int i=0;i&lt;=S;++i) a[i]=A[i],b[i]=B[i];&#125;inline void get()&#123;for(re int i=0;i&lt;=S;++i) c[i]=a[i]*b[i]%mod;&#125;inline void out()&#123;for(re int i=0;i&lt;=S;++i) cout&lt;&lt;c[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;&#x27;\\n&#x27;;&#125;inline void OR(int f[],int op)&#123;    for(re int i=0;i&lt;n;++i)&#123;        for(re int s=0;s&lt;=S;++s)&#123;            if((s&gt;&gt;i)&amp;1) f[s]=((f[s]+f[s^(1&lt;&lt;i)]*op)%mod+mod)%mod;        &#125;    &#125;&#125;inline void AND(int f[],int op)&#123;    for(re int i=0;i&lt;n;++i)&#123;        for(re int s=0;s&lt;=S;++s)&#123;            if((s&gt;&gt;i)&amp;1) f[s^(1&lt;&lt;i)]=((f[s^(1&lt;&lt;i)]+f[s]*op)%mod+mod)%mod;        &#125;    &#125;&#125;inline void XOR(int f[],int op)&#123;    for(re int i=0,len=1;i&lt;n;++i,len&lt;&lt;=1)&#123;        for(re int s=0;s&lt;=S;s+=len*2)&#123;            for(re int j=0;j&lt;len;++j)&#123;                f[s+j]=(f[s+j]+f[s+j+len])%mod;                f[s+j+len]=((f[s+j]-f[s+j+len]*2)%mod+mod)%mod;                f[s+j]=((f[s+j]*op)%mod+mod)%mod;                f[s+j+len]=((f[s+j+len]*op)%mod+mod)%mod;            &#125;        &#125;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n;S=(1&lt;&lt;n)-1;    for(re int i=0;i&lt;=S;++i) cin&gt;&gt;A[i];    for(re int i=0;i&lt;=S;++i) cin&gt;&gt;B[i];    in(),OR(a,1),OR(b,1),get(),OR(c,-1),out();    in(),AND(a,1),AND(b,1),get(),AND(c,-1),out();    in(),XOR(a,1),XOR(b,1),get(),XOR(c,inv2),out();    return 0;&#125;\n","categories":["学习笔记"],"tags":["数学"]},{"title":"圆方树学习笔记","url":"/posts/218474d4/","content":"经常见到圆方树，但一直不会，正好在复习连通性，顺便学一下。\n但我学的是广义圆方树，所以下文都是有关广义圆方树的介绍。\n定义及构建在圆方树中，原图的每个点对应一个圆点，每个点双对应一个方点。\n在一个联通分量内，对于每个点双，我们把它对应的方点和在其内的所有点对应的圆点连边，会得到一棵树。\n这棵树就叫圆方树。\n如果图由若干个联通分量构成，则会形成圆方树森林。\n特殊的，对于孤点应该特殊处理（然而我的处理就是不管它但一直没错过）。\n以下是对给定无向图建圆方树的一个图示：\n\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e5+10,maxm=5e5+10;int n,m,cnt,tim,top,tot;int head[maxn];int dfn[maxn],low[maxn];int stk[maxn];struct edge&#123;    int to,nxt;&#125;e[maxm&lt;&lt;1];vector&lt;int&gt; g[maxn&lt;&lt;1];inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u,int fa)&#123;    dfn[u]=low[u]=++tim;    stk[++top]=u;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            tarjan(v,u);            low[u]=min(low[u],low[v]);            if(low[v]&gt;=dfn[u])&#123;                ++tot;                int x;                do&#123;                    x=stk[top--];                    g[tot].push_back(x),g[x].push_back(tot);                &#125;while(x!=v);                g[tot].push_back(u),g[u].push_back(tot);            &#125;        &#125;        else if(v!=fa) low[u]=min(low[u],dfn[v]);    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;tot=n;    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    for(re int i=1;i&lt;=n;++i) if(!dfn[i]) tarjan(i,i);    return 0;&#125;\n性质\n圆方树的点数会达到 2n 级别，所以数组别开小。\n树上圆点仅会和方点相连，方点仅会和圆点相连。\n\n度数大于 1 的圆点在原图中一定是割点。\n\n\n例题道路相遇双倍经验：Traffic Real Time Query System\n结论：两个点之间必经点个数=圆方树上对应圆点路径上圆点数。\n这里的必经点包含这两个点。\n所以建出圆方树后树剖维护即可。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=5e5+10,maxm=1e6+10;int n,m,Q,cnt,tim,top,tot,id,rt,segcnt;int head[maxn];int dfn[maxn],low[maxn];int stk[maxn];struct edge&#123;    int to,nxt;&#125;e[maxm&lt;&lt;1];struct node&#123;    int fa,siz,top,hson,dep,dfn,seq;&#125;t[maxn&lt;&lt;1];struct tree&#123;    int ls,rs,sum;&#125;tr[maxn&lt;&lt;2];vector&lt;int&gt; g[maxn&lt;&lt;1];inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u,int fa)&#123;    dfn[u]=low[u]=++tim;    stk[++top]=u;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            tarjan(v,u);            low[u]=min(low[u],low[v]);            if(low[v]&gt;=dfn[u])&#123;                ++tot;                int x;                do&#123;                    x=stk[top--];                    g[tot].push_back(x),g[x].push_back(tot);                &#125;while(x!=v);                g[tot].push_back(u),g[u].push_back(tot);            &#125;        &#125;        else if(v!=fa) low[u]=min(low[u],dfn[v]);    &#125;&#125;inline void dfs1(int u,int fa)&#123;    t[u].fa=fa;    t[u].siz=1;    t[u].dep=t[fa].dep+1;    for(auto v:g[u])&#123;        if(v==fa) continue;        dfs1(v,u);        t[u].siz+=t[v].siz;        if(!t[u].hson||t[v].siz&gt;t[t[u].hson].siz) t[u].hson=v;    &#125;&#125;inline void dfs2(int u,int top)&#123;    t[u].dfn=++id;    t[id].seq=u;    t[u].top=top;    if(!t[u].hson) return;    dfs2(t[u].hson,top);    for(auto v:g[u])&#123;        if(v==t[u].hson||v==t[u].fa) continue;        dfs2(v,v);    &#125;&#125;inline void up(int p)&#123;tr[p].sum=tr[tr[p].ls].sum+tr[tr[p].rs].sum;&#125;inline void build(int l,int r,int &amp;p)&#123;    if(!p) p=++segcnt;    if(l==r)&#123;tr[p].sum=(t[l].seq&lt;=n);return;&#125;    int mid=(l+r)&gt;&gt;1;    build(l,mid,tr[p].ls),build(mid+1,r,tr[p].rs);    up(p);&#125;inline int query(int l,int r,int L,int R,int p)&#123;    if(l&gt;=L&amp;&amp;r&lt;=R) return tr[p].sum;    int mid=(l+r)&gt;&gt;1,res=0;    if(L&lt;=mid) res+=query(l,mid,L,R,tr[p].ls);    if(R&gt;mid) res+=query(mid+1,r,L,R,tr[p].rs);    return res;&#125;inline int query(int u,int v)&#123;    int res=0;    while(t[u].top!=t[v].top)&#123;        if(t[t[u].top].dep&lt;t[t[v].top].dep) swap(u,v);        res+=query(1,tot,t[t[u].top].dfn,t[u].dfn,1);        u=t[t[u].top].fa;    &#125;    if(t[u].dep&gt;t[v].dep) swap(u,v);    res+=query(1,tot,t[u].dfn,t[v].dfn,1);    return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;tot=n;    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    tarjan(1,0),dfs1(1,0),dfs2(1,1),build(1,tot,rt);    cin&gt;&gt;Q;    while(Q--)&#123;        int u,v;        cin&gt;&gt;u&gt;&gt;v;        cout&lt;&lt;query(u,v)&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n[SDOI2018] 战略游戏双倍经验：国土规划\n上一题的加强版。\n这次从两个点变成若干点了，但保证了总和，所以想到虚树。\n将每次询问点拎出来建虚树，建完后可以发现：虚树上所有是非询问点的圆点（包括建虚树需要用到的关键点和虚树的边上经过的那些非关键点）都合法。\n为了方便，我把 1 也强制加到虚树了，但 1 不一定能产生贡献，所以必须特判。\n注意：树剖的重儿子数组要清空！\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e5+10;int n,m,Q,cnt;int top,tim,tot;int id;int ans,num,len;int head[maxn];int dfn[maxn],low[maxn],stk[maxn];int a[maxn],b[maxn&lt;&lt;1];int sum[maxn&lt;&lt;1];bitset&lt;maxn&gt; vis;vector&lt;int&gt; g[maxn&lt;&lt;1];struct node&#123;    int fa,dfn,top,hson,siz,dep;&#125;t[maxn&lt;&lt;1];struct edge&#123;    int to,nxt;&#125;e[maxn&lt;&lt;1];inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u,int fa)&#123;    dfn[u]=low[u]=++tim;    stk[++top]=u;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            tarjan(v,u);            low[u]=min(low[u],low[v]);            if(low[v]&gt;=dfn[u])&#123;                ++tot;                g[tot].push_back(u),g[u].push_back(tot);                int x;                do&#123;                    x=stk[top--];                    g[tot].push_back(x),g[x].push_back(tot);                &#125;while(x!=v);            &#125;        &#125; else if(v!=fa) low[u]=min(low[u],dfn[v]);    &#125;&#125;inline void dfs1(int u,int fa)&#123;    t[u].fa=fa;    t[u].siz=1;    t[u].dep=t[fa].dep+1;    sum[u]=sum[fa]+(u&lt;=n);    for(auto v:g[u])&#123;        if(v==fa) continue;        dfs1(v,u);        t[u].siz+=t[v].siz;        if(!t[u].hson||t[v].siz&gt;t[t[u].hson].siz) t[u].hson=v;    &#125;&#125;inline void dfs2(int u,int top)&#123;    t[u].top=top;    t[u].dfn=++id;    if(!t[u].hson) return;    dfs2(t[u].hson,top);    for(auto v:g[u])&#123;        if(v==t[u].hson||v==t[u].fa) continue;        dfs2(v,v);    &#125;&#125;inline int lca(int u,int v)&#123;    while(t[u].top!=t[v].top)&#123;        if(t[t[u].top].dep&lt;t[t[v].top].dep) swap(u,v);        u=t[t[u].top].fa;    &#125;    return t[u].dep&lt;t[v].dep?u:v;&#125;inline bool cmp(int a,int b)&#123;return t[a].dfn&lt;t[b].dfn;&#125;inline void build()&#123;    len=0;    sort(a+1,a+num+1,cmp);    for(re int i=1;i&lt;num;++i)&#123;        b[++len]=a[i];        b[++len]=lca(a[i],a[i+1]);    &#125;    b[++len]=a[num];    b[++len]=1;    sort(b+1,b+len+1,cmp);    len=unique(b+1,b+len+1)-(b+1);    for(re int i=1,lc;i&lt;len;++i)&#123;        lc=lca(b[i],b[i+1]);        g[lc].push_back(b[i+1]),g[b[i+1]].push_back(lc);    &#125;&#125;inline void dfs3(int u,int fa)&#123;    for(auto v:g[u])&#123;        if(v==fa) continue;        ans+=(sum[v]-sum[u]-(v&lt;=n));        dfs3(v,u);    &#125;    if(!vis[u]&amp;&amp;u&lt;=n&amp;&amp;(u!=1||g[u].size()!=1)) ++ans;    if(!vis[u]&amp;&amp;u==1&amp;&amp;g[u].size()==1) ans-=(sum[g[u][0]]-sum[u]-(g[u][0]&lt;=n));    g[u].clear();&#125;inline void clear()&#123;    tot=n;    cnt=tim=top=id=0;    for(re int i=1;i&lt;=n;++i) head[i]=0,dfn[i]=0,low[i]=0;&#125;inline void solve()&#123;    cin&gt;&gt;n&gt;&gt;m;clear();    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    tarjan(1,0),dfs1(1,0),dfs2(1,1);    for(re int i=1;i&lt;=tot;++i) g[i].clear();    cin&gt;&gt;Q;    while(Q--)&#123;        cin&gt;&gt;num;ans=0;        for(re int i=1;i&lt;=num;++i) cin&gt;&gt;a[i],vis[a[i]]=1;        build(),dfs3(1,0);        cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;        for(re int i=1;i&lt;=num;++i) vis[a[i]]=0;    &#125;    for(re int i=1;i&lt;=tot;++i)&#123;        sum[i]=0;        t[i].hson=0;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    int T;cin&gt;&gt;T;while(T--) solve();    return 0;&#125;\n[DBOI2019] 巫女的职责综合版：EntropyIncreaser 与 动态图，动态维护割边割点。\n动态维护割点，考虑 LCT 维护圆方树。\n如果不考虑加边，那么单点修改和链查询链推平都是 LCT 基础操作。\n然后考虑加边。\n事实上，只需要在连边前，判断这两个点是否连通，如果已经连通了，那连上这条边就会产生一个环，也就是点双，给路径上的边全部断开然后暴力重构圆方树即可。\n复杂度是对的，因为每个点最多只会被合并一次，而每次复杂度都是 O(\\log n) 的。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define ls(x) tr[x].ch[0]#define rs(x) tr[x].ch[1]#define fa(x) tr[x].fa#define get(x) (rs(fa(x))==x)#define isroot(x) (ls(fa(x))!=x&amp;&amp;rs(fa(x))!=x)using namespace std;const int maxn=1e6+10;int n,m,tot,lastans,top;int stk[maxn];struct node&#123;    int w,fa,ch[2],tag,siz,add,sum;&#125;tr[maxn];inline void up(int x)&#123;    tr[x].sum=tr[ls(x)].sum+tr[rs(x)].sum+tr[x].w;    tr[x].siz=tr[ls(x)].siz+tr[rs(x)].siz+(x&lt;=n);&#125;inline void upadd(int x)&#123;    tr[x].sum=tr[x].w=0;    tr[x].add=1;&#125;inline void rev(int x)&#123;swap(ls(x),rs(x));tr[x].tag^=1;&#125;inline void down(int x)&#123;    if(tr[x].add)&#123;        upadd(ls(x));        upadd(rs(x));        tr[x].add=0;    &#125;    if(tr[x].tag)&#123;        rev(ls(x)),rev(rs(x));        tr[x].tag=0;    &#125;&#125;inline void update(int x)&#123;if(!isroot(x))&#123;update(fa(x));&#125;down(x);&#125;inline void rotate(int x)&#123;    int y=fa(x),z=fa(y),t=get(x);    if(!isroot(y)) tr[z].ch[get(y)]=x;    fa(tr[x].ch[t^1])=y,tr[y].ch[t]=tr[x].ch[t^1];    tr[x].ch[t^1]=y;    fa(y)=x,fa(x)=z;    up(y),up(x);&#125;inline void splay(int x)&#123;    update(x);    for(re int f=fa(x);f=fa(x),!isroot(x);rotate(x))&#123;        if(!isroot(f)) rotate(get(f)==get(x)?f:x);    &#125;&#125;inline void access(int x)&#123;for(re int p=0;x;p=x,x=fa(x))&#123;splay(x),rs(x)=p,up(x);&#125;&#125;inline void makeroot(int x)&#123;access(x),splay(x),rev(x);&#125;inline int find(int x)&#123;    access(x),splay(x);    while(ls(x)) x=ls(x),down(x);    splay(x);    return x;&#125;inline void split(int x,int y)&#123;makeroot(x),access(y),splay(y);&#125;inline void link(int x,int y)&#123;makeroot(x);if(find(y)!=x) fa(x)=y;&#125;inline void cut(int x,int y)&#123;makeroot(x);if(find(y)==x&amp;&amp;fa(y)==x&amp;&amp;!ls(y)) fa(y)=rs(x)=0;&#125;inline const void decode(int &amp;x)&#123;x^=lastans%n;if(x&gt;n)x%=n;if(!x)x=1;&#125;inline int query(int x,int y)&#123;    if(find(x)!=find(y)) return 0;    split(x,y);    int res=tr[y].sum;    upadd(y);    return res;&#125;inline void dfs(int u)&#123;    if(!u) return;down(u);    dfs(ls(u));    stk[++top]=u;    dfs(rs(u));&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;tot=n;    int op,x,y;    while(m--)&#123;        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;        decode(x),decode(y);        if(op==1)&#123;            if(find(x)==find(y))&#123;                split(x,y);                if(tr[y].siz&lt;=2) continue;                top=0;dfs(y);++tot;                for(re int i=1;i&lt;top;++i) cut(stk[i],stk[i+1]);                for(re int i=1;i&lt;=top;++i) link(stk[i],tot);            &#125;            else link(x,y);        &#125;        if(op==2) splay(x),tr[x].w+=y;        if(op==3)&#123;            lastans=query(x,y);            cout&lt;&lt;lastans&lt;&lt;&#x27;\\n&#x27;;        &#125;    &#125;    return 0;&#125;\n综合版代码\n#include&quot;bits/stdc++.h&quot;#define re register#define ls(x) tr[x].ch[0]#define rs(x) tr[x].ch[1]#define fa(x) tr[x].fa#define get(x) (rs(fa(x))==x)#define isroot(x) (ls(fa(x))!=x&amp;&amp;rs(fa(x))!=x)using namespace std;const int maxn=2e5+10;int n,m,lastans,tot;namespace LCT1&#123;    int tot;    struct node&#123;        int w,fa,ch[2],tag,add,sum;    &#125;tr[maxn];    inline void up(int x)&#123;tr[x].sum=tr[ls(x)].sum+tr[rs(x)].sum+tr[x].w;&#125;    inline void upadd(int x)&#123;        tr[x].sum=tr[x].w=0;        tr[x].add=1;    &#125;    inline void rev(int x)&#123;swap(ls(x),rs(x));tr[x].tag^=1;&#125;    inline void down(int x)&#123;        if(tr[x].add)&#123;            upadd(ls(x)),upadd(rs(x));            tr[x].add=0;        &#125;        if(tr[x].tag)&#123;            rev(ls(x)),rev(rs(x));            tr[x].tag=0;        &#125;    &#125;    inline void update(int x)&#123;if(!isroot(x))&#123;update(fa(x));&#125;down(x);&#125;    inline void rotate(int x)&#123;        int y=fa(x),z=fa(y),t=get(x);        if(!isroot(y)) tr[z].ch[get(y)]=x;        fa(tr[x].ch[t^1])=y,tr[y].ch[t]=tr[x].ch[t^1];        tr[x].ch[t^1]=y;        fa(y)=x,fa(x)=z;        up(y),up(x);    &#125;    inline void splay(int x)&#123;        update(x);        for(re int f=fa(x);f=fa(x),!isroot(x);rotate(x))&#123;            if(!isroot(f)) rotate(get(f)==get(x)?f:x);        &#125;    &#125;    inline void access(int x)&#123;for(re int p=0;x;p=x,x=fa(x))&#123;splay(x),rs(x)=p,up(x);&#125;&#125;    inline void makeroot(int x)&#123;access(x),splay(x),rev(x);&#125;    inline int find(int x)&#123;        access(x),splay(x);        while(ls(x)) x=ls(x),down(x);        splay(x);        return x;    &#125;    inline void split(int x,int y)&#123;makeroot(x),access(y),splay(y);&#125;    inline void link(int x,int y)&#123;makeroot(x);if(find(y)!=x) fa(x)=y;&#125;    inline void cut(int x,int y)&#123;makeroot(x);if(find(y)==x&amp;&amp;fa(y)==x&amp;&amp;!ls(y)) fa(y)=rs(x)=0;&#125;    inline int query(int x,int y)&#123;        if(find(x)!=find(y)) return -1;        split(x,y);        return tr[y].sum;    &#125;    inline void link1(int x,int y)&#123;        int u=find(x),v=find(y);        if(u==v) split(x,y),upadd(y);        else ++tot,tr[tot].w=1,link(x,tot),link(tot,y);    &#125;&#125;namespace LCT2&#123;    int tot,top;    int stk[maxn];    struct node&#123;        int fa,ch[2],tag,siz;    &#125;tr[maxn];    inline void up(int x)&#123;tr[x].siz=tr[ls(x)].siz+tr[rs(x)].siz+(x&lt;=n);&#125;    inline void rev(int x)&#123;swap(ls(x),rs(x));tr[x].tag^=1;&#125;    inline void down(int x)&#123;if(tr[x].tag) rev(ls(x)),rev(rs(x));tr[x].tag=0;&#125;    inline void update(int x)&#123;if(!isroot(x))&#123;update(fa(x));&#125;down(x);&#125;    inline void rotate(int x)&#123;        int y=fa(x),z=fa(y),t=get(x);        if(!isroot(y)) tr[z].ch[get(y)]=x;        fa(tr[x].ch[t^1])=y,tr[y].ch[t]=tr[x].ch[t^1];        tr[x].ch[t^1]=y;        fa(y)=x,fa(x)=z;        up(y),up(x);    &#125;    inline void splay(int x)&#123;        update(x);        for(re int f=fa(x);f=fa(x),!isroot(x);rotate(x))&#123;            if(!isroot(f)) rotate(get(f)==get(x)?f:x);        &#125;    &#125;    inline void access(int x)&#123;for(re int p=0;x;p=x,x=fa(x))&#123;splay(x),rs(x)=p,up(x);&#125;&#125;    inline void makeroot(int x)&#123;access(x),splay(x),rev(x);&#125;    inline int find(int x)&#123;        access(x),splay(x);        while(ls(x)) x=ls(x),down(x);        splay(x);        return x;    &#125;    inline void split(int x,int y)&#123;makeroot(x),access(y),splay(y);&#125;    inline void link(int x,int y)&#123;makeroot(x);if(find(y)!=x) fa(x)=y;&#125;    inline void cut(int x,int y)&#123;makeroot(x);if(find(y)==x&amp;&amp;fa(y)==x&amp;&amp;!ls(y)) fa(y)=rs(x)=0;&#125;    inline int query(int x,int y)&#123;        if(find(x)!=find(y)) return -1;        split(x,y);        return tr[y].siz;    &#125;    inline void dfs(int u)&#123;        if(!u) return;down(u);        dfs(ls(u));        stk[++top]=u;        dfs(rs(u));    &#125;    inline void link1(int x,int y)&#123;        if(find(x)==find(y))&#123;            split(x,y);            if(tr[y].siz&lt;=2) return;            top=0;dfs(y);++tot;            for(re int i=1;i&lt;top;++i) cut(stk[i],stk[i+1]);            for(re int i=1;i&lt;=top;++i) link(stk[i],tot);        &#125;        else link(x,y);    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;LCT1::tot=LCT2::tot=n;    int op,x,y,ans;    while(m--)&#123;        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;x^=lastans,y^=lastans;        if(op==1) LCT1::link1(x,y),LCT2::link1(x,y);        if(op==2) ans=LCT1::query(x,y),lastans=(ans==-1?lastans:ans),cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;        if(op==3) ans=LCT2::query(x,y),lastans=(ans==-1?lastans:ans),cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n[APIO2018] 铁人两项关于点双有一个很好的性质：对于一个点双中的两点，它们之间简单路径的并集，恰好完全等于这个点双。\n证明略，因为不会。\n那么放到圆方树上，就有结论：两圆点在圆方树上的路径，与路径上经过的方点相邻的圆点的集合，就等于原图中两点简单路径上的点集。\n那么在本题中，如果固定 s,f，那么合法的 c 的个数就等于 s,f 之间简单路径的并集的点数减 2（去掉 s,f 本身）。\n那么，我们给方点赋上对应点双大小的权值，给圆点赋上 -1 的权值。\n答案就是任意两个圆点之间路径的权值和。\n套路的，考虑每个点被计算的次数。\n考虑每个点 u 作为 c 时的贡献。\n若 s,f 都在其子树内，则贡献为\n\n\\sum_{v \\in sub_u} 2\\times siz_v\\times (siz_u-siz_v)\\times w_u若 s,f 只有一个在其子树内，则贡献为\n\n2\\times siz_u \\times (now-siz_u)\\times w_u其中 now 为当前连通块内圆点个数。\n乘 2 是因为题目要求统计有序对。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e5+10,maxm=2e5+10;int n,m,cnt,top,tim,tot,ans,now;int head[maxn];int dfn[maxn],low[maxn];int stk[maxn];int siz[maxn&lt;&lt;1],w[maxn&lt;&lt;1];vector&lt;int&gt; g[maxn&lt;&lt;1];struct edge&#123;    int to,nxt;&#125;e[maxm&lt;&lt;1];inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u,int fa)&#123;    ++now;    dfn[u]=low[u]=++tim;    stk[++top]=u;w[u]=-1;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            tarjan(v,u);            low[u]=min(low[u],low[v]);            if(low[v]&gt;=dfn[u])&#123;                g[++tot].push_back(u),g[u].push_back(tot),++w[tot];                int x;                do&#123;                    x=stk[top--];                    g[tot].push_back(x),g[x].push_back(tot),++w[tot];                &#125;while(x!=v);            &#125;        &#125;        else if(v!=fa) low[u]=min(low[u],dfn[v]);    &#125;&#125;inline void dfs(int u,int fa)&#123;    siz[u]=(u&lt;=n);    for(auto v:g[u])&#123;        if(v==fa) continue;        dfs(v,u);        siz[u]+=siz[v];        ans+=2ll*(siz[u]-siz[v])*siz[v]*w[u];    &#125;    ans+=2ll*siz[u]*(now-siz[u])*w[u];&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;tot=n;    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    for(re int i=1;i&lt;=n;++i) if(!dfn[i]) now=0,tarjan(i,i),dfs(i,0);    cout&lt;&lt;ans;    return 0;&#125;\nTourists如果不带修，那么给方点赋上对应点双内所有点的权值最小值，圆点赋对应点权值，查询就是链上最小值。\n然后考虑带修。一个想法是给每个方点维护一个 multiset，修改时要修改对应点点权和相连方点点权。\n但这样做给个菊花就卡死了。\n不过我们可以这样做：令每个方点的权值为其儿子中的最小权值，且 multiset 只维护其儿子的点权。\n这样修改时只需要额外修改父亲即可。\n询问时正常询问，但如果询问的两个点的 lca 是一个方点，那还要额外统计 lca 的父亲的贡献。\n卡常，需要加快读。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define ls(p) tr[p].ls#define rs(p) tr[p].rsusing namespace std;const int maxn=5e5+10,inf=1e18;int n,m,Q,cnt,tim,top,tot,rt,segcnt,id;int a[maxn],head[maxn];int dfn[maxn],low[maxn],stk[maxn];vector&lt;int&gt; g[maxn&lt;&lt;1];multiset&lt;int&gt; s[maxn];struct edge&#123;    int to,nxt;&#125;e[maxn&lt;&lt;1];struct node&#123;    int fa,dep,siz,hson,top,dfn,seq;&#125;t[maxn&lt;&lt;1];struct tree&#123;    int ls,rs,mn;&#125;tr[maxn&lt;&lt;2];inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u,int fa)&#123;    dfn[u]=low[u]=++tim;    stk[++top]=u;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            tarjan(v,u);            low[u]=min(low[u],low[v]);            if(low[v]&gt;=dfn[u])&#123;                g[++tot].push_back(u),g[u].push_back(tot);                int x;                do&#123;                    x=stk[top--];                    g[tot].push_back(x),g[x].push_back(tot);                &#125;while(x!=v);            &#125;        &#125;        else if(v!=fa) low[u]=min(low[u],dfn[v]);    &#125;&#125;inline void dfs1(int u,int fa)&#123;    t[u].fa=fa;t[u].siz=1;t[u].dep=t[fa].dep+1;    for(auto v:g[u])&#123;        if(v==fa) continue;        dfs1(v,u);        t[u].siz+=t[v].siz;        if(!t[u].hson||t[v].siz&gt;t[t[u].hson].siz) t[u].hson=v;    &#125;&#125;inline void dfs2(int u,int top)&#123;    t[u].dfn=++id;t[id].seq=u;t[u].top=top;    if(!t[u].hson) return;    dfs2(t[u].hson,top);    for(auto v:g[u])&#123;        if(v==t[u].hson||v==t[u].fa) continue;        dfs2(v,v);    &#125;&#125;inline void up(int p)&#123;tr[p].mn=min(tr[ls(p)].mn,tr[rs(p)].mn);&#125;inline void build(int l,int r,int &amp;p)&#123;    if(!p) p=++segcnt;    if(l==r)&#123;tr[p].mn=a[t[l].seq];return;&#125;    int mid=(l+r)&gt;&gt;1;    build(l,mid,ls(p)),build(mid+1,r,rs(p));    up(p);&#125;inline void update(int l,int r,int pos,int val,int p)&#123;    if(l==r)&#123;tr[p].mn=val;return;&#125;    int mid=(l+r)&gt;&gt;1;    if(pos&lt;=mid) update(l,mid,pos,val,ls(p));    else update(mid+1,r,pos,val,rs(p));    up(p);&#125;inline int query(int l,int r,int L,int R,int p)&#123;    if(l&gt;=L&amp;&amp;r&lt;=R) return tr[p].mn;    int mid=(l+r)&gt;&gt;1,res=inf;    if(L&lt;=mid) res=min(res,query(l,mid,L,R,ls(p)));    if(R&gt;mid) res=min(res,query(mid+1,r,L,R,rs(p)));    return res;&#125;inline int query(int u,int v)&#123;    int res=inf;    while(t[u].top!=t[v].top)&#123;        if(t[t[u].top].dep&lt;t[t[v].top].dep) swap(u,v);        res=min(res,query(1,tot,t[t[u].top].dfn,t[u].dfn,1));        u=t[t[u].top].fa;    &#125;    if(t[u].dep&gt;t[v].dep) swap(u,v);    res=min(res,query(1,tot,t[u].dfn,t[v].dfn,1));    if(u&gt;n) res=min(res,a[t[u].fa]);    return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;Q;tot=n;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    tarjan(1,0),dfs1(1,0),dfs2(1,1);    for(re int i=2;i&lt;=n;++i) s[t[i].fa-n].insert(a[i]);    for(re int i=n+1;i&lt;=tot;++i) a[i]=s[i-n].empty()?inf:*s[i-n].begin();    build(1,tot,rt);    char op;int x,y;    while(Q--)&#123;        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;        if(op==&#x27;C&#x27;)&#123;            update(1,tot,t[x].dfn,y,1);            if(x==1)&#123;a[x]=y;continue;&#125;            s[t[x].fa-n].erase(s[t[x].fa-n].lower_bound(a[x]));            s[t[x].fa-n].insert(y);            int mn=*s[t[x].fa-n].begin();            if(mn==a[t[x].fa])&#123;a[x]=y;continue;&#125;            update(1,tot,t[t[x].fa].dfn,mn,1);            a[t[x].fa]=mn,a[x]=y;         &#125;        else cout&lt;&lt;query(x,y)&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n【模板】静态仙人掌双倍经验： Freda的传呼机\n不会，摆。\n【MX-S1-T3】电动力学困难 dp，摆。\n「SWTR-8」地地铁铁困难性质，摆。\n","categories":["学习笔记"],"tags":["图论"]},{"title":"拉格朗日插值学习笔记","url":"/posts/1126bb36/","content":"引入在初中时，我们都学过一次函数，一定也都做过这种题：\n\n给定两个点，求经过这两个点的一次函数的解析式。\n\n我们只需要待定系数法，然后把点坐标带进去解方程即可。\n那么推广一下，可以得到结论：\n\n在平面直角坐标系中，n+1 个点能唯一确定一个 n 次多项式。\n\n但如果我们暴力高斯消元，复杂度是 O(n^3) 的。\n而拉格朗日插值法可以在 O(n^2) 的复杂度内解决这个问题。\n单点求值设 f(x) 为待求多项式，(x_i,y_i) 为第 i 个点的坐标。\n设拉格朗日基本多项式为\n\ng_j(x)=\\prod_{i=0,i\\neq j}^n \\frac {x-x_i}{x_j-x_i}这个多项式十分巧妙。\n可以发现，\\forall i\\in[0,n],g_j(x_i)=[i=j]。\n根据基本多项式，我们可以构造出 f(x)：\n\nf(x)=\\sum_{i=0}^n y_ig_i(x)根据基本多项式的性质，我们可以得到 f(x_i)=y_i，也就是恰好经过这 n+1 个点。\n那么单点求值时，只需要把那个点带进去即可。\n复杂度 O(n^2)\n事实上应该线性求逆元才是严格 O(n^2) 的，但我懒了，所以写的是 O(n^2\\log n) 的。\n例题：【模板】拉格朗日插值\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e3+10,mod=998244353;int n,k,ans;int x[maxn],y[maxn];inline int qpow(int a,int b)&#123;    int res=1;    while(b)&#123;        if(b&amp;1) res=res*a%mod;        b&gt;&gt;=1;        a=a*a%mod;    &#125;    return res;&#125;inline int inv(int x)&#123;return qpow(x,mod-2);&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;k;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;x[i]&gt;&gt;y[i];    for(re int i=1;i&lt;=n;++i)&#123;        int s1=y[i],s2=1;        for(re int j=1;j&lt;=n;++j)&#123;            if(i!=j) s1=s1*((k-x[j])%mod+mod)%mod,s2=s2*((x[i]-x[j])%mod+mod)%mod;        &#125;        ans=(ans+s1%mod*inv(s2)%mod)%mod;    &#125;    cout&lt;&lt;ans;    return 0;&#125;\n求出系数现在我们已经可以做到 O(n^2) 复杂度的单点求值了。\n但这还不够，因为我想具体求出来这个多项式。\n把上面那个东西拿过来：\n\nf(x)=\\sum_{i=0}^n y_i\\prod_{j=0,j\\neq i}^n\\frac {x-x_j}{x_i-x_j}提出常数部分：\n\na_i=\\frac{y_i}{\\prod_{j=0,j\\neq i}^n(x_i-x_j)}然后设 g(k)=\\prod_{i=0}^n(k-x_i)，则\n\nf(x)=\\sum_{i=0}^n a_i\\frac {g(x)}{x-x_i}我们可以暴力的把 g(x) 这个多项式算出来，这是 O(n^2) 的。\n然后对于每一项，我们暴力模拟长除法，总复杂度是 O(n^2) 的。\n综上，我们在 O(n^2) 的复杂度内得到了多项式的系数。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e3+10,mod=998244353;int n,k;int x[maxn],y[maxn];int f[maxn],g[maxn];int a[maxn];int tmp[maxn];inline int qpow(int a,int b)&#123;    int res=1;    while(b)&#123;        if(b&amp;1) res=res*a%mod;        b&gt;&gt;=1;        a=a*a%mod;    &#125;    return res;&#125;inline int Inv(int x)&#123;return qpow(x,mod-2);&#125;inline void pre()&#123;    for(re int i=1;i&lt;=n;++i)&#123;        int res=1;        for(re int j=1;j&lt;=n;++j)&#123;            if(i!=j) res=res*(x[i]-x[j]+mod)%mod;         &#125;        a[i]=y[i]*Inv(res)%mod;    &#125;    g[0]=1;    for(re int i=1;i&lt;=n;++i,swap(g,tmp))&#123;        tmp[0]=0;        for(re int j=1;j&lt;=i;++j) tmp[j]=g[j-1];        for(re int j=0;j&lt;=i;++j) tmp[j]=(tmp[j]+g[j]*(-x[i]+mod)%mod)%mod;    &#125;&#125;inline void Lagrange()&#123;    for(re int i=1;i&lt;=n;++i)&#123;        int lst=0,inv=Inv(-x[i]+mod);        for(re int j=0;j&lt;n;++j)&#123;            tmp[j]=(g[j]-lst+mod)*inv%mod;            f[j]=(f[j]+a[i]*tmp[j]%mod)%mod,lst=tmp[j];        &#125;    &#125;&#125;inline int calc(int x)&#123;    int ans=0,res=1;    for(re int i=0;i&lt;n;++i)&#123;        ans=(ans+res*f[i]%mod)%mod;        res=res*x%mod;    &#125;    return ans;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;k;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;x[i]&gt;&gt;y[i];    pre();    Lagrange();    cout&lt;&lt;calc(k);    return 0;&#125;\nx 取值连续时的优化此时式子变为\n\nf(k)=\\sum_{i=0}^n y_i\\prod_{j=0,i\\neq j}^n \\frac{k-i}{i-j}对于分子，我们维护前缀积和后缀积。\n对于分母，可以发现这是一个阶乘形式。\n所以式子变为\n\nf(k)=\\sum_{i=0}^n y_i\\frac {pre_{i-1}\\times suf_{i+1}}{(i-1)!\\times (n-i)!}当 n-i 为奇数时，分母应为负号。\n复杂度 O(n)\n例题：求 \\sum_{i=1}^n i^k。\nThe Sum of the k-th Powers\n可以证明，\\sum_{i=1}^n i^k 为 k+1 次多项式。\n所以直接取 k+2 个点把它插出来即可。\n取值连续，所以可以做到 O(n)。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e6+10,mod=1e9+7;int n,m,k,ans;int fac[maxn],pre[maxn],suf[maxn];inline int qpow(int a,int b)&#123;    int res=1;    while(b)&#123;        if(b&amp;1) res=res*a%mod;        b&gt;&gt;=1;        a=a*a%mod;    &#125;    return res;&#125;inline int inv(int x)&#123;return qpow(x,mod-2);&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;k;m=k+2;    pre[0]=fac[0]=suf[m+1]=1;    for(re int i=1;i&lt;=m;++i) pre[i]=pre[i-1]*(n-i)%mod;    for(re int i=m;i&gt;=1;--i) suf[i]=suf[i+1]*(n-i)%mod;    for(re int i=1;i&lt;=m;++i) fac[i]=fac[i-1]*i%mod;    int y=0;    for(re int i=1;i&lt;=m;++i)&#123;        y=(y+qpow(i,k)%mod)%mod;        int s1=pre[i-1]%mod*suf[i+1]%mod;        int s2=((m-i)&amp;1?-1ll:1ll)*fac[i-1]%mod*fac[m-i]%mod;        ans=(ans+(y%mod*s1%mod*inv(s2)%mod)%mod+mod)%mod;    &#125;    cout&lt;&lt;ans;    return 0;&#125;\n","categories":["学习笔记"],"tags":["数学"]},{"title":"操作树学习笔记","url":"/posts/7f69f632/","content":"参考文章\n引入有些题目有这样的特点：\n\n允许离线\n需要回退历史版本\n\n这种情况下，我们可以离线所有操作，建立操作树，每个版本对应一个节点，其父亲就是其来源的版本。对于修改操作，回溯时回退即可。\n当然，如果强制在线的话还是上可持久化数据结构吧。\n例题[HBCPC2024] Enchanted第一次见到这个 trick 是在这个题。\n不考虑操作树的话，剩下的和 Mark and Professor Koro 还是很像的。\n对于这种两个相同的数合并成 +1 的数的操作，我们可以把它看成二进制意义下的加法，然后进行维护。\n这道题值域很小，所以可以直接把二进制用整数表示。\n考虑建立操作树，操作四就解决了。\n操作三是单点修改，比较简单。\n操作一就是表示成二进制以后求和找最高位。\n操作二就是表示成二进制以后求和，然后找第 k 位向上的连续位数。\n单点修区间和，树状数组即可。\n复杂度 O(n\\log n)\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define lb(x) (x&amp;(-x))using namespace std;const int maxn=1e6+10,mod=1e9+7;int n,m,seed,P,Q;\tint a[maxn],ans[maxn];struct Query&#123;    int op,x,y,k;&#125;q[maxn];struct BIT&#123;    int tr[maxn];    inline void add(int x,int val)&#123;while(x&lt;=n) tr[x]+=val,x+=lb(x);&#125;    inline int query(int x)&#123;int res=0;while(x) res+=tr[x],x-=lb(x);return res;&#125;&#125;b;vector&lt;int&gt; g[maxn];inline int rnd()&#123;    seed=(7*seed+13)%19260817;    return seed;&#125;inline void dfs(int u)&#123;    int op=q[u].op,x=q[u].x,y=q[u].y,k=q[u].k;    if(op==1)&#123;        int res=b.query(y)-b.query(x-1);        ans[u]=floor(__lg(res))+1;    &#125;    if(op==2)&#123;        int res=b.query(y)-b.query(x-1);        res&gt;&gt;=(k-1);        int bs=(1ll&lt;&lt;(k+1));        while(res&amp;1) ans[u]=(ans[u]+bs)%mod,bs&lt;&lt;=1,res&gt;&gt;=1;    &#125;    if(op==3)&#123;        b.add(x,(1ll&lt;&lt;(q[u].y-1))-(1ll&lt;&lt;(a[x]-1)));        swap(a[x],q[u].y);    &#125;    for(auto v:g[u]) dfs(v);    if(op==3)&#123;        b.add(x,(1ll&lt;&lt;(q[u].y-1))-(1ll&lt;&lt;(a[x]-1)));        swap(a[x],q[u].y);    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;seed&gt;&gt;P&gt;&gt;Q;    for(re int i=1;i&lt;=n;++i) a[i]=rnd()%Q+1,b.add(i,1ll&lt;&lt;(a[i]-1));    for(re int i=1,op,x,y,k;i&lt;=m;++i)&#123;        op=rnd()%P+1;        if(op==1)&#123;            x=rnd()%n+1,y=rnd()%n+1;            if(x&gt;y) swap(x,y);        &#125;        if(op==2)&#123;            x=rnd()%n+1,y=rnd()%n+1,k=rnd()%Q+1;            if(x&gt;y) swap(x,y);        &#125;        if(op==3) x=rnd()%n+1,y=rnd()%Q+1;        if(op==4) x=rnd()%i;        q[i]=&#123;op,x,y,k&#125;;        op==4?g[x].push_back(i):g[i-1].push_back(i);    &#125;    dfs(0);    for(re int i=1;i&lt;=m;++i) if(q[i].op==1||q[i].op==2) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n「TOCO Round 1」History 考虑建立操作树，操作三就解决了。\n操作一是单点修改，比较简单。\n考虑操作二如何实现。\n看到相同深度想到 bfs 序，那么这些点事实上就是 x 的 \\frac {y}{2} 级祖先的子树内和 x 在相同深度的点。\n不难发现这些点的 bfs 序是连续的。\n然后考虑怎么得到  \\frac {y}{2} 级祖先的子树内和 x 在相同深度的点。\n可以发现，这些点的 dfs 序也是连续的。\n所以我们把所有和 x 在相同深度的点拿出来，然后二分找到 dfs 序在 [dfn_{fa},dfn_{fa}+siz_{fa}-1] 的点，那么操作二就变成了区间查询。\n别忘了把 \\frac {y}{2}-1 级祖先的子树内和 x 在相同深度的点扣掉，因为这些点并不合法。\n复杂度 O(n\\log n)\n有些细节，例如 y 可以不合法，而且还能为 0，都需要特判。\nupd：这里写的麻烦了，没必要开 vector 把所有深度的所有点存下来，可能当时写的时候还没太懂。\n我们求出每个深度对应的 bfs 序区间，然后把 bfs 序和 dfs 序对应起来。\n这样在查某个深度的时候，只需要在 bfs序的区间上二分即可。\n具体实现可以看[Cnoi2019] 雪松果树。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define lb(x) (x&amp;(-x))#define pii pair&lt;int,int&gt;#define fi first#define se secondusing namespace std;const int maxn=1e5+10;int n,m,cnt,tim;int a[maxn];int head[maxn],ans[maxn];int fa[maxn][18];int c[maxn];vector&lt;int&gt; g[maxn],Dep[maxn];struct edge&#123;    int to,nxt;&#125;e[maxn&lt;&lt;1];struct Query&#123;    int op,x,y;&#125;q[maxn];struct node&#123;    int dfn,bfn,siz,dep,seq;&#125;t[maxn];struct BIT&#123;    int tr[maxn];    inline void add(int x,int val)&#123;++x;while(x&lt;=n+1) tr[x]+=val,x+=lb(x);&#125;    inline int query(int x)&#123;++x;int res=0;while(x) res+=tr[x],x-=lb(x);return res;&#125;&#125;b;inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void bfs(int s)&#123;    queue&lt;pii&gt; q;    q.push(&#123;s,1&#125;);    while(!q.empty())&#123;        int u=q.front().fi,dep=q.front().se;        q.pop();        t[u].bfn=++tim,Dep[dep].push_back(t[u].dfn),t[u].dep=dep;        for(re int i=head[u];i;i=e[i].nxt)&#123;            int v=e[i].to;            if(!t[v].bfn) q.push(&#123;v,dep+1&#125;);        &#125;    &#125;&#125;inline void dfs1(int u,int ft)&#123;    t[u].siz=1;fa[u][0]=ft;    t[u].dfn=++tim;t[tim].seq=u;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(v==ft) continue;        dfs1(v,u);        t[u].siz+=t[v].siz;    &#125;&#125;inline void init()&#123;    for(re int j=1;j&lt;=17;++j)&#123;        for(re int u=1;u&lt;=n;++u)&#123;            fa[u][j]=fa[fa[u][j-1]][j-1];        &#125;    &#125;&#125;inline int find(int u,int dep)&#123;    for(re int i=17;i&gt;=0;--i) if(dep&gt;=(1ll&lt;&lt;i)) u=fa[u][i],dep-=(1ll&lt;&lt;i);    return u;&#125;inline void dfs(int u)&#123;    int op=q[u].op,x=q[u].x,y=q[u].y;    if(op==1) a[x]?b.add(t[x].bfn,-1):b.add(t[x].bfn,1),a[x]^=1;    if(op==2&amp;&amp;!(y&amp;1))&#123;        if(y==0) ans[u]=a[x];        else&#123;            int fa=find(x,y/2),dep=t[x].dep;            if(fa)&#123;                int l=Dep[dep][lower_bound(Dep[dep].begin(),Dep[dep].end(),t[fa].dfn)-Dep[dep].begin()];                int r=Dep[dep][upper_bound(Dep[dep].begin(),Dep[dep].end(),t[fa].dfn+t[fa].siz-1)-Dep[dep].begin()-1];                l=t[l].seq,r=t[r].seq;                ans[u]+=(b.query(t[r].bfn)-b.query(t[l].bfn-1));\t            &#125;            if(fa) fa=find(x,y/2-1);            if(fa)&#123;                int l=Dep[dep][lower_bound(Dep[dep].begin(),Dep[dep].end(),t[fa].dfn)-Dep[dep].begin()];                int r=Dep[dep][upper_bound(Dep[dep].begin(),Dep[dep].end(),t[fa].dfn+t[fa].siz-1)-Dep[dep].begin()-1];                l=t[l].seq,r=t[r].seq;                ans[u]-=(b.query(t[r].bfn)-b.query(t[l].bfn-1));            &#125;\t        &#125;    &#125;    for(auto v:g[u]) dfs(v);    if(op==1) a[x]?b.add(t[x].bfn,-1):b.add(t[x].bfn,1),a[x]^=1;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n;    for(re int i=1,u,v;i&lt;n;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    cin&gt;&gt;m;    for(re int i=1;i&lt;=m;++i)&#123;        cin&gt;&gt;q[i].op&gt;&gt;q[i].x;        if(q[i].op==2) cin&gt;&gt;q[i].y;        q[i].op==3?g[q[i].x].push_back(i):g[i-1].push_back(i);    &#125;    dfs1(1,0);tim=0;bfs(1);init();    dfs(0);    for(re int i=1;i&lt;=m;++i) if(q[i].op==2) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\nPersistent Bookcase *2200建操作树后暴力 bitset 维护即可。\n对一行取反可以先把一个全为 1 的 bitset 处理出来，然后异或这个 bitset 即可。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e3+10,maxq=1e5+10;int n,m,Q,now;int ans[maxq];bitset&lt;maxn&gt; a[maxn],A;vector&lt;int&gt; g[maxq];struct query&#123;    int op,x,y;&#125;q[maxq];inline void dfs(int u)&#123;    int op=q[u].op,x=q[u].x,y=q[u].y;    bool sta=0;    if(op==1)&#123;        sta=a[x][y];        if(!a[x][y]) ++now;        a[x][y]=1;    &#125;    if(op==2)&#123;        sta=a[x][y];        if(a[x][y]) --now;        a[x][y]=0;    &#125;    if(op==3)&#123;        int res=a[x].count();        a[x]^=A;        now+=a[x].count()-res;    &#125;    ans[u]=now;    for(auto v:g[u]) dfs(v);    if(op==1)&#123;        if(!sta) --now;        a[x][y]=sta;    &#125;    if(op==2)&#123;        if(sta) ++now;        a[x][y]=sta;    &#125;    if(op==3)&#123;        int res=a[x].count();        a[x]^=A;        now+=a[x].count()-res;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;Q;    for(re int i=1;i&lt;=m;++i) A[i]=1;    for(re int i=1,op,x,y;i&lt;=Q;++i)&#123;        cin&gt;&gt;op;        if(op==1||op==2) cin&gt;&gt;x&gt;&gt;y;        else cin&gt;&gt;x;        q[i]=&#123;op,x,y&#125;;        op==4?g[x].push_back(i):g[i-1].push_back(i);     &#125;    dfs(0);    for(re int i=1;i&lt;=Q;++i) cout&lt;&lt;ans[i]&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n可持久化并查集没有强制在线，所以考虑操作树。\n维护个可撤销并查集就行了。\n没写代码。\nTTM - To the moon没有强制在线，所以考虑操作树。\n然后线段树维护就行了。\n然而当初做这道题是为了学主席树如何区间修改（标记永久化）。\n[Ynoi2014] 等这场战争结束之后如果没有回撤，那么这是[HNOI2012] 永无乡，并查集+线段树合并即可。\n那我暴力线段树合并+分裂行不行？不行，因为每次撤销都可以卡成 O(n) 次分裂，那就寄了。\n那我 LCT 上维护 set 行不行？不行，理由同上。\n我们真的需要 LCT 维护这个东西吗？事实上不用，因为我们只关心连通性，所以可撤销并查集就足够了。\n那 kth 怎么解决？线段树用不了了，那就值域分块！\n我们对每个联通块维护所有整块的信息，合并时暴力合并。\n查询也很简单，因为相当于查全局 kth，直接枚举每个整块，然后找到落在哪个块时就枚举这个块里的值。\n枚举值的时候要判断这个值对应的点是否在联通块内，所以要给值和点对应一个关系（下面提到了）。\n时间复杂度 O(n\\log n+q(\\frac {n}{B}+B\\log n))，空间复杂度 O(\\frac {n^2}{B})。\n块长取 B=\\sqrt \\frac{n}{\\log n} 时最优。\n时间复杂度 O(n\\log n+q\\sqrt {n\\log n})，空间复杂度 O(n\\sqrt {n\\log n})\n代码倒是没有很难写，主要是卡空间卡的要死。\n卡空间的一些技巧：\n\n块长调大点\n能开 short 的数组开 short\n别用 vector 存图，用链式前向星\n能不存的就别存，例如每个块的起始终点之类的\n\n还有一些需要注意的点：\n\n离散化时，相同的数不能视为一个，因为在查询时，我们查到一个整块的里面时，需要知道每个值对应的下标是否在当前连通块里，所以编号要注意。\n别写 UB 或你弄不懂到底会怎么运行的代码。例如我参考的题解里写了一句 a[i]+=cnt[a[i]]++;，这东西你真能弄清吗。\n\n因为一直卡不过去所以最后参考了题解，代码也跟题解差不多了，而且写的也很丑，所以不放代码了。\n","categories":["学习笔记"],"tags":["数据结构","其他技巧"]},{"title":"笛卡尔树学习笔记","url":"/posts/9c20eda6/","content":"笛卡尔树是一种二叉树，它既满足二叉搜索树的性质，又满足堆的性质。\n例如 treap，就属于笛卡尔树的一种。\n以下规定：第一键值为满足二叉搜索树的键值，第二键值为满足堆的键值。\n构建我们可以用单调栈做到 O(n) 建树。\n我们考虑将下标作为第一键值，权值作为第二键值。\n那么每次我们插入的元素必然在这棵树的右链（右链：即从根节点一直往右子树走，经过的节点形成的链）的末端。\n所以我们可以用栈来维护笛卡尔树的右链。\n假设我们要建一颗大根笛卡尔树。\n设当前位置为 i，前 i-1 个位置已经构建好了。设栈顶元素为 a_{top}。\n我们维护值单调递增的单调栈。\n若 a_i \\le a_{top}，直接将 i 入栈（也就是把 i 挂在右链上）。\n否则一直弹栈，直到栈空或 a_i \\le a_{top}。把最后一个弹出的元素设为 i 的左儿子。\nfor(re int i=1;i&lt;=n;++i)&#123;    int tmp=top;    while(tmp&amp;&amp;a[stk[tmp]]&lt;a[i]) --tmp;    if(tmp) rs[stk[tmp]]=i;    if(tmp&lt;top) ls[i]=stk[tmp+1];    stk[++tmp]=i;    top=tmp;&#125;\n事实上，如果要按某个值作为第一键值，那么按这个值排序即可。\n可以发现，笛卡尔树的根就是 stk_1。\n应用笛卡尔树大多用来 dp。\n对原问题转化后，变为笛卡尔树上的 dp 问题。\n而且一般只会用到思想，并不会真把树建出来。\n以及一些直方图似乎也会用到。\n对于直方图类问题，我们常把下标作为第一键值，h_i 作为第二键值建立小根笛卡尔树。\n例题[TJOI2011] 树的序一道考察笛卡尔树定义的题。\n题目给的很明白了，要按权值当第一键值。\n因为要求字典序最小的生成序列，所以我们把每个数在序列中的位置当作第二键值，然后建小根笛卡尔树即可。\n因为插入顺序是父亲-&gt;左儿子-&gt;右儿子，所以输出先序遍历即可。\n注意输出的是键而不是编号。\nLargest Rectangle in a Histogram笛卡尔树求矩形面积板子题。\n我们把下标作为第一键值，h_i 作为第二键值建立小根笛卡尔树。\n枚举点 u，看当 h_u 作为矩形的高度时的最大面积。\n因为我们建的是小根树，所以子树内的点的 h_i 都大于 h_u。\n因为下标是键，所以子树内的点构成一段连续区间。\n那么以 h_u 作为高时的最大面积为 siz_u\\times h_u。\n[COCI2008-2009#4] PERIODNI我们考虑把这个多边形转成树。\n受上题启发，我们把下标作为第一键值，h_i 作为第二键值建立小根笛卡尔树。\n\n我们每次找到最低点，分成左右两边，然后递归处理。\n不难发现，这些矩形对应笛卡尔树上的所有节点。\n对于点 u,它代表的长为 siz_u，宽为 h_u-h_{fa}。\n因为两个儿子是分开的，所以可以直接合并，没有影响。\n设 f_{u,i} 表示以 u 为根的子树放了 i 个的方案数，g_{u,i} 表示以 u 为根的子树放了 i 个，且不包括 u 代表的矩形的方案数。\n那么 g 的转移就是背包。\n\ng_{u,i}=\\sum_{j=0}^i f_{ls,j}\\times f_{rs,i-j}至于 f 的转移，就是考虑 u 放几个。\n有结论：大小为 n\\times m 的棋盘，放 k 个互不攻击的车，方案数为 \\binom{n}{k}\\times \\binom{m}{k}\\times k!\n那么枚举子树一共用了几个，剩下的就是自己用的。\n注意子树用了的自己不能用。\n\nf_{u,i}=\\sum_{j=0}^i \\binom{siz_u}{i-j}\\times \\binom{h_u-h_{fa}}{i-j}\\times (i-j)!\\times g_{u,j}复杂度 O(nk^2+n^2)\nYet Another Array Counting Problem以下标为第一键值，a_i 为第二键值建立大根笛卡尔树，那么 [l,r] 的最左端最大值位置就是 l,r 在笛卡尔树上的 \\operatorname{lca}。\n那么所有最左端最大值位置都相等，就意味着笛卡尔树的形态相同。\n此时转化为树计数问题。\n设 f_{u,i} 表示 u 取值 1 \\sim i 的方案数。\n左儿子可以填 [1,i-1]，右儿子可以填 [1,i]\n转移就是 f_{u,i}=f_{u,i-1}+f_{ls_u,i-1}\\times f_{rs_u,i}\n复杂度 O(nm)\n","categories":["学习笔记"],"tags":["数据结构"]},{"title":"东方Project相关试题选做","url":"/posts/dd439af8/","content":"不知道写什么题了，那就来刷东方题单吧！\n绿以下的题被以前的我秒完了，所以从绿开始写。\n大概只会做简单题。\n题目按照我做的顺序排列。\n题单\nManipulating History被 *1700 的诈骗创飞了。    \n思考的时候一直在从字符串匹配的角度出发，然后啥也想不出来。\n想贪心也贪不动，因为保证唯一解所以没东西能贪。\n中间想到过一点正确思路：起始的那个字母在后面没有出现过。\n但是瞬间弃掉了。\n事实上，我们只需要关心每个字母的出现次数即可。\n开始的那个字母在所有的字符串中一定出现了奇数次，其他字母一定都出现了偶数次。\n证明也是容易的：\n\n把最终字符串当成一次操作，删除整串，并添加空串，则所有字母出现的次数都是 0（偶数）。\n开始时只有一个字母出现次数为奇数，即中间的改变次数为奇数，其他字母的改变次数为偶数。\n即开始的那个字母在所有的字符串中一定出现了奇数次，其他字母一定都出现了偶数次。\n\n琪露诺单调队列优化 DP 模板题。\n上白泽慧音强连通分量模板题。\n红色的幻想乡疑似学高级数据结构学傻了，树套树做不了就没思路了。\n十字取反，矩形求和，听上去是不是非常不可做？\n事实上，我们只需要对行和列分别维护一颗线段树即可。\n因为一个点的状态只和它所在的行和列的操作次数的奇偶性有关：若行和列的操作次数的奇偶性相同，则这个点为 0，否则为 1。\n所以只需要分别维护每行和每列的操作次数的奇偶性即可。\n此时十字取反变成了单点取反，矩形求和变成了区间求和。\n做完了。\n小魔女帕琪我是期望低手，让我做期望不如沙了我。\n首先加强一下，把 7 种改成 n 种。\n设 sum=\\sum_{i=1}^n a_i。\n根据期望的线性性，我们可以用所有方案的总贡献除以方案数得到期望。\n方案数是好算的，就是一个多重集的排列数。\n然后考虑贡献。\n我们考虑每个长度为 n 的区间带来的贡献。显然每个区间都是相同的，所以只需要考虑一个然后乘上区间数量即可。\n因为每个长度为 n 的区间贡献都是 1，所以依旧算方案数即可。\n因为要这个保证这个区间是合法的，所以必须每种元素有一个，方案数为 n!。\n剩下位置可以乱填，又是一个多重集的排列数。\n最后乘上区间数量即可。\n所以答案为\n\n\\frac {n!\\times \\frac{(sum-n)!}{\\prod_{i=1}^n (a_i-1)!}\\times (sum-n+1)}{\\frac{sum!}{\\prod_{i=1}^na_i!}}化简一下，可以得到\n\n\\frac {n!\\times \\prod_{i=1}^na_i}{sum^{\\underline{n-1}}}下划线代表下降幂。\nSAC E#1 - 一道难题 Tree1.考虑最小割。\n建一个汇点，把所有叶子向汇点连边，然后直接求最小割即可。\n为什么这么做就是对的？\n因为一棵树中，任意两点间有且只有一条简单路径，所以只需要把根到叶子的路径上的任意一条边割掉即可，所以求最小割就是对的。\n2.考虑 DP。\n加强版：[SDOI2011] 消耗战\n设 f_u 表示根和以 u 为根子树不连通的最小代价，mn_u 表示根到 u 路径上的最小边权，转移为\n\nf_u=\\min(mn_u,\\sum_{v\\in sub_u} f_v)复杂度 O(n)\n三步必杀区间加等差数列，常见做法是维护差分，这样就变成对差分数组区间加了。\n但是这道题复杂度要求 O(n)，不能直接线段树。\n不过没有一边修改一边查询，而是只有最后有一次查询，所以区间加可以差分一下变成单点加。\n因为做了两次差分，所以最后做两遍前缀和即可复原。\n萃香的请柬考验选手观察能力。\n如果把题目中给的图继续往下写几行，就可以发现：序列的长度是斐波那契数列，1 的个数也是斐波那契数列。\n然后查询只需要差分一下即可。\n那题目里给的初始状态呢？没有用吗？\n是的。\n这是因为无论初始状态是什么样，在经过无限长的时间后，序列都和一开始只有一个 1 的状态是一样的。\n查询时的拆分为什么正确？\n因为根据齐肯多夫定理：任意正整数可以被拆分为若干个不连续的 Fibonacci 数之和。\n这个东西在 [SNOI2020] 取石子 中也有使用（斐波那契进制下的数位 DP）。\n[BJWC2012] 冻结 分层图最短路模板题。\n分成 k 层，每向下走一层代表用一张卡，最后对每一层的终点距离取 \\min 即可。\nOIer们的东方梦刚学搜索的时候做的题，现在怎么升蓝了。\n写一个堆优化的 BFS 就可以过了。\n没啥思维量，就是代码比较难写，细节比较多。\n荷取融合又 是 期 望。\n依旧根据期望的线性性，先算总贡献，再算方案数。\n我们把题目中的游戏转化一下，从另一个角度考虑。\n我们把题目中的向右走和停下拆开，拆成每次只能向右走一步和在当前格停下。\n可以发现，我们只有在停下时才会有收益。\n设 f_{i,j} 表示前 i 格停下了 j 次的方案数，g_{i,j} 表示前 i 格停下了 j 次的总收益，转移为\n\nf_{i,j}=f_{i-1,j}+f_{i,j-1}\n\\\\\ng_{i,j}=g_{i-1,j}+g_{i,j-1}\\times a_i转移容易理解，就是从上一格走过来或者在当前格停下，停下时可以获得收益。\n那么为什么这种理解方式和之前那种游戏的操作是对应的？\n事实上，我们只是把之前的向右移动若干步并停下拆成了向右移动一步和停下。\n而且我们的每一次停下都对应原来的一次操作，这就一一对应了。\n答案为 \\frac {g_{n,k}}{f_{n,k}}。\n需要滚动数组。\n回忆京都啥玩意，这是来搞笑的吗。\n预处理组合数，然后求前缀和，没了啊？\n一开始还以为读错题了，这能有绿啊？\n[Cnoi2019] 数学作业第一眼以为是高维前缀和，然后不会了。\n什么时候才能记住位运算的每一位是独立的！！！\n既然是异或，那我们按位考虑。\n假设当前考虑到第 k 位，那我们把所有数的第 k 位拿出来。现在就是要求这个 01 序列的所有子集的异或和的和。\n如果整个序列都是 0，那么答案显然是 0。\n如果有至少一个 1，那么我们可以特殊的考虑其中的一个 1。\n剩下的 n-1 个元素一共有 2^{n-1} 种选法。而无论哪种选法，我们都可以控制这个特殊的 1 选不选来让这种选法产生贡献。\n所以一共会产生 2^{n-1}\\times 2^k 的贡献。\n最后把这些贡献加起来就是对的。\n事实上，我们只需要把所有数都或起来，然后乘 2^{n-1} 就是答案（想一想为什么）。\n「Wdsr-1」小铃的书 学到了没用的新技巧：如何开桶。\n第一想法是开桶记录每种数出现个数。\n但是值域让我们无法做到这一点。\n离散化也不行，我们做不到存下来这些数。\n但有一个性质：一个数的出现次数和这个数在另一个进制下每一位上的数字的出现次数相同。\n这很好理解，就是把这个数换了个进制表示而已。\n这非常好：因为我们能开的下桶了。\n这里我选了 100 进制，已经足够用了（10^{18}=100^9）。\n以下是一份没有加快读的代码，无法通过。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=10,base=100;int n,k;int buc[maxn][base];inline int qpow(int a,int b)&#123;    int res=1;    while(b)&#123;        if(b&amp;1) res=res*a;        b&gt;&gt;=1;        a=a*a;    &#125;    return res;&#125;inline void add(int x)&#123;    int len=0;    while(x)&#123;++buc[len++][x%base],x/=base;&#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;k;    for(re int i=1,x;i&lt;=n;++i) cin&gt;&gt;x,add(x);    int ans=0;    for(re int i=0;i&lt;=9;++i)&#123;        for(re int j=0;j&lt;=99;++j)&#123;            buc[i][j]%=k;            if(!buc[i][j]) continue;            ans+=qpow(base,i)*j;        &#125;    &#125;    cout&lt;&lt;ans;    return 0;&#125;\n「Wdoi-1」加密通信好吧，又想少了。\n可以发现，B_i=\\gcd(A_i,A_{i-1})。\n所以直接算就行了？\n显然不对，如果 A_{i-1}=A_i 就寄了。\n但题目保证了存在 A_i \\neq A_j，所以找出来相邻的两个不同的数算出来 \\gcd 然后往两边推出来所有 B 即可。\n「Wdsr-2」间歇泉这不是我们 CSP-S 2024 一轮的 序列合并  吗？\n容易想到二分答案，然后转化成数数问题。\n设当前二分到 mid，则需要数 \\frac {a_ic_i+a_jc_j}{a_i+a_j}\\ge mid 的点对 (i,j) 的对数。\n移项，得到 a_i\\times (c_i-mid)\\ge a_j\\times (mid-c_j)。\n设 A_i=a_i\\times (c_i-mid),B_i=a_i\\times (mid-c_i)。\n那么现在问题转化成了求 A_i \\ge B_j 的点对 (i,j) 的对数。\n这是经典问题，排序后双指针即可（也可以树状数组，感觉更好写，不过这题是浮点数用不了树状数组）。\n「Wdsr-2.5」琪露诺的算数游戏 大模拟。\n所以我写了这道题。\n总用时约 1.5 h。\n一些注意事项：\n\n变量名别写错。\n不知道为什么 stoi 寄了，所以需要手写 string 转 int。\n除法向上取整在负数情况下会寄，需要用 floor。\ndouble 状态的人在出完第一张基本牌时要把 double 状态清掉。\n仔细读题，别漏细节。\n\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=35,maxm=3e5+10,K=99,inf=1e18;int n,m,k;int turn,now,nowp,nowpai;inline int to_int(string s)&#123;    int res=0;    for(re int i=0;i&lt;s.length();++i) res=res*10+(s[i]-&#x27;0&#x27;);    return res;&#125;struct card&#123;    string name;    int op,x;    inline void init()&#123;        if(name==&quot;PASS&quot;) op=6;        else if(name==&quot;TURN&quot;) op=7;        else if(name==&quot;DOUBLE&quot;) op=8;        else&#123;            string s=&quot;&quot;;            for(re int i=1;i&lt;name.length();++i) s+=name[i];            x=to_int(s);            if(name[0]==&#x27;A&#x27;) op=1;            if(name[0]==&#x27;B&#x27;) op=2;            if(name[0]==&#x27;C&#x27;) op=3;            if(name[0]==&#x27;D&#x27;) op=4;            if(name[0]==&#x27;E&#x27;) op=5;        &#125;    &#125;&#125;t[maxm];struct player&#123;    string name;    card c[4];    bool op;&#125;p[maxn];inline void end_turn(int id)&#123;    p[now].c[id]=t[nowpai++];    now=(now+turn)%n;if(!now) now=n;&#125;inline bool solve2()&#123;    int nxtp=0,mxp=-inf,id=0,cnt=0;    for(re int j=1;j&lt;=3;++j)&#123;        if(p[now].c[j].op&lt;=5)&#123;            ++cnt;            if(p[now].c[j].op==1)&#123;                nxtp=nowp+p[now].c[j].x;                if(nxtp&lt;=K)&#123;                    if(mxp&lt;nxtp) mxp=nxtp,id=j;                    else if(mxp==nxtp)&#123;                        if(p[now].c[id].op==2||p[now].c[id].op==4||p[now].c[id].op==5) id=j;                    &#125;                &#125;            &#125;            if(p[now].c[j].op==2)&#123;                nxtp=nowp-p[now].c[j].x;                if(nxtp&lt;=K)&#123;                    if(mxp&lt;nxtp) mxp=nxtp,id=j;                    else if(mxp==nxtp)&#123;                        if(p[now].c[id].op==4||p[now].c[id].op==5) id=j;                    &#125;                &#125;            &#125;            if(p[now].c[j].op==3)&#123;                nxtp=nowp*p[now].c[j].x;                if(nxtp&lt;=K)&#123;                    if(mxp&lt;nxtp) mxp=nxtp,id=j;                    else if(mxp==nxtp)&#123;                        if(p[now].c[id].op==1||p[now].c[id].op==2||p[now].c[id].op==4||p[now].c[id].op==5) id=j;                    &#125;                &#125;            &#125;            if(p[now].c[j].op==4)&#123;                nxtp=floor(1.0*nowp/p[now].c[j].x);                if(nxtp&lt;=K)&#123;                    if(mxp&lt;nxtp) mxp=nxtp,id=j;                    else if(mxp==nxtp)&#123;                        if(p[now].c[id].op==5) id=j;                    &#125;                &#125;            &#125;            if(p[now].c[j].op==5)&#123;                nxtp=p[now].c[j].x;                if(nxtp&lt;=K)&#123;                    if(mxp&lt;nxtp) mxp=nxtp,id=j;                    else if(mxp==nxtp)&#123;&#125;                &#125;            &#125;        &#125;    &#125;    if(mxp==-inf)&#123;        if(cnt==3)&#123;            for(re int j=1;j&lt;=3;++j) p[now].c[j]=t[nowpai++];            cout&lt;&lt;p[now].name&lt;&lt;&quot; lost the game.\\n&quot;;            return 0;        &#125;        else&#123;            int id1=0,id2=0,id3=0;            for(re int j=1;j&lt;=3;++j)&#123;                if(p[now].c[j].op==6) id1=j;                if(p[now].c[j].op==7) id2=j;                if(p[now].c[j].op==8) id3=j;            &#125;            if(id1)&#123;                cout&lt;&lt;p[now].name&lt;&lt;&quot; used &quot;&lt;&lt;p[now].c[id1].name&lt;&lt;&quot;,now p=&quot;&lt;&lt;nowp&lt;&lt;&quot;.\\n&quot;;                end_turn(id1);            &#125;            else if(id2)&#123;                turn*=-1;                cout&lt;&lt;p[now].name&lt;&lt;&quot; used &quot;&lt;&lt;p[now].c[id2].name&lt;&lt;&quot;,now p=&quot;&lt;&lt;nowp&lt;&lt;&quot;.\\n&quot;;                end_turn(id2);            &#125;            else if(id3)&#123;                int nxt=(now+turn)%n;                if(!nxt) nxt=n;                p[nxt].op=1;                cout&lt;&lt;p[now].name&lt;&lt;&quot; used &quot;&lt;&lt;p[now].c[id3].name&lt;&lt;&quot;,now p=&quot;&lt;&lt;nowp&lt;&lt;&quot;.\\n&quot;;                end_turn(id3);            &#125;        &#125;    &#125;    else&#123;        nowp=mxp;        cout&lt;&lt;p[now].name&lt;&lt;&quot; used &quot;&lt;&lt;p[now].c[id].name&lt;&lt;&quot;,now p=&quot;&lt;&lt;nowp&lt;&lt;&quot;.\\n&quot;;        end_turn(id);    &#125;    return 1;&#125;inline bool solve1()&#123;    int id1=0,id2=0,id3=0;    for(re int j=1;j&lt;=3;++j)&#123;        if(p[now].c[j].op==6) id1=j;        if(p[now].c[j].op==7) id2=j;        if(p[now].c[j].op==8) id3=j;    &#125;    if(id1)&#123;        p[now].op=0;        cout&lt;&lt;p[now].name&lt;&lt;&quot; used &quot;&lt;&lt;p[now].c[id1].name&lt;&lt;&quot;,now p=&quot;&lt;&lt;nowp&lt;&lt;&quot;.\\n&quot;;        end_turn(id1);        p[now].op=1;    &#125;    else if(id2)&#123;        turn*=-1;        p[now].op=0;        cout&lt;&lt;p[now].name&lt;&lt;&quot; used &quot;&lt;&lt;p[now].c[id2].name&lt;&lt;&quot;,now p=&quot;&lt;&lt;nowp&lt;&lt;&quot;.\\n&quot;;        end_turn(id2);        p[now].op=1;    &#125;    else if(id3)&#123;        p[now].op=0;        cout&lt;&lt;p[now].name&lt;&lt;&quot; used &quot;&lt;&lt;p[now].c[id3].name&lt;&lt;&quot;,now p=&quot;&lt;&lt;nowp&lt;&lt;&quot;.\\n&quot;;        end_turn(id3);        p[now].op=1;    &#125;    else&#123;        int nxtp=0,mnp=inf,id=0;        for(re int j=1;j&lt;=3;++j)&#123;            if(p[now].c[j].op&lt;=5)&#123;                if(p[now].c[j].op==1)&#123;                    nxtp=nowp+p[now].c[j].x;                    if(nxtp&lt;=K)&#123;                        if(mnp&gt;nxtp) mnp=nxtp,id=j;                        else if(mnp==nxtp)&#123;                            if(p[now].c[id].op==3||p[now].c[id].op==5) id=j;                        &#125;                    &#125;                &#125;                if(p[now].c[j].op==2)&#123;                    nxtp=nowp-p[now].c[j].x;                    if(nxtp&lt;=K)&#123;                        if(mnp&gt;nxtp) mnp=nxtp,id=j;                        else if(mnp==nxtp)&#123;                            if(p[now].c[id].op==1||p[now].c[id].op==3||p[now].c[id].op==5) id=j;                        &#125;                    &#125;                &#125;                if(p[now].c[j].op==3)&#123;                    nxtp=nowp*p[now].c[j].x;                    if(nxtp&lt;=K)&#123;                        if(mnp&gt;nxtp) mnp=nxtp,id=j;                        else if(mnp==nxtp)&#123;                            if(p[now].c[id].op==5) id=j;                        &#125;                    &#125;                &#125;                if(p[now].c[j].op==4)&#123;                    nxtp=floor(1.0*nowp/p[now].c[j].x);                    if(nxtp&lt;=K)&#123;                        if(mnp&gt;nxtp) mnp=nxtp,id=j;                        else if(mnp==nxtp)&#123;                            if(p[now].c[id].op==2||p[now].c[id].op==1||p[now].c[id].op==3||p[now].c[id].op==5) id=j;                        &#125;                    &#125;                &#125;                if(p[now].c[j].op==5)&#123;                    nxtp=p[now].c[j].x;                    if(nxtp&lt;=K)&#123;                        if(mnp&gt;nxtp) mnp=nxtp,id=j;                        else if(mnp==nxtp)&#123;&#125;                    &#125;                &#125;            &#125;        &#125;        if(mnp==inf)&#123;            p[now].op=0;            for(re int j=1;j&lt;=3;++j) p[now].c[j]=t[nowpai++];            cout&lt;&lt;p[now].name&lt;&lt;&quot; lost the game.\\n&quot;;            return 0;        &#125;        else&#123;            nowp=mnp;            cout&lt;&lt;p[now].name&lt;&lt;&quot; used &quot;&lt;&lt;p[now].c[id].name&lt;&lt;&quot;,now p=&quot;&lt;&lt;nowp&lt;&lt;&quot;.\\n&quot;;            p[now].c[id]=t[nowpai++];p[now].op=0;        &#125;        return solve2();    &#125;    return 1;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    for(re int i=1;i&lt;=n;++i)&#123;        cin&gt;&gt;p[i].name;        cin&gt;&gt;p[i].c[1].name&gt;&gt;p[i].c[2].name&gt;&gt;p[i].c[3].name;        p[i].c[1].init();p[i].c[2].init();p[i].c[3].init();    &#125;    for(re int i=1;i&lt;=k;++i) cin&gt;&gt;t[i].name,t[i].init();    now=1;nowpai=1;    for(re int i=1;i&lt;=m;++i)&#123;        cout&lt;&lt;&quot;Round &quot;&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;&#x27;\\n&#x27;;        nowp=0;turn=1;        while(1)&#123;            if(p[now].op)&#123;if(!solve1()) break;&#125;            else&#123;if(!solve2()) break;&#125;        &#125;    &#125;    return 0;&#125;\n「Wdoi-3」夜雀 singing 做这题时 PTSD 了。\n可以想到，先处理出每个人能走到的最左侧点和最右侧点，显然我们只需要考虑那些走不到合法点的区间。\n那么此时转化成了最少点覆盖区间问题，也就是我调了三个小时的 CSP-S 2024 T2。\n现在的问题是如何处理这个区间。\n暴力处理是 O(nm) 的，但是这里有很多重叠信息可以利用。\n下面只考虑右端点怎么求，左端点同理。\n我们把人的位置排序，从左向右考虑。\n如果之前的人能走到的最远位置小于等于当前位置，那么让这个人暴力向右拓展。\n否则，我们从之前的人能走到的最远位置开始暴力向右拓展。\n每个位置最多被拓展一遍，所以复杂度是 O(n+m) 的。\n这个单调性还是挺好理解的吧，而且感觉这东西和 manacher 挺像的？\n希望 NOIP 别再爆了。\n别再爆了别再爆了别再爆了别再爆了别再爆了别再爆了。\n「Wdoi-4」芙兰？姆Q！贤者与谜题读完题以后第一想法是暴力建图然后变成 Minimal Labels  。\n然而暴力建图会有 O(nq) 条边，所以死掉了。\n所以考虑优化建图。\n容易发现，我们会建一堆重边，只要能去掉这些重边，边数就会变成 O(n) 级别。\n考虑使用并查集，连边时把父亲也更新。\n因为需要正着连和反着连，所以需要两个并查集。\n然后没了。\n「Wdcfr-1」CONsecutive and CONcat (easy version)小清新计数题。\n但是非常容易算重。\n把贡献分为两部分：自己产生的和若干串拼接产生的。\n自己内部的贡献很好算，不再赘述。\n在弱化版中，保证了一个串内至少包含两种不同的字母符，所以若干串拼接一定是两个串拼接。\n设前一个串的后缀长度为 suf，后一个串的前缀长度为 pre。\n直接算会算重：当 k \\le suf 或 k \\le pre 时，会有一些部分在同一个字符串中，但这部分贡献已经被计算过了。\n\n这是前后两个串的后缀和前缀。\n第一种情况：k > suf,k > pre\n\n那么此时的合法位置数为 (suf+pre-k+1)-1+1。\n第二种情况：k \\le suf 或 k \\le pre\n\n那么此时的合法位置数为 suf-((suf+1)-k+1)+1。\n综上，合法方案数应为 \\min(suf+pre-k+1,suf)-\\max(suf-k+2,1)+1。\n因为会贡献到 (n-1)! 种排列中（捆绑法），所以还要乘上 (n-1)!。\n实现时，我们不能 O(n^2) 的枚举字符串，但 m \\le 100，所以可以枚举前后缀长度。\n但枚举前后缀长度时，如果一个字符串的前缀和后缀都是一个字符，可能会把它自己和自己拼接的贡献也算上，应该去掉。\n这是一份 O(n^2) 枚举字符串的代码：\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define pii pair&lt;int,int&gt;#define fi first#define se secondusing namespace std;const int maxn=1e6+10,maxv=30,mod=998244353;int n,m,k,ans;int fac[maxn];string s;vector&lt;pii&gt; g1[maxv],g2[maxv];inline void init()&#123;    fac[0]=1;    for(re int i=1;i&lt;=n;++i) fac[i]=fac[i-1]*i%mod;&#125;inline void solve(int id)&#123;    int pre=1;char c1=s[0];    for(re int i=1;i&lt;m;++i)&#123;        if(s[i]!=c1) break;        else ++pre;    &#125;    g1[c1-&#x27;a&#x27;].push_back(&#123;id,pre&#125;);    int suf=1;char c2=s[m-1];    for(re int i=m-2;i&gt;=0;--i)&#123;        if(s[i]!=c2) break;        else ++suf;    &#125;    g2[c2-&#x27;a&#x27;].push_back(&#123;id,suf&#125;);    int len=0;char lst=0;    for(re int i=0;i&lt;m;++i)&#123;        if(s[i]!=lst)&#123;            if(len&gt;=k) ans=(ans+(len-k+1)*fac[n]%mod)%mod;            lst=s[i],len=1;        &#125;        else ++len;    &#125;    if(len&gt;=k) ans=(ans+(len-k+1)*fac[n]%mod)%mod;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;init();    for(re int i=1;i&lt;=n;++i)&#123;        cin&gt;&gt;s;        solve(i);    &#125;    for(re int i=0;i&lt;26;++i)&#123;        for(auto x:g2[i])&#123;            for(auto y:g1[i])&#123;                if(x.fi==y.fi) continue;                int suf=x.se,pre=y.se;                if(suf+pre&gt;=k) ans=(ans+(min(suf+pre-k+1,suf)-max(suf-k+2,1ll)+1)*fac[n-1]%mod)%mod;            &#125;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n这是一份 O(m^2) 枚举前后缀长度的代码：\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define pii pair&lt;int,int&gt;#define fi first#define se secondusing namespace std;const int maxn=1e6+10,maxm=110,maxv=30,mod=998244353;int n,m,k,ans;int fac[maxn];int pre1[maxm][maxv],suf1[maxm][maxv];int a[maxm][maxm][maxv];string s;inline void init()&#123;    fac[0]=1;    for(re int i=1;i&lt;=n;++i) fac[i]=fac[i-1]*i%mod;&#125;inline void solve(int id)&#123;    int pre=1;char c1=s[0];    for(re int i=1;i&lt;m;++i)&#123;        if(s[i]!=c1) break;        else ++pre;    &#125;    ++pre1[pre][c1-&#x27;a&#x27;];    int suf=1;char c2=s[m-1];    for(re int i=m-2;i&gt;=0;--i)&#123;        if(s[i]!=c2) break;        else ++suf;    &#125;    ++suf1[suf][c2-&#x27;a&#x27;];    if(c1==c2) ++a[pre][suf][c1-&#x27;a&#x27;];    int len=0;char lst=0;    for(re int i=0;i&lt;m;++i)&#123;        if(s[i]!=lst)&#123;            if(len&gt;=k) ans=(ans+(len-k+1)*fac[n]%mod)%mod;            lst=s[i],len=1;        &#125;        else ++len;    &#125;    if(len&gt;=k) ans=(ans+(len-k+1)*fac[n]%mod)%mod;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;init();    for(re int i=1;i&lt;=n;++i)&#123;        cin&gt;&gt;s;        solve(i);    &#125;    for(re int i=0;i&lt;26;++i)&#123;        for(re int pre=1;pre&lt;=m;++pre)&#123;            for(re int suf=max(k-pre,1ll);suf&lt;=m;++suf)&#123;                ans=(ans+(pre1[pre][i]*suf1[suf][i]-a[pre][suf][i])%mod*(min(suf+pre-k+1,suf)-max(suf-k+2,1ll)+1)%mod*fac[n-1]%mod)%mod;            &#125;        &#125;    &#125;    cout&lt;&lt;ans;    return 0;&#125;\n「Wdcfr-1」CONsecutive and CONcat (hard version) 上一题的加强版。\n现在可能出现这种东西：一个只由一种字符构成的字符串。\n那么贡献要分为五种情况：\n\n单个串自己的贡献\n若干只由一种字符构成的字符串拼接\n一段后缀+若干只由一种字符构成的字符串\n若干只由一种字符构成的字符串+一段前缀\n一段后缀+若干只由一种字符构成的字符串+一段前缀\n\n设 f_{pre,num,suf} 表示前缀长度为 pre，中间有 num 个只由一种字符构成的字符串，后缀长度为 suf 的贡献。\n那要怎么去重呢？\n我不会啊？题解说的是啥？这是正常思路吗？难道正常思路不是钦定在某个地方算贡献吗？\n等我以后再补。\nupd：感谢 born_to_sun 的厉害思路。\n具体请看洛谷题解，不在这里写了。\nupd：原来 zak 也是这么写的。\n「Wdsr-3」永远与须臾的走廊怎么又是数数。\n哦原来是性质题，竟然被我秒了。\n通过手玩样例，可以发现：只要填出来的括号序列的任意一个循环同构是合法括号序列，那么这种方案就合法。\n为什么？\n这很好理解，因为我们要往后无限拼接，那么只要这个括号序列的任意一个循环同构是合法括号序列，那么就一定能拼出来合法的括号序列。\n那么怎么判断这个括号序列的任意一个循环同构是合法括号序列呢？\n可以发现：一个括号序列的任意一个循环同构是合法括号序列当且仅当它的左右括号数相等。\n做完了。\n [Cnoi2021] 数学练习 简单数数题。\n对于 S 大小为 i，T 大小为 n-i 时，i 和 n-i 要放的位置已经固定，只剩下 n-2 个数可以随便放。\n那么此时的方案数为 \\binom {n-2}{i-1}。\n需要特判 n 为偶数，因为此时 \\frac {n}{2} 没地方放。\n [Cnoi2021] 矩阵简单式子题。\n通过手推样例的 k=1,2,3，可以发现，答案为\n\n(\\sum_{i=1}^n a_i)\\times (\\sum_{i=1}^n b_i)\\times (\\sum_{i=1}^n a_ib_i)^{k-1}需要特判 k=0。\n还有注意取模，一定别取模少了（本来能一遍过就因为取模取少了）。\n是不是写的太简短了？那我在这里推一下 k=3 吧。\n\n\\begin{align*}\nans &= \\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n A'_{i,k}\\times A_{k,j}\n\\\\\n&=\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n (\\sum_{p=1}^n A_{i,p}\\times A_{p,k}) \\times A_{k,j}\n\\\\\n&=\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{k=1}^n (\\sum_{p=1}^n a_i\\times b_p\\times a_p\\times b_k) \\times a_k\\times b_j\n\\\\\n&=\\sum_{i=1}^n a_i\\sum_{j=1}^n b_j\\sum_{k=1}^n a_k\\times b_k\\sum_{p=1}^na_p\\times b_p\n\\\\\n&=(\\sum_{i=1}^n a_i)\\times (\\sum_{i=1}^n b_i)\\times (\\sum_{i=1}^n a_ib_i)^2\n\\end{align*}「Wdoi-5」模块化核熔炉抽象坐标系。\n如果是普通的矩形加，那树套树可以轻松解决。\n但是这正六边形非常恶心啊，感觉根本做不了。\n所以把坐标系变换一下，变成直角坐标系就能做了。\n具体怎么变还是请参考题解吧，感觉有点抽象。\n射命丸文的取材之旅枚举区间显然不可做。\n但值域是 O(n) 的，所以可以枚举 \\operatorname{mex}。\n那么对于每个 \\operatorname{mex}，我们找出它所在的最长区间即可。\n假设我们的 c 已经选好了，那么我们只需要把每个位置挂到值上，然后暴力找即可。\n但现在我们需要决策一下 a,b。事实上这让我们的选择更加宽松了。\n因为只有当 a_i=b_i=\\operatorname{mex} 时，我们才把这个位置挂到这个 \\operatorname{mex} 上。\n每个位置只会遍历一次，复杂度 O(n)。\n虹色的北斗七星感觉在 CF 上见到过一车这种题？\n如果这里的 -len 是 +len，那么非常好做，因为这东西是有单调性的，直接枚举左端点然后二分右端点即可。\n但这里不是，所以还把 r-l+1 看成 len 这个整体会很难做。\n如果仔细思考会发现一个性质：最优区间的左右端点一定对应着 \\max 和 \\min。\n证明很容易：在不改变 \\max 和 \\min 的情况下扩大区间只能让收益减少。\n所以，此时的 l,r 一定对应着 \\max,\\min 的下标。\n分类讨论一下：\n\nl 对应 \\max，r 对应 \\min。\n\n式子变为 (\\max+l)-(\\min+r)-1。\n设 b_i=a_i+i，那么要找的就是 \\max_{i\\le j} b_i-b_j-1。\n扫的过程中维护前缀最大即可。\n\nr 对应 \\max，l 对应 \\min。\n\n式子变为 (\\max-r)-(\\min-l)-1。\n设 b_i=a_i-i，那么要找的就是 \\max_{i\\ge j} b_i-b_j-1。\n扫的过程中维护前缀最小即可。\n复杂度 O(n)\n [Aya Round 1 H] 破碎的历史看到撤回还以为是操作树，结果是撤销单次操作。\n仔细思考这个染色，可以发现：每次加进来的若干线段，只有那条最长的两端点均为黑点的线段是有用的。\n那么要怎么维护是否合法？\n我一开始想的是区间推平维护区间和，但是这东西完全没法撤销单次操作，如果是回到某个状态倒是能做，离线操作树+ [COCI2015-2016#3] NEKAMELEONI 即可。\n那换个思路：非得维护区间和吗？\n可以发现，如果一个点没被染过，那么它一定是 0。\n所以维护最小值即可。\n操作只需要普通的区间加，这东西显然可以撤销。\n撤销单次操作加强版：方方方的数据结构 \n注意：区间加操作可能不合法，需要特判。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define ls(p) tr[p].ls#define rs(p) tr[p].rsusing namespace std;const int maxn=5e5+10,inf=1e18;int n,m,rt,segcnt;int a[maxn],b[maxn],pos[maxn];struct tree&#123;    int ls,rs,tag,mn;&#125;tr[maxn&lt;&lt;1];struct Query&#123;    int l,r;&#125;q[maxn];inline void up(int p)&#123;tr[p].mn=min(tr[ls(p)].mn,tr[rs(p)].mn);&#125;inline void add(int l,int r,int val,int p)&#123;    tr[p].mn+=val;    tr[p].tag+=val;&#125;inline void down(int l,int r,int mid,int p)&#123;    if(tr[p].tag)&#123;        add(l,mid,tr[p].tag,ls(p));        add(mid+1,r,tr[p].tag,rs(p));        tr[p].tag=0;    &#125;&#125;inline void build(int l,int r,int &amp;p)&#123;    p=++segcnt;    if(l==r)&#123;tr[p].mn=a[l];return;&#125;    int mid=(l+r)&gt;&gt;1;    build(l,mid,ls(p)),build(mid+1,r,rs(p));    up(p);&#125;inline void update(int l,int r,int L,int R,int val,int p)&#123;    if(L&gt;R||L&lt;=0||R&gt;=n+1) return;    if(l&gt;=L&amp;&amp;r&lt;=R)&#123;add(l,r,val,p);return;&#125;    int mid=(l+r)&gt;&gt;1;    down(l,r,mid,p);    if(L&lt;=mid) update(l,mid,L,R,val,ls(p));    if(R&gt;mid) update(mid+1,r,L,R,val,rs(p));    up(p);&#125;inline int query(int l,int r,int L,int R,int p)&#123;    if(l&gt;=L&amp;&amp;r&lt;=R) return tr[p].mn;    int mid=(l+r)&gt;&gt;1,res=inf;    down(l,r,mid,p);    if(L&lt;=mid) res=min(res,query(l,mid,L,R,ls(p)));    if(R&gt;mid) res=min(res,query(mid+1,r,L,R,rs(p)));    return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;pos[i];    int len=0;    for(re int i=1;i&lt;=n;++i)&#123;        cin&gt;&gt;a[i];        if(a[i]) b[++len]=i;    &#125;    build(1,n,rt);    if(query(1,n,1,n,1)==0) cout&lt;&lt;&quot;No\\n&quot;;    else cout&lt;&lt;&quot;Yes\\n&quot;;    for(re int i=1,op,l,r,x;i&lt;=m;++i)&#123;        cin&gt;&gt;op;        if(op==1)&#123;            cin&gt;&gt;l&gt;&gt;r;            l=lower_bound(pos+1,pos+n+1,l)-pos,r=upper_bound(pos+1,pos+n+1,r)-pos-1;            l=b[lower_bound(b+1,b+len+1,l)-b],r=b[upper_bound(b+1,b+len+1,r)-b-1];            update(1,n,l,r,1,1);        &#125;        else&#123;            cin&gt;&gt;x;            update(1,n,q[x].l,q[x].r,-1,1);        &#125;        q[i]=&#123;l,r&#125;;        if(query(1,n,1,n,1)==0) cout&lt;&lt;&quot;No\\n&quot;;        else cout&lt;&lt;&quot;Yes\\n&quot;;    &#125;    return 0;&#125;\n「Wdoi-2」来自地上的支援我是数据结构低手/kk。\n遇到这种玩游戏题一般都要观察性质，否则按题意模拟复杂度肯定寄。\n首先分析这个操作。\n显然第三条规则是没用的，因为这种情况根本不可能出现。\n然后可以发现一些性质：\n\n被选到的数的操作时刻一定是一段连续区间。\n如果一个数在第一次出现时没有被选上，那么它一定再也不会被选。\n\n那么询问就很清楚了。\n设 c_i 表示第 i 次操作后的 \\max_{j=1}^i b_j。\n第 x 个数要想被选至少 k 次，需要满足以下要求：\n1.a_x \\ge c_{x-1}\n2.a_x > \\max_{i=x+1}^{x+k-1} a_i-(i-x)\\times v \n第一个要求保证第 x 个数第一次出现时就能被选上。\n第二个要求保证第 x 个数能被连续选 k 次。\n第一个要求很好处理，重点是第二个要求。\n这个要求事实上就是这个问题：\n\n给定公差 d，每次询问为区间加公差为 d 的等差数列后的区间最大值。询问互相独立。\n\n第一眼以为很不可做，但关键在公差不变上。\n我们令 a_i\\leftarrow a_i+i\\times d，那么我们每次直接查区间最大值，查到的位置就是对的。\n注意是位置，不是值。具体的值需要我们根据公差算一下才能得到。\n把 d 换成 -v 就是这道题了。\n实现时，我使用了 ST 表，空间复杂度 O(n\\log n)，无法通过。换成线段树就行了。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=2e6+10;int n,m,v;int a[maxn],b[maxn],c[maxn];int st[22][maxn],id[22][maxn];inline void pre()&#123;    for(re int i=1;i&lt;=n;++i) b[i]=a[i];    int mx=0,id=0;    for(re int i=1;i&lt;=n;++i)&#123;        if(b[i]&gt;=mx) id=i;b[id]+=v;        c[i]=mx=b[id];    &#125;&#125;inline void init()&#123;    for(re int i=1;i&lt;=n;++i) st[0][i]=a[i]-i*v,id[0][i]=i;    for(re int j=1;j&lt;=21;++j)&#123;        for(re int i=1;i&lt;=n-(1&lt;&lt;j)+1;++i)&#123;            if(st[j-1][i]&gt;st[j-1][i+(1&lt;&lt;(j-1))]) st[j][i]=st[j-1][i],id[j][i]=id[j-1][i];            else st[j][i]=st[j-1][i+(1&lt;&lt;(j-1))],id[j][i]=id[j-1][i+(1&lt;&lt;(j-1))];        &#125;    &#125;&#125;inline int query(int l,int r)&#123;    if(l&gt;r) return 0;    int k=__lg(r-l+1),pos=0;    if(st[k][l]&gt;st[k][r-(1&lt;&lt;k)+1]) pos=id[k][l];    else pos=id[k][r-(1&lt;&lt;k)+1];    return a[pos]-(pos-l+1)*v+1;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;v;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];    pre();init();    int ans1=0,ans2=0;    for(re int i=1,x,k,res;i&lt;=m;++i)&#123;        cin&gt;&gt;x&gt;&gt;k;        if(x+k-1&gt;n) continue;        res=max(c[x-1],query(x+1,x+k-1));        ans1^=res,ans2+=res;    &#125;    cout&lt;&lt;ans1&lt;&lt;&quot; &quot;&lt;&lt;ans2;    return 0;&#125;\nThe Enchanted Forest如果 k \\le n，那么一定是选和最大的一个长度为 k 的子区间。\n还需要考虑新长出来的部分，这部分是固定的，为 \\frac {k\\times (k-1)}{2}。\n如果 k > n，感性理解一下，可以发现：我们一定会把原来的都拿完，然后来回扫荡。\n对于新长出来的那部分，因为我们要从一端走到另一端，所以会少拿 \\frac {n\\times (n+1)}{2}。\n一共长出来了 nk 个，所以这部分贡献为 nk-\\frac {n\\times (n+1)}{2}。\n感觉说的非常不清楚啊，但我只会感性理解不会证明···\nDoremy’s IQ比上题简单。\n正着似乎不太好考虑，所以我们倒着考虑。\n通过观察样例可以发现，选一段极长后缀一定是一组合法解，这也启示我们倒着考虑。\n所以我们倒着扫一遍，能选就选，选不了就停。\n然后别忘了前缀里还有一些 \\le q 的是白送的，也要选上。\n那么这为什么是对的呢？\n我们正着来看上述操作，可以发现：我们优先让后面的扣，前面的能不扣就不扣。\n感性理解一下，前面的越早扣，后面选择的余地就越小，所以能晚扣就晚扣。\n然而在做题时我根本没证明，大概想了一下感觉对就做完了，不太会严谨证贪心啊。\nKoishi Loves Segments简单贪心。\n做的时候睡着了，梦里会了。\n直接贪就完事了，优先放长度短的，能放就放。\n拿线段树模拟这个东西就行。\n然后写代码的时候唐完了，离散化后点数为 cnt，我写个 n 调半天没调出来，鉴定为睡晕了。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define ls(p) tr[p].ls#define rs(p) tr[p].rsusing namespace std;const int maxn=4e5+10,maxm=2e5+10,inf=1e18;int n,m,rt,segcnt,ans;int a[maxn],tmp[maxn];struct node&#123;    int pos,x;&#125;t[maxn];struct line&#123;    int l,r;    inline bool operator &lt; (const line &amp;a)const&#123;        if(l==a.l) return r&lt;a.r;        return l&gt;a.l;    &#125;&#125;lin[maxm];struct tree&#123;    int ls,rs,mn,tag;&#125;tr[maxn&lt;&lt;1];inline void up(int p)&#123;tr[p].mn=min(tr[ls(p)].mn,tr[rs(p)].mn);&#125;inline void add(int p,int val)&#123;    tr[p].mn+=val;    tr[p].tag+=val;&#125;inline void down(int p)&#123;if(tr[p].tag) add(ls(p),tr[p].tag),add(rs(p),tr[p].tag);tr[p].tag=0;&#125;inline void build(int l,int r,int &amp;p)&#123;    p=++segcnt;    if(l==r)&#123;tr[p].mn=a[l];return;&#125;    int mid=(l+r)&gt;&gt;1;    build(l,mid,ls(p)),build(mid+1,r,rs(p));    up(p);&#125;inline void update(int l,int r,int L,int R,int val,int p)&#123;    if(l&gt;=L&amp;&amp;r&lt;=R)&#123;add(p,val);return;&#125;    int mid=(l+r)&gt;&gt;1;    down(p);    if(L&lt;=mid) update(l,mid,L,R,val,ls(p));    if(R&gt;mid) update(mid+1,r,L,R,val,rs(p));    up(p);&#125;inline int query(int l,int r,int L,int R,int p)&#123;    if(l&gt;=L&amp;&amp;r&lt;=R) return tr[p].mn;    int mid=(l+r)&gt;&gt;1,res=inf;    down(p);    if(L&lt;=mid) res=min(res,query(l,mid,L,R,ls(p)));    if(R&gt;mid) res=min(res,query(mid+1,r,L,R,rs(p)));    return res;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;m&gt;&gt;n;    for(re int i=1;i&lt;=m;++i) cin&gt;&gt;lin[i].l&gt;&gt;lin[i].r;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;t[i].pos&gt;&gt;t[i].x,tmp[i]=t[i].pos;    sort(tmp+1,tmp+n+1);    int cnt=unique(tmp+1,tmp+n+1)-(tmp+1);    memset(a,0x3f,sizeof a);    for(re int i=1;i&lt;=n;++i)&#123;        t[i].pos=lower_bound(tmp+1,tmp+cnt+1,t[i].pos)-tmp;        a[t[i].pos]=min(a[t[i].pos],t[i].x);    &#125;    for(re int i=1;i&lt;=m;++i)&#123;        lin[i].l=lower_bound(tmp+1,tmp+cnt+1,lin[i].l)-tmp;        lin[i].r=upper_bound(tmp+1,tmp+cnt+1,lin[i].r)-tmp-1;    &#125;    sort(lin+1,lin+m+1);    build(1,cnt,rt);    for(re int i=1;i&lt;=m;++i) if(query(1,cnt,lin[i].l,lin[i].r,1)&gt;0) update(1,cnt,lin[i].l,lin[i].r,-1,1),++ans;    cout&lt;&lt;ans;    return 0;&#125;\nkoishi的数学题结论：a \\mod b=a-\\lfloor \\frac{a}{b} \\rfloor \\times b。\n推荐去做[清华集训2012] 模积和，加深一下印象。\n第一眼以为模板整除分块，结果数据范围 n \\le 10^6。\n我们思考一下 x 和 x+1 的增量是什么。\n可以发现，当 i 为 x+1 的约数时，\\lfloor \\frac{x+1}{i} \\rfloor 会比 \\lfloor \\frac{x}{i}\\rfloor 大 1。\n因为还带了个 \\times i，所以答案的增量就是 x+1 的约数和。\n这东西显然可以线性筛，然后做完了。\n注意：我们求的是增量，所以还得求个前缀和。\n不是哥们，怎么随便一交就最优解了？\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e6+10;int n,cnt;int pri[maxn],d[maxn];bitset&lt;maxn&gt; vis;inline void sieve()&#123;    d[1]=1;    for(re int i=2;i&lt;=n;++i)&#123;        if(!vis[i]) pri[++cnt]=i,d[i]=i+1;        for(re int j=1;j&lt;=cnt&amp;&amp;i*pri[j]&lt;=n;++j)&#123;            vis[i*pri[j]]=1;            if(i%pri[j]==0)&#123;d[i*pri[j]]=(d[i]-d[i/pri[j]])*pri[j]+d[i];break;&#125;            else d[i*pri[j]]=d[i]*d[pri[j]];        &#125;    &#125;    for(re int i=2;i&lt;=n;++i) d[i]+=d[i-1];&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n;    sieve();    for(re int i=1;i&lt;=n;++i) cout&lt;&lt;n*i-d[i]&lt;&lt;&quot; &quot;;    return 0;&#125;\n萃香抱西瓜读完题就想到了这道题：HDU 7446 梦中的地牢战斗。\n看到这数据范围应该能直接想到暴力状压吧。\n设 f_{x,y,T,S} 表示当前在 (x,y)，时间为 T，拿到的西瓜状态为 S 的最少次数。\n转移就是从不走或者走一步转移来。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=6,maxt=110,maxm=(1&lt;&lt;10)+10,inf=1e18;int h,w,T,sx,sy,n,m,sum,S,ans;int mp[maxn][maxn][maxt];int f[maxn][maxn][maxt][maxm];int dx[5]=&#123;0,0,1,-1&#125;;int dy[5]=&#123;1,-1,0,0&#125;;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;h&gt;&gt;w&gt;&gt;T&gt;&gt;sx&gt;&gt;sy&gt;&gt;n&gt;&gt;m;S=(1&lt;&lt;m)-1;    for(re int i=1,t1,t2,op;i&lt;=n;++i)&#123;        cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;op;        sum+=op;        for(re int t=t1,x,y;t&lt;t2;++t)&#123;            cin&gt;&gt;x&gt;&gt;y;            if(!op) mp[x][y][t]=-1;            else mp[x][y][t]=1&lt;&lt;(sum-1);        &#125;    &#125;    if(mp[sx][sy][1]==-1)&#123;cout&lt;&lt;-1;return 0;&#125;    memset(f,0x3f,sizeof f);    f[sx][sy][1][mp[sx][sy][1]]=0;    for(re int t=2;t&lt;=T;++t)&#123;        for(re int x=1;x&lt;=w;++x)&#123;            for(re int y=1;y&lt;=h;++y)&#123;                if(mp[x][y][t]==-1) continue;                if(mp[x][y][t-1]!=-1) for(re int s=0;s&lt;=S;++s) f[x][y][t][s|mp[x][y][t]]=min(f[x][y][t][s|mp[x][y][t]],f[x][y][t-1][s]);                for(re int i=0;i&lt;4;++i)&#123;                    int prex=x+dx[i],prey=y+dy[i];                    if(prex&lt;1||prex&gt;w||prey&lt;1||prey&gt;h) continue;                    if(mp[prex][prey][t-1]==-1) continue;                    for(re int s=0;s&lt;=S;++s) f[x][y][t][s|mp[x][y][t]]=min(f[x][y][t][s|mp[x][y][t]],f[prex][prey][t-1][s]+1);                &#125;            &#125;        &#125;    &#125;    ans=inf;    for(re int x=1;x&lt;=w;++x)&#123;        for(re int y=1;y&lt;=h;++y)&#123;            ans=min(ans,f[x][y][T][S]);        &#125;    &#125;    cout&lt;&lt;(ans==inf?-1:ans);    return 0;&#125;\n冰精冻西瓜这种题我竟然想了大于 0.5 h，还是水平太低了。\n先考虑序列怎么做。\n设 pre_u 为前缀积。\n对于一次修改中所有会受影响的点 v，它会加上 \\frac {pre_v}{pre_u}\\times w。\n所以一个点的点权为 val_v=\\sum_{i=1}^m \\frac {pre_v}{pre_{u_i}}\\times w_i。\n把 pre_v 提出来，得到 val_v=pre_v\\times \\sum_{i=1}^m \\frac {w_i}{pre_{u_i}}。\n对于每次修改，后面那个东西都是确定的，所以修改就是区间加。\n但是有个问题：有 0 怎么办？\n显然 0 的出现会让上面的操作出错。\n但可以发现：如果有 0，那么这前后两段是完全独立的（即对前面段的操作不会影响到后面段，反之同理）。\n所以以 0 为断点，把序列分成若干连续段，那么每个连续段是独立的。\n对每个连续段分别做上面的东西即可。\n然后上树是简单的，这题是子树加单点查，甚至不需要树剖。\n根据 0 把原树拆成森林，然后对每部分分别做即可。\n代码感觉非常好写，最大难点可能是精度问题？\n妖梦斩木棒一个比较麻烦的做法。\n首先可以想到线段树，然后考虑怎么合并信息。\n我们对每个节点维护：左/右侧 X 极长连续段长度，左侧第一个 ‘)’ 的位置，右侧第一个 ‘(‘ 的位置，该区间左右端点，该区间答案。\n两个区间合并能产生新答案，当且仅当：左区间的右端点-右侧 X 极长连续段长度=右侧第一个 ‘(‘ 的位置且右区间的左端点+左侧 X 极长连续段长度=左侧第一个 ‘)’ 的位置。\n事实上我写麻烦了，只需要对每个点维护左/右侧第一个 ‘)’ 的位置以及左/右侧第一个 ‘(‘ 的位置即可。\n大家可以思考一下怎么做。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define ls(p) tr[p].ls#define rs(p) tr[p].rsusing namespace std;const int maxn=2e5+10,inf=1e18;int n,m,rt,segcnt;struct data&#123;    int ans;    int l,r;    int lpos,rpos;    int len1,len2;    inline data()&#123;ans=len1=len2=0,lpos=inf,rpos=-inf;&#125;    inline void init(int val)&#123;        if(val==-1) rpos=l,lpos=inf,len1=len2=ans=0;        if(val==0) len1=len2=1,lpos=inf,rpos=-inf,ans=0;        if(val==1) lpos=l,rpos=-inf,len1=len2=ans=0;    &#125;    inline data operator + (const data &amp;a)const&#123;        data res;        res.l=l,res.r=a.r;        res.ans=ans+a.ans;        res.lpos=min(lpos,a.lpos);        res.rpos=max(rpos,a.rpos);        if(len1==r-l+1) res.len1=len1+a.len1;        else res.len1=len1;        if(a.len2==a.r-a.l+1) res.len2=len2+a.len2;        else res.len2=a.len2;        if(rpos==r-len2&amp;&amp;a.lpos==a.l+a.len1) ++res.ans;        return res;\t    &#125;&#125;;struct tree&#123;    int ls,rs;    data s;&#125;tr[maxn&lt;&lt;1];inline void up(int p)&#123;tr[p].s=tr[ls(p)].s+tr[rs(p)].s;&#125;inline void build(int l,int r,int &amp;p)&#123;    if(!p) p=++segcnt;    tr[p].s.l=l,tr[p].s.r=r;    if(l==r)&#123;        if(l==1) tr[p].s.init(-1);        else if(l==n) tr[p].s.init(1);        else tr[p].s.init(0);        return;    &#125;    int mid=(l+r)&gt;&gt;1;    build(l,mid,ls(p)),build(mid+1,r,rs(p));    up(p);&#125;inline void update(int pos,int val,int p)&#123;    if(tr[p].s.l==tr[p].s.r)&#123;tr[p].s.init(val);return;&#125;    int mid=(tr[p].s.l+tr[p].s.r)&gt;&gt;1;    if(pos&lt;=mid) update(pos,val,ls(p));    else update(pos,val,rs(p));    up(p);&#125;inline data query(int L,int R,int p)&#123;    if(tr[p].s.l&gt;=L&amp;&amp;tr[p].s.r&lt;=R) return tr[p].s;    int mid=(tr[p].s.l+tr[p].s.r)&gt;&gt;1;    //对于合并信息复杂的题，建议这么写，不然还得考虑你维护的信息的单位信息应该是什么（例如维护矩阵）    if(R&lt;=mid) return query(L,R,ls(p));    if(L&gt;mid) return query(L,R,rs(p));    return query(L,R,ls(p))+query(L,R,rs(p));&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    build(1,n,rt);char c;    for(re int i=1,op,l,r,pos;i&lt;=m;++i)&#123;        cin&gt;&gt;op;        if(op==1)&#123;            cin&gt;&gt;pos&gt;&gt;c;            if(c==&#x27;(&#x27;) update(pos,-1,1);            if(c==&#x27;X&#x27;) update(pos,0,1);            if(c==&#x27;)&#x27;) update(pos,1,1);        &#125;        else cin&gt;&gt;l&gt;&gt;r,cout&lt;&lt;query(l,r,1).ans&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\nPower收集简单单调队列。\n设 f_{i,j} 表示当前在 (i,j) 的最大价值，转移为\n\nf_{i,j}=\\max_{j-T\\le k \\le j+T} f_{i-1,k}+val_{i,j}对每个 i 都做一次单调队列即可。\n小学数学题第一遍没做出来···\n首先 n\\le 15，考虑状压，那么每次操作就是把至多 r 位取反。\n设 f_S 表示到达状态 S 的最小次数，转移为\n\nf_S=\\min f_T+1发现这个转移很像最短路，且没有转移顺序，所以考虑用最短路转移。\n暴力建图后跑最短路，复杂度为 O(2^{2n})。\n按理来说过不了，但它过了。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=(1&lt;&lt;15)+10,maxm=55,inf=1e18;int n,m1,m2,r,S,cnt;int dis[maxn],num[maxn];bitset&lt;maxn&gt; vis;vector&lt;int&gt; g;struct limit1&#123;    int a,b;&#125;t1[maxm];struct limit2&#123;    int a,b,c;&#125;t2[maxm];inline void init()&#123;    for(re int s=0;s&lt;=S;++s)&#123;        bool flag=1;        for(re int i=1;i&lt;=m1;++i)&#123;            bool a=s&amp;(1&lt;&lt;(t1[i].a-1)),b=s&amp;(1&lt;&lt;(t1[i].b-1));            if(a^b)&#123;flag=0;break;&#125;        &#125;        if(!flag) continue;        for(re int i=1;i&lt;=m2;++i)&#123;            bool a=s&amp;(1&lt;&lt;(t2[i].a-1)),b=s&amp;(1&lt;&lt;(t2[i].b-1)),c=s&amp;(1&lt;&lt;(t2[i].c-1));            if(!(b^c)&amp;&amp;(a^b))&#123;flag=0;break;&#125;        &#125;        if(flag) g.push_back(s);    &#125;&#125;inline bool check(int s,int t)&#123;    int cnt=__builtin_popcount(s^t);    return cnt&lt;=r;&#125;inline void spfa()&#123;    for(re int s=0;s&lt;=S;++s) dis[s]=inf;    queue&lt;int&gt; q;    q.push(0);vis[0]=1,dis[0]=0,num[0]=1;    while(!q.empty())&#123;        int u=q.front();q.pop();vis[u]=0;        for(auto v:g)&#123;            if(!check(u,v)) continue;            if(dis[v]&gt;=dis[u]+1)&#123;                if(dis[v]==dis[u]+1) num[v]+=num[u];                else num[v]=num[u];                dis[v]=dis[u]+1;                if(!vis[v]) q.push(v),vis[v]=1;            &#125;        &#125;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m1&gt;&gt;m2&gt;&gt;r;r=min(r,n);S=(1&lt;&lt;n)-1;    for(re int i=1;i&lt;=m1;++i) cin&gt;&gt;t1[i].a&gt;&gt;t1[i].b;    for(re int i=1;i&lt;=m2;++i) cin&gt;&gt;t2[i].a&gt;&gt;t2[i].b&gt;&gt;t2[i].c;    init();spfa();    if(dis[S]==inf) cout&lt;&lt;-1&lt;&lt;&#x27; &#x27;&lt;&lt;0;    else cout&lt;&lt;dis[S]&lt;&lt;&#x27; &#x27;&lt;&lt;num[S];    return 0;&#125;\n正解：\n考虑优化建图。\n我们把一个点拆成 r+1 个点：一个真点（记作 S_0）和 r 个假点（记作 S_k，表示还能和当前状态差 k 位）。\n我们这样建图：\n\nS_0 向 S_r 连边权为 1 的边\nS_k 向 T_{k-1} 连边权为 0 的边（1\\le k \\le r，T 为和 S 恰好差一位的状态）\nS_k 向 S_0 连边权为 0 的边（1\\le k >1}+f_{i-1,(S>>1)|(1","tags":["其他技巧"]},{"title":"概率与期望学习笔记","url":"/posts/feb14041/","content":"学一遍不会一遍，遂决定写篇博客把东西记下来。\n主要还是记录怎么做题。\n定义与性质这一部分还是详见OI Wiki吧。\n常见方法定义法对于一些题目来说，我们只需要根据期望的定义 E(X)=\\sum p_ix_i，把期望转化为求概率，再把概率转化为数数，然后再想办法怎么计数即可。\n还有一种方法就是用 \\frac {所有情况的总价值}{总情况数} 来得到期望。\n因为这种题目的难点都不在期望，只是套了个期望的壳子而已，所以我一般把这种题称作“假期望题”。\n这种题目还挺多，例如最近做的几道：\n纯粹的弹幕地狱：难点在后面的计数+莫反\n不可思议的迷宫：难点在后面的分讨\n符卡对决：难点在后面的莫队\n不过也是有一些期望题能用定义做的，不过用这个方法做起来会比较麻烦。\n但毕竟是定义，所以我一做题就会先想到这个···\n期望的线性性期望的线性性是一个非常好的性质：它让我们能够把贡献拆开分别统计，最后再合起来得到答案。\n拆贡献也是一种非常常见且重要的思想。\nDP虽然说是 DP，但也有很多种状态设计。\n例如：正推，逆推等。\n在有关概率与期望的 DP 中，可以把每个状态看成一个节点，然后把 DP 的转移看成图上走路，这样会很好理解（事实上很多 DP 都能这么考虑吧）。\n例题下面我用例题带大家感受上面的方法应该如何运用。\n绿豆蛙的归宿方法一：利用期望的线性性因为要求路径期望总长度，所以可以把路径拆成边，那么就要求每条边产生的期望贡献之和。\n一条边产生的贡献的期望，根据期望的定义，等于这条边被经过的概率乘上边权。\n所以只需要求每条边被经过的概率即可。\n这里有一个套路：算边被经过的概率转化为求点被经过的概率。\n设 f_u 表示点 u 被经过的概率，deg_u 表示点 u 的出度，若存在有向边 (u,v)，则\n\nf_v=\\sum \\frac {f_u}{deg_u}那么边 (u,v) 被经过的概率为 \\frac {f_u}{deg_u}。\n答案就是把每条边的贡献的期望值加起来。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long #define double long doubleusing namespace std;const int maxn=1e5+10,maxm=2e5+10;int n,m,cnt;int head[maxn],in[maxn],deg[maxn];double ans,f[maxn];struct edge&#123;    int to,nxt,w;&#125;e[maxm];inline void add(int u,int v,int w)&#123;    ++in[v],++deg[u];    e[++cnt]=&#123;v,head[u],w&#125;;    head[u]=cnt;&#125;inline void topo()&#123;    queue&lt;int&gt; q;    for(re int u=1;u&lt;=n;++u) if(!in[u]) q.push(u);    while(!q.empty())&#123;        int u=q.front();q.pop();        for(re int i=head[u];i;i=e[i].nxt)&#123;            int v=e[i].to;            if(!(--in[v])) q.push(v);            f[v]+=f[u]/deg[u];            ans+=f[u]/deg[u]*e[i].w;        &#125;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1,u,v,w;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v&gt;&gt;w,add(u,v,w);    f[1]=1;topo();    printf(&quot;%.2Lf&quot;,ans);    return 0;&#125;\n方法二：DP正推和逆推都是可以的，这里讲逆推。\n设 f_u 表示从 u 到 n 的路径期望总长度，若存在有向边 (u,v)，则转移为\n\nf_u=\\frac {1}{deg_u}\\sum f_v+w_{u,v}因为转移是 v 向 u 贡献，所以要建反图，然后在反图的拓扑序上 DP。\n初值为 f_n=0，答案为 f_1。\n注意：因为建了反图，所以转移里的 u,v 也变了。请仔细理解。\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long #define double long doubleusing namespace std;const int maxn=1e5+10,maxm=2e5+10;int n,m,cnt;int head[maxn],in[maxn],deg[maxn];double f[maxn];struct edge&#123;    int to,nxt,w;&#125;e[maxm];inline void add(int u,int v,int w)&#123;    ++in[v],++deg[v];    e[++cnt]=&#123;v,head[u],w&#125;;    head[u]=cnt;&#125;inline void topo()&#123;    queue&lt;int&gt; q;    for(re int u=1;u&lt;=n;++u) if(!in[u]) q.push(u);    while(!q.empty())&#123;        int u=q.front();q.pop();        for(re int i=head[u];i;i=e[i].nxt)&#123;            int v=e[i].to;            if(!(--in[v])) q.push(v);            f[v]+=1.0*(f[u]+e[i].w)/deg[v];        &#125;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1,u,v,w;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v&gt;&gt;w,add(v,u,w);    topo();    printf(&quot;%.2Lf&quot;,f[1]);    return 0;&#125;\nBeautiful Mirrors利用这道题介绍期望 DP 的各种 trick。\n以下的 p_i 为题目中的 \\frac {p_i}{100}。\n方法一：正推设 f_i 表示从第一面镜子到第 i 面镜子都高兴的期望天数。\n那么在第 i 天，有以下两种可能：\n\n询问失败，概率为 1-p_i。代价为 f_{i-1}+1+f_i。\n询问成功，概率为 p_i。代价为 f_{i-1}。\n\n根据期望的定义，概率乘代价再求和就是期望。则\n\nf_i=(1-p_i)(f_{i-1}+1+f_i)+p_i(f_{i-1}+1)移项，整理得\n\nf_i=p_i(f_{i-1}+1)初值为 f_0=0，答案为 f_n。\n可能有疑问：为什么询问失败的代价为 f_{i-1}+1+f_i？\n可以把代价拆开来看。\n首先，我们已经到了第 i 面镜子，说明前 i-1 面都没失败，这部分的代价为 f_{i-1}。\n然后，我们在第 i 面镜子处进行询问，会花费一天，这部分的代价为 1。\n最后，因为询问失败，我们回到了第一面镜子。但我们的状态为从第一面镜子到第 i 面镜子都高兴，所以我们还得从第一面镜子一直问到第 i 面镜子且保持高兴。这部分的代价为 f_i。\n方法二：逆推设 f_i 表示从第 i 面镜子到最后一面镜子的期望天数。\n那么在第 i 天，有以下两种可能：\n\n询问失败，概率为 1-p_i，我们会回到第一面镜子，代价为 f_1+1。\n询问成功，概率为 p_i，我们会走到下一面镜子，代价为 f_{i+1}+1。\n\n根据期望的定义，概率乘代价再求和就是期望。则\n\nf_i=(1-p_i)(f_1+1)+p_i(f_{i+1}+1)初值为 f_{n+1}=0，答案为 f_1。\n要求 f_1，但是转移用到了 f_1，考虑解方程。\n如果你把前几项写出来，会发现：\n当 i=1 时，f_1=f_2+\\frac {1}{p_1}。\n当 i=2 时，f_1=f_3+\\frac {1+\\frac {1}{p_1}}{p_2}。\n当 i=3 时，f_1=f_4+\\frac {1+\\frac {1+\\frac {1}{p_1}}{p_2}}{p_3}。\n所以：\n\nf_1=\\frac {1+\\frac {1+\\frac {\\cdots}{p_{n-2}}}{p_{n-1}}}{p_n}整理得：\n\nf_1=\\frac {1+p_1+p_1p_2+\\cdots+p_1p_2\\cdots p_{n-1}}{\\prod_{i=1}^np_i}方法三：一种常见的状态设计但是我不知道怎么称呼设 f_i 表示从第 i 面镜子到第 i+1 面镜子的期望天数。\n设 s=\\sum_{j=1}^{i-1} f_j，则\n\nf_i=p_i\\times 1+(1-p_i)\\times (1+f_i+s)关于代价为什么是这个，可以参考正推。\n移项，整理得：\n\nf_i=\\frac {1+(1-p_i)\\times s}{p_i}答案为 \\sum_{i=1}^n f_i。\n方法四：设一次函数还是逆推的 DP。\n设 f_i=k_i\\times f_1+b_i，通过递推求出 k_{n+1},b_{n+1}，最后解方程 k_{n+1}\\times f_1+b_{n+1}=0 即可。\n[六省联考 2017] 分手是祝愿一道经典好题。\n利用这道题补充期望 DP 的各种 trick。\n首先考虑最优操作应该怎么按。\n感性理解一下，可以发现：每次按最右边的是最优的。因为除它以外没有数的约数包含它，所以它必须得按。\n事实上，这也是唯一的一种按法。证明参考题解。\n考虑 DP。\n设 f_i 表示当前还剩 i 个键要按的期望操作次数，则转移为：\n\nf_i = \\begin{cases} i & (i \\le k) \\\\ \\frac {i}{n} f_{i-1}+\\frac {n-i}{n}f_{i+1}+1 & (i >k) \\end{cases}这应该挺好理解的吧，不再赘述了。\n但是这东西没法转移啊，只能高斯消元解方程，怎么办？\n方法一：模拟高斯消元事实上，如果你把系数矩阵写出来，会发现它长这样（图片来自题解）：\n\n对于这种带状矩阵，有复杂度为 O(nd^2) 的消元方法。\n具体可以参考文章：浅谈高斯消元拓展之 band-matrix。\n但高斯消元这东西我学一次忘一次···\n方法二：设一次函数设 f_i=f_{i-1}+b_i，那么发现 b_i 是好求的。\n转移为\n\nf_i=\\frac {i}{n} f_{i-1}+\\frac {n-i}{n}f_{i+1}+1代入得\n\nf_i=\\frac {i}{n} (f_i-b_i)+\\frac {n-i}{n}(f_i+b_{i+1})+1发现 f_i 被消没了，则\n\nb_i = \\frac {(n-i)b_{i+1}+n}{i}边界为 b_n=1。\n然后用 b_i 把 f_i 求出来即可。\n方法三：一种常见的状态设计把之前的 DP 扔了，换状态。\n设 f_i 表示从还剩 i 个键要按到还剩 i-1 个键要按的期望操作步数。\n那么还剩 i 个键时，有以下两种可能：\n\n按对了，概率为 \\frac {i}{n}，代价为 1。\n按错了，概率为 \\frac {n-i}{n}，代价为 f_i+f_{i+1}+1。\n\n则转移为\n\nf_i = \\frac {i}{n}+ \\frac {n-i}{n}\\times(f_i+f_{i+1}+1)为什么代价是这个？\n感觉和之前那个一样吧，但还是再解释一遍：\n可以把代价拆开来看。\n首先，我们按了一次，代价为 1。\n然后，因为按错了，所以现在还剩 i+1 个键需要按。那么从还剩 i+1 个键到还剩 i 个键的代价为 f_{i+1}。\n最后，我们需要把还剩 i 个键变成还剩 i-1 个键（因为这是我们的状态），代价为 f_i。\n我们先按最优解的操作按一遍，得到操作次数 cnt。那么答案为\n\n\\begin{cases}cnt & (cnt \\le k) \\\\ (\\sum_{i=k+1}^{cnt} f_i)+k & (cnt > k)\\end{cases}[SHOI2002] 百事世界杯之旅设 f_i 表示当前已经拿了 i 种物品，那么转移为\n\nf_i=\\frac {i}{n}f_i+\\frac {n-i}{n}f_{i+1}+1移项整理得\n\nf_i=f_{i+1}+\\frac {n}{n-i}初值为 f_n=0，答案为 f_0。\n事实上，你把式子再写一下，会发现 f_0=\\sum_{i=1}^n \\frac {n}{i}。\nLet’s Play Osu!加强版：OSU!\n设 f_i 表示以 i 结尾连续成功长度的期望，g_i 表示以 i 结尾连续成功长度的平方的期望。\n然后根据期望的线性性，E((X+1)^2)=E(X^2+2X+1)=E(X^2)+2E(X)+1。\n所以转移为\n\nf_i=p_i\\times (f_{i-1}+1)\n\\\\\ng_i=p_i\\times (g_{i-1}+2\\times f_{i-1}+1)弱化版答案为 \\sum_{i=1}^n p_i\\times (2\\times f_{i-1}+1)。\n加强版答案为 \\sum_{i=1}^n p_i\\times (3\\times g_{i-1}+3\\times f_{i-1}+1)。\n[Cnoi2020] 线形生物期望的线性性好题。\n设 f_{u \\rightarrow v} 表示 u 到 v 的期望步数，则 f_{u \\rightarrow v}=\\sum_{i=u}^{v-1} f_{i \\rightarrow i+1}。\n设 g_u 表示 u 到 u+1 的期望步数，deg_u 表示 u 的返祖边条数，E 为 u 的返祖边集，则\n\ng_u=\\frac {1}{deg_u+1}\\times 1+\\frac {1}{deg_u+1}\\times\\sum_{(u,v)\\in E} (f_{v,u+1}+1)设 s_i=\\sum_{j=1}^i g_i，则\n\ng_u=1+\\frac {1}{deg_u+1}\\times\\sum_{(u,v)\\in E}s_u-s_{v-1}把 g_u 都放到左边，整理得\n\ng_u=(deg_u+1)+\\sum_{(u,v)\\in E}s_{u-1}-s_{v-1}答案为 s_n。\n[HNOI2013] 游走高斯消元经典题。\n设 f_u 表示点 u 得期望经过次数，g_{u,v} 表示边 (u,v) 的期望经过次数，deg_u 表示点 u 的出度，则\n\ng_{u,v}=\\frac {f_u}{deg_u}+\\frac {f_v}{deg_v}\n\\\\\nf_u=\\sum \\frac {f_v}{deg_v}然后高斯消元把 f 求出来，再用 f 把 g 求出来即可。\n至于编号，我们只需要贪心的给期望经过次数越大的边编号越小即可。\n忽略了很多细节，写的时候需要注意。\nBroken robot也是高斯消元经典题。\n设 f_{i,j} 表示从 (i,j) 走到最后一行的期望步数，转移为\n\nf_{i,j}=\n\\begin{cases}\n\\frac{f_{i+1,j}+f_{i,1}+f_{i,2}}{3}+1 & (j=1)\n\\\\\n\\frac{f_{i+1,m}+f_{i,m}+f_{i,m-1}}{3}+1 & (j=m)\n\\\\\n\\frac{f_{i+1,j}+f_{i,j}+f_{i,j+1}+f_{i,j-1}}{4}+1 & otherwise\n\\end{cases}初始值为 f_{n,i}=0。\n因为只能往下走，所以行没有后效性，但列有后效性。\n所以从下往上消元即可。\n暴力消元复杂度不对，但是你把系数矩阵写出来，发现又是带状矩阵。\n所以按之前的方法消元就行了。\n[HNOI2015] 亚瑟王根据期望的线性性，总伤害就是每张卡的伤害乘上该卡的发动概率，所以考虑如何求出每张卡的发动概率。\n这道题最难的地方就是轮次，如果根据轮次来 DP 的话，会发现有后效性。例如我一开始想的是 f_{i,j} 表示第 i 轮发动 j 的概率，发现转移不了。\n我们换一个思路，既然轮次有后效性，那就不能按轮次 DP 了，而是直接考虑卡牌。\n感觉是和荷取融合很像的套路。\n设 f_{i,j} 表示在整局游戏中，前 i 张牌发动了 j 张的概率，则转移为\n\nf_{i,j}=f_{i-1,j}\\times (1-p_i)^{r-j}+f_{i-1,j-1}\\times (1-(1-p_i)^{r-j+1})解释一下这个转移。\n如果 f_{i,j} 从 f_{i-1,j} 转移来，说明第 i 张牌在整局游戏中都没有发动。\n因为前面已经发动了 j 张，也就是占用了 j 轮的机会，所以概率为 (1-p_i)^{r-j}。\n如果 f_{i,j} 从 f_{i-1,j-1} 转移来，说明第 i 张牌发动了。\n但发动的概率不好求，考虑用 1 减去不发动的概率，为 (1-p_i)^{r-j+1}。\n那每张卡的发动概率就好求了：\n\nP_i=\\sum \\limits_{j=0}^{i-1} f_{i-1,j}\\times (1-(1-p_i)^{r-j})[NOIP2016 提高组] 换教室感觉比较简单。\n设 f_{i,j,0/1} 表示前 i 节课成功换了 j 次教室。\n转移就是考虑换不换，如果换还要考虑能否成功，乘上最短路长度即可。\n是没啥意思的分类讨论，不展开写了。\n最短路用 Floyd 预处理即可。\n","categories":["学习笔记"],"tags":["dp","数学"]},{"title":"连通性问题学习笔记","url":"/posts/2dbb3c01/","content":"联通性这东西学一次忘一次，只能背板子了。\n原理？太困难了算了吧，板子也不难背。\n真想学原理去网上找找别的博客吧。\n考 tarjan 原理就爆了。\n还有，tarjan 的复杂度是 O(n+m) 的。\n模板求割边模板#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define pii pair&lt;int,int&gt; #define fi first#define se secondusing namespace std;const int maxn=1e5+10;int n,m,cnt=1,ans,tim;int head[maxn];int dfn[maxn],low[maxn];struct edge&#123;    int to,nxt;&#125;e[maxn&lt;&lt;1];vector&lt;pii&gt; g;inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u,int eid)&#123;    dfn[u]=low[u]=++tim;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            tarjan(v,i);            low[u]=min(low[u],low[v]);            if(low[v]&gt;dfn[u]) g.push_back(&#123;u,v&#125;);        &#125;        else if(i!=(eid^1)) low[u]=min(low[u],dfn[v]);    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    for(re int i=1;i&lt;=n;++i) if(!dfn[i]) tarjan(i,0);    sort(g.begin(),g.end());    for(auto x:g) cout&lt;&lt;x.fi&lt;&lt;&quot; &quot;&lt;&lt;x.se&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n求割点模板#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=1e5+10,maxm=1e5+10;int n,m,cnt,tim,ans;int head[maxn];int dfn[maxn],low[maxn];bitset&lt;maxn&gt; cut;struct node&#123;    int to,nxt;&#125;e[maxm&lt;&lt;1];vector&lt;int&gt; g;inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u,int fa)&#123;    int son=0;    dfn[u]=low[u]=++tim;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            ++son;            tarjan(v,u);            low[u]=min(low[u],low[v]);            if(u!=fa&amp;&amp;low[v]&gt;=dfn[u]) g.push_back(u);        &#125;        else if(v!=fa) low[u]=min(low[u],dfn[v]);    &#125;    if(u==fa&amp;&amp;son&gt;=2) g.push_back(u);&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    for(re int i=1;i&lt;=n;++i) if(!dfn[i]) tarjan(i,i);    sort(g.begin(),g.end());    g.erase(unique(g.begin(),g.end()),g.end());    for(auto x:g) cout&lt;&lt;x&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\n缩点模板#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define pii pair&lt;int,int&gt;#define fi first#define se secondusing namespace std;const int maxn=1e5+10,maxm=1e5+10;int n,m,cnt,top,tim,scc;int head[maxn];int dfn[maxn],low[maxn],stk[maxn];int col[maxn],f[maxn];int in[maxn];bitset&lt;maxn&gt; vis;vector&lt;pii&gt; g;struct edge&#123;    int to,nxt;&#125;e[maxm];inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u)&#123;    dfn[u]=low[u]=++tim;    stk[++top]=u,vis[u]=1;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            tarjan(v);            low[u]=min(low[u],low[v]);        &#125;        else if(vis[v]) low[u]=min(low[u],dfn[v]);    &#125;    if(dfn[u]==low[u])&#123;        ++scc;        int x;        do&#123;            x=stk[top--];            col[x]=scc;            vis[x]=0;        &#125;while(x!=u);    &#125;&#125;inline void clear()&#123;    cnt=0;    memset(head,0,sizeof head);&#125;inline void topo()&#123;    queue&lt;int&gt; q;    for(re int i=1;i&lt;=scc;++i) if(!in[i]) q.push(i);    while(!q.empty())&#123;        int u=q.front();        q.pop();        for(re int i=head[u];i;i=e[i].nxt)&#123;            int v=e[i].to;            if(!(--in[v])) q.push(v);            //do something here        &#125;    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),g.push_back(&#123;u,v&#125;);    for(re int i=1;i&lt;=n;++i) if(!dfn[i]) tarjan(i);    clear();    for(auto x:g) if(col[x.fi]!=col[x.se]) add(col[x.fi],col[x.se]),++in[col[x.se]];    topo();    return 0;&#125;\n求点双模板#include&quot;bits/stdc++.h&quot;using namespace std;#define re register#define int long longconst int maxn=5e5+10,maxm=2e6+10;int n,m,cnt,tot,top,tim;int head[maxn];int dfn[maxn],low[maxn];int stk[maxn];bitset&lt;maxn&gt; vis;vector&lt;int&gt; g[maxn];struct edge&#123;    int to,nxt;&#125;e[maxm&lt;&lt;1];inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u,int fa)&#123;    int son=0;    dfn[u]=low[u]=++tim;    stk[++top]=u;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            ++son;            tarjan(v,u);            low[u]=min(low[u],low[v]);            if(low[v]&gt;=dfn[u])&#123;                ++tot;                while(stk[top+1]!=v) g[tot].push_back(stk[top--]);                g[tot].push_back(u);            &#125;        &#125;        else if(v!=fa) low[u]=min(low[u],dfn[v]);    &#125;    if(u==fa&amp;&amp;!son) g[++tot].push_back(u);&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    for(re int i=1;i&lt;=n;++i) if(!dfn[i]) tarjan(i,i);    cout&lt;&lt;tot&lt;&lt;&#x27;\\n&#x27;;    for(re int i=1;i&lt;=tot;++i)&#123;        cout&lt;&lt;g[i].size()&lt;&lt;&quot; &quot;;        for(auto j:g[i]) cout&lt;&lt;j&lt;&lt;&quot; &quot;;        cout&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n求边双模板#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=5e5+10,maxm=2e6+10;int n,m,cnt=1,tot,tim;int head[maxn];int dfn[maxn],low[maxn];int col[maxn];bitset&lt;maxm&lt;&lt;1&gt; vis; vector&lt;int&gt; g[maxn];struct edge&#123;    int to,nxt;&#125;e[maxm&lt;&lt;1];inline void add(int u,int v)&#123;    e[++cnt]=&#123;v,head[u]&#125;;    head[u]=cnt;&#125;inline void tarjan(int u,int eid)&#123;    dfn[u]=low[u]=++tim;    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(!dfn[v])&#123;            tarjan(v,i);            low[u]=min(low[u],low[v]);            if(low[v]&gt;dfn[u]) vis[i]=vis[i^1]=1;        &#125;        else if(i!=(eid^1)) low[u]=min(low[u],dfn[v]);    &#125;&#125;inline void dfs(int u,int id)&#123;    col[u]=id;    g[id].push_back(u);    for(re int i=head[u];i;i=e[i].nxt)&#123;        int v=e[i].to;        if(col[v]||vis[i]) continue;        dfs(v,id);    &#125;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(re int i=1,u,v;i&lt;=m;++i) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);    for(re int i=1;i&lt;=n;++i) if(!dfn[i]) tarjan(i,0);    for(re int i=1;i&lt;=n;++i)&#123;        if(!col[i]) dfs(i,++tot);    &#125;    cout&lt;&lt;tot&lt;&lt;&#x27;\\n&#x27;;    for(re int i=1;i&lt;=tot;++i)&#123;        cout&lt;&lt;g[i].size()&lt;&lt;&quot; &quot;;        for(auto j:g[i]) cout&lt;&lt;j&lt;&lt;&quot; &quot;;        cout&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n常见技巧有一些无向图上的问题需要先缩个点/边双然后变成树上问题。\n有一些有向图上的问题需要先缩个点然后变成 DAG，然后拓扑序上搞事情。\n但一般来说难点都在缩完以后搞得那些东西上，例如 dp，贪心，数据结构啥的。\n点不能重复：缩点双。一条边最多属于一个点双。\n边不能重复：缩边双。一个点最多属于一个边双。\n所以把环缩成点要缩边双。\n例题下面选的基本都是一些简单板子题。\n间谍网络缩点板子。\n首先判断无解，然后缩点，然后把入度为 0 的点的权值拿了就行。\n一个强连通分量构成的点的权值为其内所有点的最小权值。\n有机化学之神偶尔会做作弊把环缩成点要缩边双。\n然后变成一颗树，树上距离随便求。\n[USACO5.3] 校园网Network of Schools 首先缩点，那么第一问答案就是入度为 0 的点的个数（和上面那个题一样）。\n第二问要求最少加几条边使得 DAG 变成强连通。\n我们贪心的想，肯定要让无出度点连向无入度点。那么连的边数就是 \\max(无出度点,无入度点)。\n注意特判本来就是强连通的情况。\n采蘑菇缩点以后变为 DAG 上最长路，dp 一下即可。\n[USACO06JAN] Redundant Paths G经典结论题。\n求最少添加多少条边，使得图变成边双连通。\n缩完点双后，统计入度和出度，答案为：（入度和出度之和为 1 的点+1）/2\n正则表达式板子。\n强连通分量内部不需要价值，所以缩点以后 DAG 上最短路即可。\n[APIO2009] 抢掠计划板子。\n强连通分量显然可以全拿，缩点以后 DAG 上最长路即可，注意只能在是酒吧的点取答案。\n[Wind Festival] Running In The Sky板子。\n缩点以后 DAG 上最长路即可，注意还得求个最大值。\n[SDOI2010] 所驼门王的宝藏怎么降蓝了？在 WLFS 做的时候还是紫。\n如果图建好了，那么它是板子，缩点以后 DAG 上最长路即可。\n但难点就在建图。\n直接建是 O(n^2) 的，肯定不行。\n但是每一行的横门可以相互到达，每一列的纵门也可以相互到达。\n对于优化建边有个常见套路：建虚点，然后把边都连向虚点。\n这样边数就是 O(n) 的了。\n[NOIP2022] 建造军营边双缩点后树形 dp。\n但是我不会这个 dp。\n摆。\n[POI2008] BLO-Blockade分情况讨论。\n若 u 不是割点，那么它会和剩下 n-1 个点不连通。\n若 u 是割点，那么显然会得到若干联通块（u 这个点自己也算个连通块）。\n那么答案就是 2\\sum_{i=1}^k siz_i\\times (n-siz_i)。\n求割点时顺便统计一下子树大小即可。\n[HAOI2010] 软件安装缩点以后变成树形背包板子。\n为什么缩完是树？因为题目保证只依赖一个物品。\n[USACO04DEC] Cow Ski Area G把图建出来以后就是[USACO5.3] 校园网Network of Schools 的第二问。\n「TAOI-1」椎名真昼好玩的博弈论。\n先不考虑博弈，只看这张图能不能全变白，可以发现：如果一个强连通分量里有异色点，那就不能。\n所以可以先缩点，顺便判断无解，此时我们得到一张 DAG。\n如果你思考一会，会发现这个游戏是很难有人获胜的。\n除非一步就能赢，否则对方可以一直模仿你的操作使你赢不了。\n所以可以猜到：只有一步能赢的时候才有人能赢，否则平局。\n那么考虑怎么一步赢。\nAlice 是很好考虑的，因为只能操作一次，所以如果遇到一个黑点，那么往后走就不能出现白点。\n如果搜完以后有没搜到的黑点，那么就寄了。\nBob 比较复杂。\n\n若存在至少一个入度为 0 的点为白点，那么 Bob 获胜当且仅当所有点都是白点。因为 Alice 可以让其中一个点变黑，Bob 为了赢必须把这个点弄回来。\n若所有入度为 0 的点均为黑点，如果只有一个那 Alice 肯定赢。如果有两个，那 Bob 肯定赢。否则平局。\n只有两个点，一黑一白，且黑点指向白点，则 Bob 必胜。\n\n综上，Bob 必胜的情况共三种：\n\n两个孤立黑点。\n两个点，一黑一白，且黑点指向白点。\n所有点均为白点。\n\n「EVOI-RD2」旅行家因为边不可以重复经过，所以缩边双。\n变成一棵树后就很简单了，每次覆盖一条路径，求被覆盖过的点的点权和。\n事实上都不用树剖，树上差分即可。\n","categories":["学习笔记"],"tags":["图论"]},{"title":"高斯消元学习笔记","url":"/posts/95a2e91f/","content":"又是一个学一遍忘一遍的算法···\n引入高斯消元，是一个用来求解线性方程组的算法。\n线性方程组是形如这样的方程组\n\n\\begin{cases}\na_{1,1}x_1+a_{2,1}x_2+\\cdots+a_{n,1}x_n\\ \\ = b_1 \n\\\\\na_{1,2}x_1+a_{2,2}x_2+\\cdots+a_{n,2}x_n\\ \\ = b_2 \n\\\\\n\\cdots\n\\\\\na_{1,n}x_1+a_{2,n}x_2+\\cdots+a_{n,n}x_n\\ \\ = b_n \n\\end{cases}实现思路很简单，我们先把系数矩阵消成对角线形式，然后就可以得到解了。\n但是会设计到除法，所以我们要尽量减少精度误差。\n解决方法是：对于每一个未知量，我们都找到系数的绝对值最大的那一项，让它去把别人消掉。\n然后代码就不难得出了。\n复杂度 O(n^3)\ninline void Gauss()&#123;    for(re int i=1,pos;i&lt;=n;++i)&#123;//当前在消哪一个未知量        pos=0;        for(re int j=i;j&lt;=n;++j)&#123;            //找到系数最大的那一行            if(fabs(a[j][i])&gt;fabs(a[pos][i])) pos=j;        &#125;        //如果不存在就跳过        if(fabs(a[pos][i])&lt;eps) continue;        //把这一行换到第i行        swap(a[i],a[pos]);        for(re int j=1;j&lt;=n;++j)&#123;            //把其他行的第i个未知量的系数消掉            if(j==i) continue;            double bs=a[j][i]/a[i][i];            //枚举列，把第j行的所有系数都减去对应的值            for(re int k=i;k&lt;=n+1;++k) a[j][k]-=bs*a[i][k];        &#125;    &#125;    for(re int i=1;i&lt;=n;++i)&#123;        if(fabs(a[i][i])&lt;eps)&#123;//第i个未知数的系数为0（小于eps可以视为0）            if(fabs(a[i][n+1])&gt;eps)&#123;//但对应的值却不是0，说明无解                cout&lt;&lt;&quot;No Solution&quot;;                return;            &#125;            else&#123;//对应值也为0，则该未知数可以随意取值，说明有无数解                //这种未知数称为自由元                cout&lt;&lt;&quot;Numerous Solutions&quot;;                return;            &#125;        &#125;    &#125;&#125;\n拓展异或方程组因为异或满足交换律和结合律，所以可以像普通高斯消元那样进行消元。\n只不过把加减消元换成了异或消元。\n因为涉及位运算，所以可以 bitset 优化。\n复杂度 O(\\frac {n^3}{\\omega})\nbitset&lt;maxn&gt; a[maxn];inline void Gauss()&#123;    for(re int i=1;i&lt;=n;++i)&#123;        int pos=i;        while(pos&lt;=m&amp;&amp;!a[pos].test(i)) ++pos;        if(pos&gt;m)&#123;cout&lt;&lt;&quot;No Solution&quot;;return;&#125;        if(pos!=i) swap(a[pos],a[i]);        for(re int j=1;j&lt;=m;++j)&#123;            if(i!=j&amp;&amp;a[j].test(i)) a[j]^=a[i];        &#125;    &#125;    for(re int i=1;i&lt;=n;++i) cout&lt;&lt;a[i].test(0)&lt;&lt;&#x27;\\n&#x27;;&#125;\n","categories":["学习笔记"],"tags":["数学"]},{"title":"高维前缀和学习笔记","url":"/posts/beb6cf6/","content":"引入首先来看这样一个问题：\n\n\\forall s\\in[0,2^n-1]，求 \\sum_{t \\subseteq s} a_t。\n\n显然可以枚举子集做到 O(3^n)，但高维前缀和可以做到 O(n2^n)。\n那么什么是高维前缀和呢？\n我们先来看一些低维的前缀和，例如二维。\n在求二维前缀和时，我们通常用容斥的方法来求，即\n\ns_{i,j}=s_{i-1,j}+s_{i,j-1}-s_{i-1,j-1}+a_{i,j}但事实上，我们还可以把二维前缀和分解成两次一维前缀和，分别对每一维求前缀和。\nfor(int i = 1; i &lt;= n; i++)    for(int j = 1; j &lt;= n; j++)        a[i][j] += a[i - 1][j];for(int i = 1; i &lt;= n; i++)    for(int j = 1; j &lt;= n; j++)        a[i][j] += a[i][j - 1];\n高维前缀和高维前缀和的思路是类似的。\n我们可以把求集合 s 的子集和的过程看成求一个一共 n 维，每一维大小为 2 的前缀和。\nfor(re int i=0;i&lt;n;++i)&#123;    for(re int s=0;s&lt;(1&lt;&lt;n);++s)&#123;        if((s&gt;&gt;i)&amp;1) f[s]+=f[s^(1&lt;&lt;i)];    &#125;&#125;\n代码中的 f_s 表示集合 s 的子集和。\n阅读代码不难发现，我们事实上就是在干一件事：对每一个子集的每一维分别求前缀和。\n因为是对每一维分别求，所以一定是先枚举维再枚举子集。\n事实上，高维前缀和不止能维护前缀和，它可以维护任何半群信息。\n所以在遇到需要维护一个集合的所有子集的所有子集的半群信息时，都可以用高维前缀和做。\n例题[ARC100E] Or Plus Max下文定义 \\oplus 为按位或。\n首先把 i \\oplus j \\le k 的限制转化掉，所以考虑对每个 k 分别计算。\n设 A_k=\\max_{i \\oplus j =k,i \\neq j} a_i+a_j，那么 ans_k=\\max_{i=1}^k A_i。\n但这个 A_i 依旧不好算，我们考虑拓宽限制。\n设 B_k=\\max_{i,j \\subseteq k,i \\neq j} a_i+a_j，那么 ans_k=\\max_{i=1}^k B_i。\n这为什么是对的？A_i 不一定等于 B_i 啊？\n这是因为 i,j \\subseteq k 是 i \\oplus j =k 的必要条件，是 i \\oplus j \\le k 的充分条件。\n所以 i,j \\subseteq k,i \\neq j 的所有元素 (i,j) 一定完全包含 i \\oplus j =k,i \\neq j 的所有元素，且不包含 i \\oplus j >k 的任何元素，但可能会包含 i \\oplus j < k 的元素。\n但这不影响，因为我们的答案是前缀 \\max，所以统计到的答案依旧是对的。\n那么现在问题变成了 \\forall k\\in[1,2^n-1]，求 \\max_{i,j \\subseteq k,i \\neq j} a_i+a_j。\n不难发现，我们的 \\max 一定是最大和次大相加得到，所以只需要对于所有 k，维护子集最大和次大即可。\n这显然可以高维前缀和维护。\n复杂度 O(n2^n)\n#include&quot;bits/stdc++.h&quot;#define re register#define int long long#define pii pair&lt;int,int&gt;#define fi first#define se secondusing namespace std;const int maxn=(1&lt;&lt;18)+10,inf=1e18;int n,S;pii f[maxn];inline void upd(pii &amp;a,pii b)&#123;    if(b.fi&gt;a.fi) a.se=max(a.fi,b.se),a.fi=b.fi;    else a.se=max(a.se,b.fi);&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n;S=(1&lt;&lt;n)-1;    for(re int i=0;i&lt;=S;++i) cin&gt;&gt;f[i].fi,f[i].se=-inf;    for(re int i=0;i&lt;n;++i)&#123;        for(re int s=0;s&lt;=S;++s)&#123;            if((s&gt;&gt;i)&amp;1) upd(f[s],f[s^(1&lt;&lt;i)]);        &#125;    &#125;    int ans=0;    for(re int i=1;i&lt;=S;++i) ans=max(ans,f[i].fi+f[i].se),cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;    return 0;&#125;\nVowels光题意就理解了半天···\n一个非常直接的想法：对于每一个单词，我们都枚举超集，然后贡献到超集上。\n这里的贡献注意不要算重，所以需要容斥一下。\n具体的，我们对每一个子集都枚举超集，然后加贡献时带上容斥系数。\n设 S 为单词长度，V 为字符集大小，则总复杂度为 O(n2^S2^V)\n但这样每次都枚举超集太浪费了，能不能优化？\n所以我们可以这样：对于每一个单词，先把贡献加到子集上，然后最后一块算贡献。\n这样就可以只枚举一次了。\n最后算贡献的时候，事实上就是求每个子集的子集和，高维前缀和即可。\n复杂度为 O(n2^S+V2^V)\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=(1&lt;&lt;24)+10,m=24,S=(1&lt;&lt;24)-1;int n;int f[maxn];signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n;char c;    for(re int i=1;i&lt;=n;++i)&#123;        int t=0,cnt=0;        for(re int j=1;j&lt;=3;++j) cin&gt;&gt;c,t|=(1&lt;&lt;(c-&#x27;a&#x27;));        for(re int s=t;s;s=(s-1)&amp;t)&#123;            if(__builtin_popcountll(s)&amp;1) ++f[s];            else --f[s];        &#125;    &#125;    for(re int i=0;i&lt;m;++i)&#123;        for(re int s=0;s&lt;=S;++s)&#123;            if((s&gt;&gt;i)&amp;1) f[s]+=f[s^(1&lt;&lt;i)];        &#125;    &#125;    int ans=0;    for(re int s=0;s&lt;=S;++s) ans^=(f[s]*f[s]);    cout&lt;&lt;ans;    return 0;&#125;\n拓展子集和能做，超集和呢？\n事实上也很简单，子集和时我们是子集向自己贡献，那超集和只需要自己向子集贡献即可。\nfor(re int i=0;i&lt;n;++i)&#123;    for(re int s=0;s&lt;(1&lt;&lt;n);++s)&#123;        if((s&gt;&gt;i)&amp;1) f[s^(1&lt;&lt;i)]+=f[s];    &#125;&#125;\n前缀和能做，差分呢？\n只需要符号变一下就行了。\n也不难理解，毕竟前缀和的逆运算就是差分。\nfor(re int i=0;i&lt;n;++i)&#123;    for(re int s=0;s&lt;(1&lt;&lt;n);++s)&#123;        if((s&gt;&gt;i)&amp;1) f[s]-=f[s^(1&lt;&lt;i)];    &#125;&#125;\n","categories":["学习笔记"],"tags":["dp","数学"]}]