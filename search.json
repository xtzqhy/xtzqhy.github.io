[{"title":"2024.10.2","url":"/2024/10/02/2024-10-2/","content":"Team Building *2300\n首先可以想到暴力 dp。\n设 f_{i,j,S} 表示前 i 个人，选了 j 个观众，队伍的选择状态为 S。\n复杂度是炸的。\n但仔细想想，我们真的要记这么多状态吗？\n如果你把这道题想成一个普通的背包，那就错了，因为这题很特殊。\n每个物品的体积都是 1。\n这说明此时贪心是正确的。\n我们按观众值降序排序，那么对于观众值而言，一定是全选前面的更优。\n设 f_{i,S} 表示前 i 个人，队伍的选择状态为 S，num_S 为 S 里 1 的个数。\n转移时，如果当前观众人数小于 k，那么一定是让他当观众最优。\n因为观众是能选就选的，所以观众人数很容易得出，就是 i-num_S。\n复杂度 O(n2^p)\nMinimal Labels *2300\n第一眼看到以后以为是拓扑板子，直到看到第三个样例。\n经过手玩可以发现，我们应该每次都先填未填的点里编号最小的点，这样才能让字典序更小。\n但是编号最小的点可能被一些点指向，所以要先把前面的那些点给填上。\n前面那些点又构成一张新图，这就是一个子问题了，递归解决即可。\n找前面点可以建反图往回跑即可。\n复杂度？\n然而正解是建反图后拓扑，然后倒序编号。\n我们刚才的思路都是正着来的，那为什么倒着才是对的呢？\n正解是对的比较好理解，但感性理解一下，我们的做法似乎和倒着做是一样的？\nTrains and Statistic *2300\n类似 Floyd，对于两个点，我们要么一步到，要么找一个中转点。\n而这道题不需要 O(n^3) 的原因是：每个点能到的区间是一定的。\n所以我们可以贪心。\n既然一步走不到，那肯定走的越远越好。\n所以我们一定会从 i 走到 [i+1,a_i] 里 a 最大点 j。\n设 f_i=\\sum_{j=i+1}^n p_{i,j}。\n那么 f_i 只会从 f_j 转移来。\n转移为\n\nf_i=f_j+n+j-a_i-i首先让编号 >j 的点强制从 j 转移过去，那么这部分答案是 f_j+n-j。\n这会把 [j+1,a_i] 里的点多算一步，那么减去 a_i-(j+1)+1。\n最后加上 [i+1,j] 的点，他们只需要走一步，是 j-(i+1)+1。\n合起来就是 f_j+n+j-a_i-i。\n求 j 是一个 RMQ 问题，随便做。\n复杂度 O(n\\log n)\nMonster Invaders *2300\n又读错题。\n贪心肯定是很难贪的。考虑 dp。\n但是 dp 是不是有后效性？毕竟可以从前面过来，还可以从后面过来。\n难道要高斯消元解方程组？复杂度也接受不了啊。\n但你仔细想想，我们真的会从很后面的地方过来吗？\n显然不会。\n如果我们现在在 i，剩个 boss 差一血没打死，然后被强制移到了 i+1。\n假设我们一直往后打，直到  j 才往回走，把 i 剩下的 boss 打死。\n那么我们为什么不在被迫移动到 i+1 的时候就直接回去把 boss 打死？这肯定更优。\n想明白了这个，剩下就很简单了。\n然后考虑用什么方式把 i 清完。\n这里我读错题了，没看到 r_1 \\le r_2 \\le r_3。\n既然这样，那么每个房间只有这几种方法：\n\n手枪打小怪，AWP 打 boss。\n用激光枪（或手枪）对所有人各打一点伤害，被迫移动后，再移动回来，然后手枪解决 boss。\n\n转移很简单。\n注意最后重点可能是 n-1，也可能是 n。\nKeshi in Search of AmShZ *2300\n竟然是原理题。\n读完题后又瞬间想到一个假贪心：把最短路以外的边封掉，然后强制走最短路。\n显然不正确。我们可以少封一些边，然后走最长路，这样代价可以更小。\n考虑这张图确定了下来，那么对方一定会走最长路。\n设 f_u 表示 u 到 n 的最大代价。\n考虑一条边 (u,v)，如果我们经过了这条边，那么说明经过 u 必须是一条最长路。\n那么我们必须把比 u 还长的删掉。即转移为\n\nf_u=\\min_{v \\in to_u} (f_v+1+\\sum_{v'\\in to_u} [f_{v'}>f_v])直接转移复杂度是炸的。\n那么能不能在反图上跑时转移呢？\n但是如果倒着转移的话，无法确定 \\sum_{v'\\in to_u} [f_{v'}>f_v]) 的值。\n然后我们钦定转移顺序，让 f_v 从小到大转移，这样 \\sum_{v'\\in to_u} [f_{v'}>f_v]) 就满足了单调性。\n用优先队列维护最小即可。\n复杂度 O((n+m)\\log m)\n","categories":["每日记录"],"tags":["Codeforces","dp","贪心"]},{"title":"2024.9.27","url":"/2024/09/27/2024-9-27/","content":"一直在搭博客没怎么做题啊···\nTourism *2200\n首先手玩样例可以发现：环上的点可以都拿，连接环的点也可以都拿。\n然后考虑剩下的点。\n因为剩下的点只能选一条点权和最大的路径，所以考虑拓扑 dp。\n那么答案就是起点到环经过的点 + 环上的点的点权和 + \\max f_i\n学到的东西：看到这种类似不能重复走一条边的东西可以考虑缩点双（因为割边走过去不能回来）\nHappy Line *2200\n感觉很困难。我是性质低手/kk。\n假设当前 a_i,a_{i+1}  需要操作，那么操作完后会变成 a_{i+1}+1,a_i-1。\n对于 a_i，可以发现 a_i+i=(a_i-1)+(i+1)。\n即 val_i+pos_i=val_i'+pos_i'。\n不难推出，对于所有 i，都有 a_i+i 为定值。\n那么将 a_i+i 排序得到序列 b，答案就是 b_i-i。\n无解就是存在 b_i=b_{i+1}。\n学到的东西：对于这种交换位置的题，要往排序想，分析两个元素交换带来的影响（类似微扰法）。\nShort Code *2200\n读完题瞬间想到一个假做法：按长度从小到大排序，然后模拟。\n但这很容易 hack。对于一个很长的串，我们完全可以让它取很短的一部分，让一些短串取稍微长一些。这样比长串取很长短串取很短要优。\n那从大到小呢？也不行。\n因为很有可能长串取完以后，一些短串作为长串的前缀，就算全取也无法避免重复，这就不合法了。\n然后不会了。\n正解：\n建立 trie 树。此时问题变为：\n给一棵树，有一些黑点。可以把黑点移到祖先处，但两个黑点不能在同一个位置。求最小的黑点深度和。\n用堆维护每颗子树中黑点的深度，如果根上没有黑点就把最深的移到根。\n学到的东西：看到字符串前缀想到 trie（还是字符串做少了）。\n","categories":["每日记录"],"tags":["Codeforces","贪心"]},{"title":"2024.10.3","url":"/2024/10/03/2024-10-3/","content":"模拟赛\n\n数据范围：n \\le 100,1\\le a_i,b_i,c_i \\le 10^9\n值域很大，无法加到状态里。那么考虑每个操作对答案产生的贡献。\n我们把攻击力拆开来算。\n直接攻击，那么贡献就是 a_i。\n设这回合后一共攻击 j 次。\n加攻击力，那么在这以后每次攻击伤害都会加 c_i，贡献就是 j\\times c_i\n加增量，那么设后续攻击的回合是 p_1,p_2,\\cdots,p_j，那么贡献为 \\sum_{k=1}^j (p_k-i)\\times b_i。\n把这个东西稍微拆一下，得到 b_i(\\sum_{k=1}^j p_k-j\\times i)。\n那么我们只需要记录攻击次数和攻击回合的编号和即可。\n但有个问题，我们现在的贡献和未来回合的行动有关。\n所以要倒过来做。那么转移也要相应的变一下。\n设 f_{i,j,k} 表示第 i 个回合到最后一个回合，一共攻击了 j 次，攻击回合的编号和为 k 的最大值。\n转移为\n\nf_{i,j+1,k+i}=f_{i+1,j,k}+a_i\n\\\\\nf_{i,j,k}=f_{i+1,j,k}+(i\\times j-k)\\times b_i\n\\\\\nf_{i,j,k}=f_{i+1,j,k}+j\\times c_i转移时可以把第一维压掉，但第二维要倒序枚举。\n复杂度 O(n^4)。\nCode：\n#include&quot;bits/stdc++.h&quot;#define re register#define int long longusing namespace std;const int maxn=110,inf=1e18;int n;int a[maxn],b[maxn],c[maxn],f[maxn][maxn*maxn];inline void solve()&#123;    cin&gt;&gt;n;    for(re int i=1;i&lt;=n;++i) cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];    reverse(a+1,a+n+1);reverse(b+1,b+n+1);reverse(c+1,c+n+1);    memset(f,-0x3f,sizeof f);    f[0][0]=0;    for(re int i=1;i&lt;=n;++i)&#123;        for(re int j=i-1;j&gt;=0;--j)&#123;            for(re int k=0;k&lt;=(i-1)*i/2;++k)&#123;                f[j+1][k+i]=max(f[j+1][k+i],f[j][k]+a[i]);                f[j][k]=max(f[j][k],f[j][k]+max((i*j-k)*b[i],j*c[i]));            &#125;        &#125;    &#125;    int ans=-inf;    for(re int i=0;i&lt;=n;++i) for(re int j=0;j&lt;=n*(n+1)/2;++j) ans=max(ans,f[i][j]);    cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;&#125;signed main()&#123;#ifndef ONLINE_JUDGE    freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);#endif    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    int T;cin&gt;&gt;T;while(T--) solve();    return 0;&#125;\nRemoving Leaves *2300\n又读错题被硬控了。\n一开始没看见 k，以为随便删。\n考虑贪心。\n我们用 set 存每个节点，然后每次找到叶子最多的那个点，然后删 k 个。找不到就结束。\n这为什么是对的？\n感性理解一下，我们这么做只会让能删的点越来越多，而且不会有本来能删的点因为操作而不能删除，所以这么做操作数就是最大的。\n复杂度 O(n\\log n)\nVoting (Hard Version) *2400\n看完题就想到了一个假贪心：先按 m 降序再按 p 升序，每次买 m 最大 p 最小的。\n显然不对。我们不一定只从 m 最大的里面买。\n那改成每次买 p 最小的呢？\n还是不对。因为不一定买最小的就优。例如这组样例\n21 12 2\n显然只需要 2 即可。\n那应该怎么做？\n我们依旧按 m 降序排序。\n对于当前的 m_i，设 m 值小于 m_i 的人数为 pre，大于 m_i 且被买的人数为 cnt。\n假设我们已经把 < m_i 的人全搞定了，那么只需要让 pre+cnt\\ge m_i，就能搞定 m_i了。\n但如果不满足，我们就要从 \\ge m_i 的人里买人（因为 pre 是固定的），直到 pre+cnt\\ge m_i。\n满足该条件后，m_i 就被我们搞定了。\n那么我们只需要保证 < m_i 的人都被搞定就行了。\n然后再处理 < m_i 的那些人。这是一个子问题，和上述步骤完全一致。\n买人贪心买最便宜的，用个堆维护一下即可。\n复杂度 O(n\\log n)\nHappy Life in University *2300\n怎么现在啥数据结构都不会了/kk。\n对于这种 lca 的问题，常见套路是枚举 lca，把贡献都在 lca 处统计（枚举 lca 的意思是考虑每个点作为 lca 时的情况）。\n而这种 lca 的路径问题又能跟子树弄上关系。\n设当前考虑到以 u 为根的子树。\n那么我们只需要维护 u 到子树内节点的路径即可，答案就是拿两条路径拼起来。\n假设已经搜完了子树，回溯到了 u。\n那么 u 会对所有路径产生自己颜色的贡献。\n但显然会算重，那么考虑去重。\n因为每个点只需要在离他最近的且颜色和他相同的祖先处减去重复，所以只会操作 O(n) 次。\n那么直接去重就是对的。\n所以我们的操作就只有子树加和子树查，线段树维护。\n答案用最大值和次大值拼一下即可。\n复杂度 O(n\\log n)\nWine Factory (Easy Version) *2300\n讲一个很有意思的做法。\n我们考虑有多少水被浪费了。\n设 f_i  表示从 i 流向 i+1 的水的量。\n转移为 \n\nf_i=\\max(f_{i-1}+a_i-b_i,0)这东西可以用 (max,+) 矩乘表示。\n\n\\begin{bmatrix}\nf_i \n\\\\\n0 \n\\end{bmatrix}\n=\n\\begin{bmatrix}\na_i-b_i & 0 \n\\\\\n-inf & 0\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\nf_{i-1} \n\\\\\n0 \n\\end{bmatrix}然后线段树维护矩阵即可。单点修改也是简单的。\n复杂度 O(k^3n\\log n)\nMark and Professor Koro *2300\n感觉和 [HBCPC2024] Enchanted 非常的像啊，套路也是一样。\n对于这种两个相同的数合并成+1的数的操作，我们可以把它看成二进制意义下的加法，然后进行维护。\n但这个题不能直接把数的二进制用整数表示，值域太大了。\n我们用线段树维护值域上每个数出现次数，不难发现每个数出现次数只会为 0/1。\n那么修改可以看成删一个数再加上一个数。\n删和加是类似的，先考虑加。设加的那个数是 x。\n如果 x 那一位是 0，那么不用进位，直接给这一位 +1 即可。\n否则会进位。但不难发现，这东西是一次区间覆盖和一次单点修改。\n删数同理。\n如果 x 那一位是 1，那么不用退位，直接给这一位 -1 即可。\n否则会退位。依旧是一次区间覆盖和一次单点修改。\n那么答案就是最右边的 1 的位置，这个可以线段树上二分找到。\n具体的，线段树上维护区间里 1 的个数。\n加法进位：找到 x 后第一个为 0 的位置 pos，然后把 [x,pos-1] 区间赋值为 0，把 pos 赋值为 1.\n减法进位：找到 x 后第一个为 1 的位置 pos，然后把 [x,pos-1] 区间赋值为 1，把 pos 赋值为 0.\n找位置都可以线段树上二分。\n复杂度 O(n\\log n)\n","categories":["每日记录"],"tags":["Codeforces","dp","模拟赛","数据结构"]},{"title":"2024.9.29","url":"/2024/09/29/2024-9-29/","content":"Funny Game *2200\n看了半个小时不会后看题解被嘲讽简单题后破防。\nKirill and Company *2200\n终于做到会的题了。\n看到 k 这么小，直接考虑状压。\n在处理最短路时，我们还要处理出每个点的搭载朋友情况。\n最后就是一个背包。\n复杂度 O((n+m)2^k+f(2^k)^2)\nRailguns *2200\n你指尖跃动的电光，是我此生不变的信仰。\n似乎不太难想？\n首先可以发现，答案上界为 n+m+r，因此可以枚举答案。\n设 f_{i,j,k} 表示第 k 秒时能否到达 (i,j)。转移为\n\nf_{i,j,k}|=(f_{i-1,j,k-1}|f_{i,j-1,k-1}|f_{i,j,k-1})我们在最外层枚举时间，然后 dp 即可。\n至于超电磁炮，我们都已经枚举时间了，那 dp 之前把对应状态直接限制一下就行了。\n复杂度 O(nmr)\n","categories":["每日记录"],"tags":["Codeforces","dp"]},{"title":"2024.9.30","url":"/2024/09/30/2024-9-30/","content":"Darth Vader and Tree *2200\n首先考虑暴力。\n设 f_i 表示距离根距离恰好为 i 的数量。转移为\n\nf_i=\\sum_{j=1}^n f_{i-d_j}但观察数据范围，发现 d_i\\le 100，说明不同的 d_i 很少。\n那么只需要对这些不同的 d_i 转移就行了。\n设 num_i=\\sum_{j=1}^n [d_j=i]，那么转移为\n\nf_i=\\sum_{j=1}^V num_j\\times f_{i-j} 这是一个常系数齐次线性递推方程，BM算法矩阵快速幂即可。\n最终答案为 \\sum_{i=1}^x f_i，可以在矩阵里顺便维护一下。\n复杂度 O(V^3\\log x)\nVladik and cards *2200\n容易想到状压。\n但第一个条件感觉很难搞，没法记录每个元素出现次数，怎么办？\n我们可以二分出所有的数字的最小出现次数 mid，那么每个元素出现次数只能为 mid 和 mid+1（经常在错解里想到这种思路，终于在这道题成为正解了）。\n设 f_{i,S} 表示到第 i 个位置，数字出现状态为 S 时，出现次数为 mid+1 的数的最大个数。\n这么设状态是因为，一个数的出现次数只能为 mid 和 mid+1，那肯定让 mid+1 的个数越多越好。\n转移比较简单，看每个数字出现 mid 次还是 mid+1 次即可。\n我们可以把每个数字出现的位置记录下来，方便转移。\n注意每种数字必须连续，也就是出现过后就不能再转移了。\n复杂度 O(2^Vn\\log n)\nTreeland Tour *2200\n树上路径问题直接考虑点分治。\n设当前分治重心为 rt，我们求出从叶子往 rt 走且以 i 结尾的 LIS 和 LDS。\n这个东西怎么求呢？\n每个点都只能从子树转移来，所以问题就是单点加子树查，弄个 dfn 序后线段树维护即可。\n统计答案时，考虑包不包含 rt。\n设 up_i 表示以 i 结尾的 LIS 长度， down_i 表示以 i 结尾的 LDS 长度。\n对 up_i 和 down_i 分别做前缀 max 和后缀 max。\n包含 rt：ans=\\max up_{a_{rt}-1}+down_{a_{rt}+1}+1\n不包含 rt：ans=\\max up_i+down_{i+1}\n然后完了？\n显然没有，因为如果两条路径来自同一颗子树内就寄了。\n那么线段树在维护时，记录最大值和次大值，以及来自哪棵子树即可。\n统计答案时特判一下。\n复杂度 O(n\\log^2 n)\nFelicity’s Big Secret Revealed *2200\n简单性质题。\n不难发现答案 x 不会很大。因为 n\\le 75，所以 x\\le 20。 \n那就考虑状压，设 f_{i,S} 表示这一刀切在 i 前，状态为 S 时的方案数。\n转移就枚举上一刀切在哪。\n转移为 \n\nf_{i,S}=\\sum f_{j,S/T}把 [j,i-1] 组成的数去掉即可。\n答案为 \\sum f_{i,2^j-1}\n复杂度 O(n2^V)\nAbbreviation *2200\n唐唐唐，下次读题能不能读仔细点。\n做了半个小时+看了半天题解才发现翻译里最后一句写着“至多进行一次操作”\n绷不住了。\n那就好做了。枚举缩哪一段区间即可。\n具体的，我们可以先处理出 f_{i,j} 表示 i 和 j 向后匹配的最长长度。\n然后枚举缩哪段区间，然后向后暴力缩就行了。\n复杂度 O(n^3+n|\\sum s_i|)\n代码可参考官方题解。\nThree Pieces *2200\n很厉害的一道题，完全没想出来。\n考虑 dp。\n设 f_{i,j,k,0/1/2} 表示当前在 (i,j)，已经填了 1\\sim k，且当前是 0/1/2 棋子的最小花费。\n但这个 dp 有一个问题：不知道转移顺序。\n所以考虑用最短路转移。\n转移分三种：\n\n换棋子，代价为 inf+1\n移动棋子，代价为 inf\n填数（即 (i,j) 所在的数是下一个数），代价为 0\n\n这里有一个 trick：因为还要求换的次数最小，所以可以设一个极大值，将移动棋子设为 inf，换棋子设为 inf+1，这样就可以做到双关键字了。\n输出答案时，时间就是 ans/inf，换的次数就是 ans\\%inf。\n一共 O(n^4) 个点，O(n^5) 条边。\n","categories":["每日记录"],"tags":["Codeforces","dp","贪心","数据结构"]},{"title":"2024.9.28","url":"/2024/09/28/2024-9-28/","content":"LaIS *2200\n没太想出来。\n设 f_i 表示以 i 为结尾的最长子序列长度。\n考虑如何从 j 转移到 i。\n若 a_j\\le a_i，那么直接转移即可。\n若 a_j > a_i，则需要考虑 j 的前驱 k。\n因为需要满足 \\min(a_k,a_j)\\le \\min(a_j,a_i)，即 a_k \\le a_i。\n那么我们贪心的想，让 j 越靠右越好，因为这样前驱 k 的范围就更大。\n那么我们维护一个单调栈，求出每个 i 左侧的第一个 j，使得 a_j > a_i。\n转移用树状数组即可。\n复杂度 O(n\\log n)\nHelping Hiasat *2200\n开到抽象题了。\n第一遍读错题了，没看到每一次都得一样。\n如果没有这个限制的话就很简单了，把相邻两个 1 之间划分成一个区间，找每个区间的众数即可。\n但现在有这个限制，怎么办？\n依旧考虑划分成若干区间，那么两个人可以共存当且仅当两个人从未同时出现过。\n如果两个人不能共存，那么就连一条边。最后求出这个图的最大独立集即可。\n这是一个 NPC 问题。\n不过有结论：原图的最大独立集=补图的最大团。\n最大团可以用 Bron–Kerbosch 算法在 O(2^{\\frac{n}{2}}) 的复杂度内求出。\n复杂度 O(nm^2+2^{\\frac{m}{2}})\nDemiurges Play Again *2200\n首先考虑权值给定怎么做。\n设 f_{u,0/1} 表示 u 点先/后手能取到的值。转移为\n\nf_{u,0}=\\max_{v \\in sub_u} f_{v,1}\n\\\\\nf_{u,1}=\\min_{v \\in sub_u} f_{v,0}然后考虑放权值。\n依旧设 f_{u,0/1}，表示 u 点先/后手能取到的值是该子树内第 f_{u,0/1} 大的数。\n那么转移是类似的，不过变成了第几大。\n对于 f_{u,0}，取 \\min 即可。\n对于 f_{u,1}，下一步由对方取最大值，而无论怎么放权值，对方都有可能不选择某子树。所以问题可以看作我们需要放多少个数进入叶子结点才可以让此时的玩家保证能够取到数。而能取到的最小值就是这些数的最后一个。因为是子树内的第几大，所以可以直接求和。\n综上，转移为\n\nf_{u,0}=\\min_{v \\in sub_u} f_{v,1}\n\\\\\nf_{u,1}=\\sum_{v \\in sub_u} f_{v,0}那么答案分别为 m-f_{1,0}+1,f_{1,1}。\n复杂度 O(n)\n因为有单调性，所以也可以二分变成判定性问题，不过似乎有点多此一举？\nYet Another Array Counting Problem *2300\n开到了笛卡尔树上 dp 板子。\n以下标为键，a_i 为值建立大根笛卡尔树，那么 [l,r] 的最左端最大值位置就是 l,r 在笛卡尔树上的 \\operatorname{lca}。\n那么所有最左端最大值位置都相等，就意味着笛卡尔树的形态相同。\n此时转化为树计数问题。\n设 f_{u,i} 表示 u 取值 1 \\sim i 的方案数。\n左儿子可以填 [1,i-1]，右儿子可以填 [1,i]\n转移就是 f_{u,i}=f_{u,i-1}+f_{ls_u,i-1}\\times f_{rs_u,i}\n复杂度 O(nm)\n","categories":["每日记录"],"tags":["Codeforces","dp"]},{"title":"test","url":"/2024/09/27/test/","content":"\n      \n        b6d9dfa549147f0632b315f54d4544272cb5f714c8d4249f0bd0f1658f458372beef2254cd477e84ddea3da8c143e04bbd29b0c490129037e5520e4fc2dd69138069b00d7bfae2486bc3dd53645efd0ae6e57fdee23337f687d5ac05503845e2b92235090ca23eea5cfa14778d0dadc7\n      \n      \n        \n          \n          \n            请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n          \n        \n        \n      \n    \n    "},{"title":"笛卡尔树学习笔记","url":"/2024/09/28/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"笛卡尔树是一种二叉树，它既满足二叉搜索树的性质，又满足堆的性质。\n例如 treap，就属于笛卡尔树的一种。\n以下规定：第一键值为满足二叉搜索树的键值，第二键值为满足堆的键值。\n如何构建笛卡尔树\n我们可以用单调栈做到 O(n) 建树。\n我们考虑将下标作为第一键值，权值作为第二键值。\n那么每次我们插入的元素必然在这棵树的右链（右链：即从根节点一直往右子树走，经过的节点形成的链）的末端。\n所以我们可以用栈来维护笛卡尔树的右链。\n假设我们要建一颗大根笛卡尔树。\n设当前位置为 i，前 i-1 个位置已经构建好了。设栈顶元素为 a_{top}。\n我们维护值单调递增的单调栈。\n若 a_i \\le a_{top}，直接将 i 入栈（也就是把 i 挂在右链上）。\n否则一直弹栈，直到栈空或 a_i \\le a_{top}。把最后一个弹出的元素设为 i 的左儿子。\nfor(re int i=1;i&lt;=n;++i)&#123;    int tmp=top;    while(tmp&amp;&amp;a[stk[tmp]]&lt;a[i]) --tmp;    if(tmp) rs[stk[tmp]]=i;    if(tmp&lt;top) ls[i]=stk[tmp+1];    stk[++tmp]=i;    top=tmp;&#125;\n事实上，如果要按某个值作为第一键值，那么按这个值排序即可。\n可以发现，笛卡尔树的根就是 stk_1。\n应用\n笛卡尔树大多用来 dp。\n对原问题转化后，变为笛卡尔树上的 dp 问题。\n而且一般只会用到思想，并不会真把树建出来。\n以及一些直方图似乎也会用到。\n对于直方图类问题，我们常把下标作为第一键值，h_i 作为第二键值建立小根笛卡尔树。\n例题\n[TJOI2011] 树的序\n一道考察笛卡尔树定义的题。\n题目给的很明白了，要按权值当第一键值。\n因为要求字典序最小的生成序列，所以我们把每个数在序列中的位置当作第二键值，然后建小根笛卡尔树即可。\n因为插入顺序是父亲-&gt;左儿子-&gt;右儿子，所以输出先序遍历即可。\n注意输出的是键而不是编号。\nLargest Rectangle in a Histogram\n笛卡尔树求矩形面积板子题。\n我们把下标作为第一键值，h_i 作为第二键值建立小根笛卡尔树。\n枚举点 u，看当 h_u 作为矩形的高度时的最大面积。\n因为我们建的是小根树，所以子树内的点的 h_i 都大于 h_u。\n因为下标是键，所以子树内的点构成一段连续区间。\n那么以 h_u 作为高时的最大面积为 siz_u\\times h_u。\n[COCI2008-2009#4] PERIODNI\n我们考虑把这个多边形转成树。\n受上题启发，我们把下标作为第一键值，h_i 作为第二键值建立小根笛卡尔树。\n\n我们每次找到最低点，分成左右两边，然后递归处理。\n不难发现，这些矩形对应笛卡尔树上的所有节点。\n对于点 u,它代表的长为 siz_u，宽为 h_u-h_{fa}。\n因为两个儿子是分开的，所以可以直接合并，没有影响。\n设 f_{u,i} 表示以 u 为根的子树放了 i 个的方案数，g_{u,i} 表示以 u 为根的子树放了 i 个，且不包括 u 代表的矩形的方案数。\n那么 g 的转移就是背包。\n\ng_{u,i}=\\sum_{j=0}^i f_{ls,j}\\times f_{rs,i-j}至于 f 的转移，就是考虑 u 放几个。\n有结论：大小为 n\\times m 的棋盘，放 k 个互不攻击的车，方案数为 \\binom{n}{k}\\times \\binom{m}{k}\\times k!\n那么枚举子树一共用了几个，剩下的就是自己用的。\n注意子树用了的自己不能用。\n\nf_{u,i}=\\sum_{j=0}^i \\binom{siz_u}{i-j}\\times \\binom{h_u-h_{fa}}{i-j}\\times (i-j)!\\times g_{u,j}复杂度 O(nk^2+n^2)\nYet Another Array Counting Problem\n以下标为第一键值，a_i 为第二键值建立大根笛卡尔树，那么 [l,r] 的最左端最大值位置就是 l,r 在笛卡尔树上的 \\operatorname{lca}。\n那么所有最左端最大值位置都相等，就意味着笛卡尔树的形态相同。\n此时转化为树计数问题。\n设 f_{u,i} 表示 u 取值 1 \\sim i 的方案数。\n左儿子可以填 [1,i-1]，右儿子可以填 [1,i]\n转移就是 f_{u,i}=f_{u,i-1}+f_{ls_u,i-1}\\times f_{rs_u,i}\n复杂度 O(nm)\n","categories":["学习笔记"],"tags":["数据结构"]}]